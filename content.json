{"meta":{"title":"zsky's Blog","subtitle":"","description":"某211研一在读|CTF_RE选手|tcl","author":"zsky","url":"https://zzzzsky.github.io","root":"/"},"pages":[{"title":"记录本fw的学习","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-19T03:51:47.540Z","comments":true,"path":"about/index.html","permalink":"https://zzzzsky.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-18T14:36:30.000Z","updated":"2021-11-19T00:57:24.730Z","comments":true,"path":"tags/index.html","permalink":"https://zzzzsky.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-11-18T14:36:52.000Z","updated":"2021-11-19T01:58:59.031Z","comments":true,"path":"categories/index.html","permalink":"https://zzzzsky.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-19T07:15:39.566Z","comments":true,"path":"link/index.html","permalink":"https://zzzzsky.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"2021GFCTF部分RE_WP","slug":"2021GFCTF_WP","date":"2021-11-25T09:05:00.000Z","updated":"2021-11-25T09:06:08.774Z","comments":true,"path":"2021/11/25/2021GFCTF_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/25/2021GFCTF_WP/","excerpt":"","text":"2021GFCTF RE_WPwordy去除花指令 123456789addr =0X556AE377FD56end = 0x0556AE377FE40flag = &quot;&quot;for i in range(addr, end, 13): c = get_bytes(i+4, 1)[0] flag+=chr(c) print(flag)# GFCTF&#123;u_are2wordy&#125; BabyReverseIDA打开，去除所有的花指令 直接看下面对flag如何加密的，进入sub_412E10, 发现是SM4加密 而传入的第二个参数是key，即byte_4409c0是key，回到main函数再往上看，发现前面有一个对byte_4409c0类似RC4加密的操作, 对 byte_4409C0进行交叉引用 于是下断点调试来获取key，发现不行，猜测前面是反调试，从main函数头部下断点调试 最终定位到这个函数 采用的是self_mapping技术实现反调试，本质是创建secion的时候设置SEC_NO_CHANGE，映射后不能改变 Self-Remapping-Code 关于这个技术，可以参考下这位大佬的笔记 https://jev0n.com/2021/09/23/Self-Remapping.html 我们直接将call sub_411CE0 的地方nop掉，手动的把byte_4409c0的地方加1 12345678a = [ 0x07, 0xB8, 0x0D, 0x24, 0xB1, 0x0C, 0x2D, 0xC7, 0x28, 0x2D, 0xC3, 0x61, 0x66, 0x4F, 0x72, 0x13] addr = 0x04409C0for i in range(16): patch_byte(addr+i, a[i]+1)print(&quot;OK&quot;) 运行起来 得到key为 GF?-&gt;GirlFriend? 提取密文 10D 40 3B 87 A5 66 DA 74 92 7F BB E1 B8 CD EB BC 59 45 1B C0 38 99 AA 22 AA 3F 9D 21 07 4E 81 1F SM4在线解密 2e69df5961f20aee0897cf1905156344 , 最终得到flag为 GFCTF&#123;2e69df5961f20aee0897cf1905156344&#125; re_EasyRE_0x00IDA打开分析，最关键的是sub_100016A0函数 经过分析，发现sub_10001180是解密login.key文件，生成的数据放到V13里面 然后下面这个地方是将V13处的数据与生成的一些数据进行对比，猜测是机器码的验证 这是V13处的数据 111 55 66 55 0D 50 51 0C FF 01 80 12 CE A9 08 75 73 65 72 32 33 33 33 最后8个字符是user2333 将对比的数据也提取出来, 然后结合题目，用户名用admin6677登录，长度是9，整理得 111 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37 我们写脚本，每次运行到对比数据的时候就把v13的数据给他替换掉 12345data = [0x11, 0x55, 0x66, 0x55, 0x98, 0xFA, 0x9B, 0x59, 0x6F, 0xF6, 0x14, 0x8F, 0xE9, 0xDA, 0x09, 0x61, 0x64, 0x6D, 0x69, 0x6E, 0x36, 0x36, 0x37, 0x37]addr = 0x004CB348 # v13的地址for i in range(len(data)): patch_byte(addr+i, data[i])print(&quot;OK&quot;) 然后绕过机器码验证，往下走，来到sub_10001610处 可以发现，这个地方肯定是与服务器通信了，我们直接运行，直接Wireshark抓包 提取数据 1234567---&gt; 11 55 66 55 1a 27 00 00 00 00 &lt;--- 11 55 66 55 66 27 00 00 0f 00 f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd ---&gt; 11 55 66 55 1a 27 01 00 40 00 0e a2 60 19 1f df 39 0d bc 62 48 57 5a 11 87 78 69 11 03 76 4b f9 2c 1f 35 fd ff 4a b8 d8 63 8f b6 b1 f0 cd d3 90 2d 27 05 b7 1e 01 22 74 91 1a a4 53 df 1d f4 69 7d 3e 29 bd d3 30 da 94 a3 03 &lt;--- 11 55 66 55 66 27 01 00 48 00 84 cb 11 ef 71 51 30 0b b3 d8 c1 22 ac c4 ca f1 29 12 cf 79 f5 36 5f 5a 5e a8 f5 fa 62 3c e8 32 69 d6 a1 54 eb 1b 06 06 b0 68 20 5a 62 ea 48 ec 8a 3d 5c 40 d0 a8 03 94 6a 2e b7 f0 e4 33 aa a0 e3 f2 da f8 a9 cf 5d 92 重新调试，接着刚才的位置往下分析，看到了RC4的初始化及加密 猜测是刚开始，服务器端返回RC4的key，然后后面全部使用RC4加密方式进行加密 根据sub_10001350这个函数可以猜测出数据包的格式, 拿上面服务器返回的key举例子 1234511 55 66 55 //标志66 27 //版本00 00 //命令0f 00 //后面数据的长度f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd //数据，当命令为0的时候，是RC4的key，命令为1和2的时候，是RC4加密的数据 写脚本验证RC4加密 1234567891011121314151617181920212223242526272829303132from Crypto.Cipher import ARC4 as rc4cipherimport binasciidef rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return reskey = binascii.unhexlify(&quot;f3468abe8162ed36d5df28dc048afd&quot;)data1 = binascii.unhexlify( &quot;0ea260191fdf390dbc6248575a118778691103764bf92c1f35fdff4ab8d8638fb6b1f0cdd3902d2705b71e012274911aa453df1df4697d3e29bdd330da94a303&quot;)m1 = rc4_algorithm(&quot;dec&quot;, data1, key)data2 = binascii.unhexlify( &quot;84cb11ef7151300bb3d8c122acc4caf12912cf79f5365f5a5ea8f5fa623ce83269d6a154eb1b0606b068205a62ea48ec8a3d5c40d0a803946a2eb7f0e433aaa0e3f2daf8a9cf5d92&quot;)m2 = rc4_algorithm(&quot;dec&quot;, data2, key)print(m1)print(m2)# b&#x27;\\x8ayqv,\\x8eYjj\\xdb\\xfa\\x10\\xd6\\xa0=\\xed!w\\xa9/\\xdd\\xa3\\x1a \\x05!+\\xbd\\xd0\\xa7\\xe7\\xd4\\xba\\t%\\xb9N\\xeeYR\\xdc\\xb0Pfq\\xae\\xe9\\xc7\\x1eB\\xa3\\x0eA\\xb3\\x08\\xcf1\\xb3\\x12\\xa5L\\xd4`\\xcc&#x27;# b&#x27;\\x00\\x10\\x00\\x80B\\x00Please update client!\\r\\nClient version=10010, Server version=10086\\x00&#x27; 结合login.key，发现当命令为1的时候，向服务器发送的是login.key的数据，然后服务器返回信息 所以现在需要构造 真正的login.key(11 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37) 加密后的数据 sub_10001180是解密函数，进去分析,发现是RSA的PKCS#1加密 根据这个结构找到e和n 提取出来 12345e: 65537n: 0xd928b8efe000f72db5bda67a9aa0740defb555b2603736eecd6d01f38ef2fc79分解得到p, qp = 322922590106035145437937724697895880569q = 304171468404401467258708275665013611777 利用rsatool.py生成private.pem 1python rsatool.py -e 65537 -p 322922590106035145437937724697895880569 -q 304171468404401467258708275665013611777 -o private.pem 利用在线解密网站测试 https://the-x.cn/cryptography/Rsa.aspx 发现解密成功，将构造好的数据进行加密， 对于PKCS#1的填充方式可以参考下面2篇文章 https://www.cloudcared.cn/3155.html https://www.cnblogs.com/feng9exe/p/8075447.html 然后写程序与服务器交互，发现服务器返回命令为2的验证码问题 Question(Send result in uint32_t format, 1 second!): 9540808 * 32 + 509 * 859 = ? 然后利用eval计算数值，构造，返回给服务器，即可得到flag，完整的exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import socketfrom Crypto.Cipher import ARC4 as rc4cipherimport reimport structlogin_key = [0x5D, 0x98, 0xEE, 0x8B, 0x68, 0x86, 0x2F, 0x56, 0xBA, 0xA1, 0x27, 0x2A, 0x68, 0x8B, 0x19, 0x31, 0x37, 0xC1, 0x2B, 0x1A, 0x80, 0x5F, 0xAB, 0x8C, 0xE0, 0xE6, 0x81, 0xDF, 0x05, 0xC6, 0xB1, 0x2F, 0x0E, 0x59, 0xC8, 0x45, 0x8A, 0x7D, 0x83, 0x35, 0x5F, 0x02, 0x05, 0x10, 0x8A, 0x35, 0x6D, 0x0C, 0xE8, 0x3C, 0x9C, 0x15, 0xD7, 0xDA, 0xF0, 0x96, 0x6D, 0x2E, 0x77, 0xEC, 0x78, 0x3B, 0x83, 0xB2]def rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return resdef get_data(_cmd, _len, _data, _key): sig = [0x11, 0x55, 0x66, 0x55] # 签名 banben = [0x66, 0x27] # 版本 cmd_list = [_cmd, 0x00] # 命令 data_len_list = [_len, 0x00] # 数据长度 if _len != 0: return bytes(sig + banben + cmd_list + data_len_list) + rc4_algorithm(&#x27;enc&#x27;, bytes(_data), _key) return bytes(sig + banben + cmd_list + data_len_list)def get_captcha(_captcha_str): m = re.search( r&quot;Question\\(Send result in uint32_t format, 1 second!\\): (.*?) = &quot;, _captcha_str) c = eval(m.group(1)) return struct.pack(&quot;I&quot;, c)if __name__ == &#x27;__main__&#x27;: address = (&#x27;119.27.179.145&#x27;, 10086) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(address) s.send(get_data(0, 0, [], None)) data = s.recv(1024) rc4_key = data[10:] # 获取RC4密钥 s.send(get_data(1, 0x40, login_key, rc4_key)) data = s.recv(1024) captcha_str = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key).decode() captcha = get_captcha(captcha_str) # 计算得到验证码 print(f&quot;Captcha: &#123;captcha&#125;&quot;) # 向服务器返回验证码 send_data = get_data(2, len(captcha), list(captcha), rc4_key) s.send(send_data) data = s.recv(1024) m = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key) print(m) s.close() # Captcha: b&#x27;\\xc84\\x06\\x03&#x27; # b&#x27;\\x00\\x10\\x00\\x805\\x00flag_0x00 = \\x00GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;\\x00&#x27; 得到flag为 GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"L3HCTF 部分RE WP","slug":"L3HCTF_WP_RE_","date":"2021-11-17T02:00:00.000Z","updated":"2021-11-19T06:43:31.957Z","comments":true,"path":"2021/11/17/L3HCTF_WP_RE_/","link":"","permalink":"https://zzzzsky.github.io/2021/11/17/L3HCTF_WP_RE_/","excerpt":"","text":"L3HCTF 部分RE WPdouble-joyIDA打开程序，找到main函数进行分析 最关键的是enc_flag 函数, 经过调试，发现传入的参数有2套，都是固定的结构体 1234567typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1; 进入 enc_flag函数，F5，发现很乱，然后patch掉一些用于对齐的代码后，F5, 发现是个VM 调试，发现一共执行了0XCA次 enc_flag, 并且传入的参数是交替的 还原程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include &lt;windows.h&gt;#include &lt;basetsd.h&gt;#include &lt;stdio.h&gt;typedef unsigned int uint32;#define _DWORD uint32typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1;BYTE key1[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0x15, 0xCD, 0x5B, 0x07, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xB1, 0x68, 0xDE, 0x3A, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4C, 0x49, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x76, 0x6F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x20, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x55, 0x43, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x56, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x20, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x08, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xCC, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x96, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;BYTE key2[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0xF7, 0xCB, 0x54, 0x01, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xAD, 0xDE, 0xED, 0x5E, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x54, 0x53, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4D, 0x4F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x74, 0x20, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x61, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x5B, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x25, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xC7, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x91, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;void enc_flag(struc_1* st)&#123; BYTE* pKey = st-&gt;pKey; BYTE opcode = 0; _DWORD* pFlag = st-&gt;pFlag; int data1, data2, tmp, index; while (true) &#123; opcode = pKey[st-&gt;i]; //取出对应的opcode st-&gt;i++; //每取出一个opcode， 索引就+1 printf(&quot;------&gt;OPCODE :%d\\n&quot;, opcode); switch (opcode) &#123; case 0: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 + data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x + pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 1: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 - data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x - pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 2: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 * data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x * pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 3: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 / data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x / pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 4: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 % data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x %% pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 5: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 &amp; data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x &amp; pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 6: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 | data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x | pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 7: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 ^ data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x ^ pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 8: st-&gt;stack--; tmp = pFlag[st-&gt;stack]; index = pFlag[st-&gt;stack - 1]; pFlag[index] = tmp; printf(&quot;pFlag[%d] = %#x;\\n&quot;, index, tmp); st-&gt;stack--; continue; case 9: index = pFlag[st-&gt;stack - 1]; data1 = pFlag[index]; pFlag[st-&gt;stack - 1] = data1; printf(&quot;pFlag[%d] = %#x;\\n&quot;, st-&gt;stack -1, data1); continue; case 10: tmp = pFlag[st-&gt;stack - 1]; if (tmp == 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 11: tmp = pFlag[st-&gt;stack - 1]; if ((int)tmp &lt; 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 12: data1 = pFlag[st-&gt;stack - 1]; data2 = pFlag[st-&gt;stack - 2]; pFlag[st-&gt;stack - 1] = data2; pFlag[st-&gt;stack - 2] = data1; printf(&quot;exchange pFlag[%d]:%#x, pFlag[%d]:%#x\\n&quot;, st-&gt;stack - 1, data2, st-&gt;stack - 2, data1); continue; case 13: st-&gt;stack--; continue; case 14: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i += 4; pFlag[st-&gt;stack++] = tmp; printf(&quot;pFlag[%d] = %#x\\n&quot;, st-&gt;stack-1, tmp); continue; case 15: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; index = st-&gt;i + 4 + tmp; st-&gt;i = index; continue; case 16: tmp = st-&gt;i + 4; st-&gt;stack--; if (pFlag[st-&gt;stack]) tmp += *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i = tmp; continue; case 17: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;stack += tmp; st-&gt;i += 4; continue; case 18: st-&gt;i += 4; return; default: st-&gt;i++; &#125; &#125;&#125;char flag1[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char flag2[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char compare_date[1000] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79, 0&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111222211111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111222211111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD *)flag1; v12.pKey = key1; v12.i = 0; v12.stack = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.stack = 0; for (int i = 0; i &lt; 0XCA; i+=2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); printf(&quot;----------------------------------------------------------------------------&quot;); &#125; return 0; &#125; 调试发现，flag是分组进行加密的,每8个字符一组，共5组 第一组 L3HCTF&#123;*, 只差1个字符, 暴力破解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char compare_date[] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111111111111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111111111111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;1&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;1&quot;, 8); for (int j = 32; j &lt; 127; j++) &#123; v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;&quot;, 8); flag1[7] = j; flag2[7] = j; for (int i = 0; i &lt; 0XCA; i += 2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); &#125; if (memcmp(flag1, compare_date, 8) == 0) &#123; printf(&quot;%c\\n&quot;, j); getchar(); &#125; &#125; return 0;&#125;//D 发现第一组是L3HCTF&#123;D 然后下面开始还原VM，只需还原出加密每一组的第一个循环就OK 输入flag 为 L3HCTF&#123;D1111222211111111111111111111111 1234第二组为Input: 31 31 31 31 32 32 32 32enc后Output: ec 9d 57 67 94 6a 7e a5 通过打印的日志，追踪Input，来分析如何得到的Output 加密flag的第二组的第一个循环的日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564输入：31 31 31 31 32 32 32 32输出：ec 9d 57 67 94 6a 7e a5======以下是打印的日志OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :8pFlag[12] = 0x31313131;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :8pFlag[13] = 0x32323232;------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x32323232;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x32323232; ====------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0x32323232, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0x32323232 / pFlag[24]:0x20; ====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x1919191 ^ pFlag[23]:0x23232320;------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232; ====------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x32323232 + pFlag[23]:0x22b2b2b1; ====------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xce0a6e55;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0x1;------&gt;OPCODE :9pFlag[25] = 0x6f76;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x6f76 + pFlag[24]:0xce0a6e55;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xce0addcb ^ pFlag[23]:0x54e4e4e3;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9aee3928 + pFlag[22]:0x31313131; ===------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0xce0a6e55; === 上一轮循环剩下的------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x75bcd15;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x75bcd15 + pFlag[22]:0xce0a6e55;------&gt;OPCODE :8pFlag[11] = 0xd5663b6a;====------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0xcc1f6a59; ===------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0xcc1f6a59, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0xcc1f6a59 / pFlag[24]:0x20;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xfe60fb53 ^ pFlag[23]:0xc1f6a590;------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0xcc1f6a59 + pFlag[23]:0x3f965ec3;------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xd5663b6a;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xd5663b6a;------&gt;OPCODE :14pFlag[26] = 0x800------&gt;OPCODE :12exchange pFlag[26]:0xd5663b6a, pFlag[25]:0x800------&gt;OPCODE :3pFlag[25] = pFlag[26]:0xd5663b6a / pFlag[25]:0x800;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xfffaacc8; ====------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0;------&gt;OPCODE :9pFlag[25] = 0x494c;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x494c + pFlag[24]:0xd5663b6a;===------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xd56684b6 ^ pFlag[23]:0xbb5c91c; ===------&gt;OPCODE :0pFlag[22] = pFlag[23]:0xded34daa + pFlag[22]:0x32323232;------&gt;OPCODE :8pFlag[13] = 0x11057fdc; === ------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[2] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[3] = 0x11057fdc;------&gt;OPCODE :18 =============================================v13准备开始------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[13] = 0x11057fdc;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0x798dcdf9;------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x154cbf7; = =====系统中的立即数------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x154cbf7 + pFlag[22]:0x798dcdf9; == 这2个数是固定的------&gt;OPCODE :8pFlag[11] = 0x7ae299f0; =========------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x11057fdc;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x11057fdc;========------&gt;OPCODE :14pFlag[24] = 0------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0;------&gt;OPCODE :9pFlag[24] = 0x5354;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x5354 + pFlag[23]:0x1057fdc0; =======------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xd------&gt;OPCODE :9pFlag[25] = 0x11057fdc;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x11057fdc, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x11057fdc / pFlag[25]:0x20; ### 0x882bfe------&gt;OPCODE :14pFlag[26] = 0x1------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x1;------&gt;OPCODE :9pFlag[26] = 0x4f4d;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x4f4d + pFlag[25]:0x882bfe;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x887b4b ^ pFlag[24]:0x8be819cc; =====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x8b606287 ^ pFlag[23]:0x10585114;==------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9b383393 + pFlag[22]:0xcc1f6a59;=====------&gt;OPCODE :8pFlag[12] = 0x67579dec; ######------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x2------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0x2;------&gt;OPCODE :9pFlag[24] = 0x2074;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x2074 + pFlag[23]:0x7579dec0; === 49------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0x67579dec;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x67579dec; =====------&gt;OPCODE :14pFlag[25] = 0xc------&gt;OPCODE :9pFlag[25] = 0x67579dec;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x67579dec, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x67579dec / pFlag[25]:0x20;===&#x27;0x33abcef&#x27;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x3;------&gt;OPCODE :9pFlag[26] = 0x6561;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x6561 + pFlag[25]:0x33abcef;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x33b2250 ^ pFlag[24]:0xe23a37dc;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xe101158c ^ pFlag[23]:0x7579ff34;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9478eab8 + pFlag[22]:0x11057fdc; # &#x27;0xa57e6a94&#x27;------&gt;OPCODE :8pFlag[13] = 0xa57e6a94;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x67579dec;------&gt;OPCODE :8pFlag[2] = 0x67579dec;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0xa57e6a94;------&gt;OPCODE :8pFlag[3] = 0xa57e6a94;------&gt;OPCODE :18---------------------------------------------------------------------------- 分析算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758A = FLAG[0:4]B = FLAG[4:8]pFlag[23] = B * 0x10pFlag[24] = B / 0X20 pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = B + pFlag[23] pFlag[23] = (0xCE0A6E55 + 0X6F76) ^ pFlag[23] pFlag[22] = pFlag[23] + A TMP1 = pFlag[22] # 173行 0xcc1f6a59 ***V12导出 # v0pFlag[22] = 0xCE0A6E55 # (过会回来补坑，这个是上一轮循环剩下的) 这个与FLAG无关，是固定的pFlag[22] = 0x75bcd15(立即数) + 0xce0a6e55TMP2 = pFlag[22] # 187行 0xd5663b6a #TMP2 = sum1pFlag[23] = TMP1pFlag[23] = TMP1 * 0X10 # 201pFlag[24] = TMP1 / 0x20 # 213pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = TMP1 + pFlag[23] pFlag[26] = TMP2pFlag[25] = pFlag[26] / 0x800 #233行pFlag[24] = TMP2 + 0x494c ###245pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + B TMP3 = pFlag[22] ### 251行 0x11057fdc ***V12导出 #v1pFlag[22] = 0x154cbf7(立即数) + 0x798dcdf9; #这2个数是固定的 #在第一轮的时候是这个，其他的还没测试TMP4 = pFlag[22] ###407行 0x7ae299f0pFlag[23] = TMP3 * 0X10pFlag[23] = pFlag[23] + 0X5354 # 421 pFlag[24] = TMP4 + TMP3 #441 pFlag[25] = TMP3 / 0x20 #451 ### 0x882bfepFlag[25] = 0x4f4d + pFlag[25] pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23] #465 ## 0x9b383393pFlag[22] = pFlag[23] + TMP1TMP5 = pFlag[22] #### 469 0x67579decpFlag[23] = TMP5 * 0X10pFlag[23] = pFlag[23] + 0x2074 ## 0x7579ff34pFlag[24] = TMP4 + TMP5 ####503行pFlag[25] = TMP5 / 0x20pFlag[25] = pFlag[25] + 0x6561pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + TMP3 # 529行 0xa57e6a94TMP6 = pFlag[22] # 0xa57e6a94 通过 * 0x10 、/0x20、 /0x800、 &amp;3等特征，猜测是xtea， tea算法 一边猜一边还原算法,用C语言写出1轮的循环加密算法 1234567891011121314151617181920int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125; sum_tea 和 sum_xtea，对于每一组来说，初始值是不同的，比如第二组这里是0x798dcdf9 和 0xce0a6e55 最后通过打印三，四，五组第一个循环的日志，来与第二组的日志做对比，找到了所有组的初始的sum_tea 和 sum_xtea 123456int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;; 最终写脚本解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;;int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125;void decrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v1 -= ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v0 -= ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); sum_tea -= 0x154cbf7;; v1 -= (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_xtea -= 0x75bcd15; v0 -= (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); v[0] = v0; v[1] = v1;&#125;char compare_date[100] = //这里是从程序中提取的加密后的flag的值&#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; int v[2] = &#123; 0 &#125;; int* encFlag = (int*)compare_date; //flag的前8个字符爆破得到的 L3HCTF&#123;D for (int j = 0; j &lt; 4; j++) //后32个字符，分4组 &#123; for (int i = 0; i &lt; 20; i++) encrypt(v, sum[j][0], sum[j][1]); //提升sum_xtea 和 sum_tea for (int i = 0; i &lt; 20; i++) decrypt(&amp;encFlag[j * 2 + 2], sum[j][0], sum[j][1]); &#125; char* flag = (char*)&amp;encFlag[2]; printf(&quot;flag is L3HCTF&#123;D%s \\n&quot;, flag); return 0;&#125;// L3HCTF&#123;D0uBle_vM_W1th_dOubIe_TEA&#125; LoadIDA打开程序分析 进入LOAD_PE函数，就是创建了个傀儡进程 在ResumeThread这里下断点，dump，然后foremost分离 注意在foremost分离的时候要把dump下来的程序的MZ头抹去，这样才能分离解密后的PE文件来 IDA打开分析 获取flag后，对flag中的字符在 0x30-0x39或 a-f 范围做了个小处理 12340x30 - 0x39 ---&gt; 0x00 - 0x09a - f ---&gt; 0xA ---0xF# 然后假设输入的是123f --&gt; 0x12, 0x3f 存在了0x434380的位置 注意这里全是对应的十六进制，猜测输入的flag的范围就是[0-9a-f] 最终434380处的数据是13个。下面又分为9 + 4 个，正好是3和2的平方，并且下面验证的时候也是分为9 + 4进行验证的 猜测是3 * 3 + 2 * 2的某个矩阵运算, 在上述图89行位置下断点，修改src处的数据为100010001, 12341 0 00 1 00 0 1正好是单位矩阵 然后运行，加密后发现Src处的数据没变，但是v29处的数据全乱了，猜测是逆矩阵 提取出加密后Src 和 v29处的数据 12345678Src: 1 0 -90 -1 -6-1 -2 -4 v29:7 330 13 写脚本求逆矩阵，并转换为flag 12345678910111213141516171819import numpyif __name__ == &quot;__main__&quot;: a = numpy.array([[1, 0, -9], [0, -1, -6], [-1, -2, -4]]) b = numpy.array([[7, 3], [30, 13]]) a_inv = numpy.linalg.inv(a) b_inv = numpy.linalg.inv(b) a_list = [list(i) for i in a_inv] b_list = [list(i) for i in b_inv] flag_list = a_list[0] + a_list[1] + a_list[2] + b_list[0] + b_list[1] flag_list = [int(i) &amp; 0xff for i in flag_list] flag = bytes(flag_list).hex() print(flag) # f812f706f306ff02ff0dfde207 拼接后进行验证，Load.exe在 ResumeThread那里下断点，输入flag，程序断下，在运行dump提取出来的exe，验证成功 最终flag为 : flag&#123;f812f706f306ff02ff0dfde207&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]},{"title":"2021强网拟态_babyre","slug":"2021强网拟态_babyre","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-19T06:44:07.109Z","comments":true,"path":"2021/11/12/2021强网拟态_babyre/","link":"","permalink":"https://zzzzsky.github.io/2021/11/12/2021%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81_babyre/","excerpt":"","text":"2021强网拟态rebabyreIDA动态调试，进入关键函数 分析函数，提取数据，还原算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;typedef unsigned char BYTE;typedef unsigned long DWORD;char _flag[] = &quot;1234567890123456&quot;;DWORD cmp_data[8] = &#123;0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623&#125;;DWORD key[60] = &#123;0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f&#125;;DWORD dword_405420[256] = &#123;0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042&#125;;DWORD dword_405820[256] = &#123;0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257&#125;;DWORD dword_405C20[256] = &#123;0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8&#125;;DWORD dword_405020[256] = &#123;0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0&#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123;0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE HIBYTE(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;DWORD _enc_flag[4] = &#123;0&#125;;int main()&#123; DWORD *flag = (DWORD *)_flag; int key_index = 0; DWORD v9 = 0, v8 = 0, v7 = 0, i = 0; DWORD v11 = 0, v13 = 0, v15 = 0, v17 = 0; DWORD v12 = 0, v14 = 0, v16 = 0, v18 = 0; v9 = flag[3] ^ key[key_index]; key_index += 1; v8 = flag[2] ^ key[key_index]; key_index += 1; v7 = flag[1] ^ key[key_index]; key_index += 1; i = flag[0] ^ key[key_index]; key_index += 1; for (int j = 0; j &lt; 13; j++) &#123; v11 = dword_405420[BYTE1(v9)] ^ dword_405820[BYTE2(v8)] ^ dword_405C20[HIBYTE(v7)] ^ dword_405020[BYTE0(i)]; v13 = dword_405420[BYTE1(i)] ^ dword_405820[BYTE2(v9)] ^ dword_405C20[HIBYTE(v8)] ^ dword_405020[BYTE0(v7)]; v15 = dword_405420[BYTE1(v7)] ^ dword_405820[BYTE2(i)] ^ dword_405C20[HIBYTE(v9)] ^ dword_405020[BYTE0(v8)]; v17 = dword_405420[BYTE1(v8)] ^ dword_405820[BYTE2(v7)] ^ dword_405C20[HIBYTE(i)] ^ dword_405020[BYTE0(v9)]; //最后一轮时 V11, V13, V15, V17的值应该如下 // v11 = 0xf048c314; // v13 = 0xb4db6016; // v15 = 0x8eee5336; // v17 = 0x948726e2; v9 = v17 ^ key[key_index]; key_index += 1; v8 = v15 ^ key[key_index]; key_index += 1; v7 = v13 ^ key[key_index]; key_index += 1; i = v11 ^ key[key_index]; key_index += 1; &#125; //运行到这里，v9, v8, v7, i的数据应该如下 // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; v12 = (RijnDael_AES_LONG_inv_406120[BYTE1(v9)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v8)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v7)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(i)]; v14 = (RijnDael_AES_LONG_inv_406120[BYTE1(i)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v9)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v8)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v7)]; v16 = (RijnDael_AES_LONG_inv_406120[BYTE1(v7)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(i)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v9)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v8)]; v18 = (RijnDael_AES_LONG_inv_406120[BYTE1(v8)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v7)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(i)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v9)]; //运行到这里，v12, v14, v16, v18的数据应该如下 // 0xe82b2381 v12 // 0x70ea91de v14 // 0xe7e1d2f1 v16 // 0xdb36973b v18 _enc_flag[3] = v18 ^ key[key_index]; key_index += 1; _enc_flag[2] = v16 ^ key[key_index]; key_index += 1; _enc_flag[1] = v14 ^ key[key_index]; key_index += 1; _enc_flag[0] = v12 ^ key[key_index]; for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%#X, &quot;, _enc_flag[i]); &#125; return 0;&#125; 写解密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;windows.h&gt;size_t count = 0;DWORD key[60] = &#123; 0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f &#125;;DWORD dword_405420[256] = &#123; 0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042 &#125;;DWORD dword_405820[256] = &#123; 0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257 &#125;;DWORD dword_405C20[256] = &#123; 0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8 &#125;;DWORD dword_405020[256] = &#123; 0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0 &#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123; 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D &#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE BYTE3(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;// void brute(DWORD target /*, unsigned char *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4*/)// &#123;// for (unsigned char i1 = 0; i1 &lt; 256; i1++)// &#123;// for (unsigned char i2 = 0; i2 &lt; 256; i2++)// &#123;// for (unsigned char i3 = 0; i3 &lt; 256; i3++)// &#123;// for (unsigned char i4 = 0; i4 &lt; 256; i4++)// &#123;// if ((dword_405020[i1] ^ dword_405420[i2] ^ dword_405820[i3] ^ dword_405C20[i4]) == target)// &#123;// printf(&quot;brute found for %#x: %d %d %d %d\\n&quot;, target, i1, i2, i3, i4);// // *a1 = i1;// // *a2 = i2;// // *a3 = i3;// // *a4 = i4;// return;// &#125;// &#125;// &#125;// &#125;// &#125;// &#125;void brute(DWORD target, unsigned char* a1, unsigned char* a2, unsigned char* a3, unsigned char* a4)&#123; for (size_t i1 = 0; i1 &lt; 256; i1++) &#123; for (size_t i2 = 0; i2 &lt; 256; i2++) &#123; for (size_t i3 = 0; i3 &lt; 256; i3++) &#123; for (size_t i4 = 0; i4 &lt; 256; i4++) &#123; if ((dword_405420[i1] ^ dword_405820[i2] ^ dword_405C20[i3] ^ dword_405020[i4]) == target) &#123; printf(&quot;%d - brute found for %x:%d %d %d %d\\n&quot;, count++, target, i1, i2, i3, i4); *a1 = i1; *a2 = i2; *a3 = i3; *a4 = i4; &#125; &#125; &#125; &#125; &#125;&#125;unsigned char findIndex1(BYTE data)&#123; BYTE* array = RijnDael_AES_LONG_inv_406120; for (unsigned char i = 0; i &lt; 256; i++) &#123; if (array[i] == data) return i; &#125; return -1;&#125;void decrypt(DWORD* miwen, DWORD* flag)&#123; int key_index = 59; DWORD v12, v14, v16, v18; DWORD v11, v13, v15, v17; unsigned char _v9[4] = &#123; 0 &#125;; unsigned char _v8[4] = &#123; 0 &#125;; unsigned char _v7[4] = &#123; 0 &#125;; unsigned char _i[4] = &#123; 0 &#125;; DWORD v9, v8, v7, i; v12 = miwen[0] ^ key[key_index--]; v14 = miwen[1] ^ key[key_index--]; v16 = miwen[2] ^ key[key_index--]; v18 = miwen[3] ^ key[key_index--]; // 得到v9, v8, v7, i; _i[0] = findIndex1(BYTE0(v12)); _v9[1] = findIndex1(BYTE1(v12)); _v8[2] = findIndex1(BYTE2(v12)); _v7[3] = findIndex1(BYTE3(v12)); _v7[0] = findIndex1(BYTE0(v14)); _i[1] = findIndex1(BYTE1(v14)); _v9[2] = findIndex1(BYTE2(v14)); _v8[3] = findIndex1(BYTE3(v14)); _v8[0] = findIndex1(BYTE0(v16)); _v7[1] = findIndex1(BYTE1(v16)); _i[2] = findIndex1(BYTE2(v16)); _v9[3] = findIndex1(BYTE3(v16)); _v9[0] = findIndex1(BYTE0(v18)); _v8[1] = findIndex1(BYTE1(v18)); _v7[2] = findIndex1(BYTE2(v18)); _i[3] = findIndex1(BYTE3(v18)); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; for (int j = 0; j &lt; 13; j++) &#123; v11 = i ^ key[key_index--]; v13 = v7 ^ key[key_index--]; v15 = v8 ^ key[key_index--]; v17 = v9 ^ key[key_index--]; brute(v11, &amp;_v9[1], &amp;_v8[2], &amp;_v7[3], &amp;_i[0]); brute(v13, &amp;_i[1], &amp;_v9[2], &amp;_v8[3], &amp;_v7[0]); brute(v15, &amp;_v7[1], &amp;_i[2], &amp;_v9[3], &amp;_v8[0]); brute(v17, &amp;_v8[1], &amp;_v7[2], &amp;_i[3], &amp;_v9[0]); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; &#125; flag[0] = i ^ key[key_index--]; flag[1] = v7 ^ key[key_index--]; flag[2] = v8 ^ key[key_index--]; flag[3] = v9 ^ key[key_index--];&#125;int main()&#123; printf(&quot;Start...\\n&quot;); DWORD cmp_data[8] = &#123; 0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623 &#125;; //DWORD cmp_data[8] = &#123;0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6, 0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6&#125;; //拿1234567890123456做测试 DWORD flag[8] = &#123; 0 &#125;; decrypt(cmp_data, flag); decrypt(&amp;cmp_data[4], &amp;flag[4]); printf(&quot;flag: %s\\n\\n&quot;, (char*)flag); char* tmp = (char*)flag; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X, &quot;, tmp[i]); &#125; return 0;&#125; 最终跑出来的数据为 稍作处理 123456789101112#include &lt;stdio.h&gt;int main()&#123; unsigned int a[] = &#123;0XFFFFFFF2, 0XFFFFFF88, 0X35, 0X49, 0XFFFFFFF8, 0X5C, 0X2A, 0X4, 0XFFFFFFA8, 0X4E, 0XFFFFFF86, 0XFFFFFF9E, 0XFFFFFFBE, 0XFFFFFFF9, 0X2A, 0XE, 0XFFFFFFC6, 0X4, 0XFFFFFF94, 0X56, 0X14, 0XFFFFFF89, 0X4C, 0X4C, 0X2E, 0XFFFFFF9C, 0X17, 0XFFFFFFC4, 0XFFFFFFC2, 0XFFFFFFA7, 0XFFFFFF82, 0X1F&#125;; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X &quot;, a[i] &amp; 0xff); &#125; return 0;&#125;//F2 88 35 49 F8 5C 2A 4 A8 4E 86 9E BE F9 2A E C6 4 94 56 14 89 4C 4C 2E 9C 17 C4 C2 A7 82 1F 找到源程序，调试起来，修改flag，进行验证 修改为 运行 发现程序输出success 所以最终的flag应该是 1flag = b&#x27;flag&#123;\\xF2\\x88\\x35\\x49\\xF8\\x5C\\x2A\\x4\\xA8\\x4E\\x86\\x9E\\xBE\\xF9\\x2A\\xE\\xC6\\x4\\x94\\x56\\x14\\x89\\x4C\\x4C\\x2E\\x9C\\x17\\xC4\\xC2\\xA7\\x82\\x1F&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"陇原战\"疫\"2021网络安全大赛_RE_WP","slug":"陇原战疫2021_RE_WP","date":"2021-11-11T02:00:00.000Z","updated":"2021-11-19T06:43:50.925Z","comments":true,"path":"2021/11/11/陇原战疫2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/11/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021_RE_WP/","excerpt":"","text":"陇原战”疫”2021网络安全大赛_RE_WPEasyRe方法一IDA打开分析 发现sub_4111406这个函数是对输入的flag进行加密，然后将加密后的数据存放到0X41A14C中 来到sub_4111406函数，并不能F5, 直接动态调试一直跟 、 发现程序在不断的生成一些数据，长度是32 多次调试，不同输入，这里获取的数据是一样的 分析，还原算法 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD * enc(char* flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)flag; DWORD* pdw_key = (DWORD*)key; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 7; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13; pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 17; &#125; return pdw_flag;&#125;int main()&#123; char flag[33] = &quot;12345678901234567890123456789012&quot;; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; enc(flag, key); return 0; //在这里下断点观察加密后的数据是否与IDA调试时生成的一样&#125; 在末尾下断点调试 IDA调试运行下断点观察加密后的数据 发现是一样的，还原加密算法成功，现在开始写解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;windows.h&gt;VOID dec_shift_xor(DWORD* mingwen, int shiftlen) &#123; //pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13 类似这种加密方式，知道加密后的，解密得到原来的数据 //mingwen指向明文 //shiftlen指向移位的的位数 DWORD data = *mingwen; DWORD mask = 1; for (int i = 0; i &lt; shiftlen - 1; i++) &#123; // 构造mask mask = (mask &lt;&lt; 1) + 1; &#125; DWORD zuidi2wei = data &amp; mask; int count = 32 / shiftlen; count = 32 % shiftlen == 0 ? count : count + 1; for (int i = 0; i &lt; count; i++) &#123; zuidi2wei &lt;&lt;= shiftlen; mask &lt;&lt;= shiftlen; data ^= zuidi2wei; zuidi2wei = data &amp; mask; &#125; *mingwen = data;&#125;DWORD* dec(char* enc_flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)enc_flag; DWORD* pdw_key = (DWORD*)key; for (int i = 7; i &gt;=0; i--) &#123; dec_shift_xor(&amp;pdw_flag[i], 17); pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; dec_shift_xor(&amp;pdw_flag[i], 13); pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; dec_shift_xor(&amp;pdw_flag[i], 7); &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; return pdw_flag;&#125;int main()&#123; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; char enc_flag[33] = &#123; 0x15, 0x86, 0x0F, 0xF9, 0x3D, 0x7C, 0x82, 0xC8, 0x63, 0x32, 0xD7, 0x1B, 0x54, 0x74, 0x0C, 0xA9, 0x05, 0x4E, 0x3F, 0x7D, 0x19, 0xBC, 0xE4, 0x53, 0x7F, 0x39, 0x5B, 0xA8, 0x5E, 0xA4, 0xB2, 0xD4,0&#125;; //提取的0X41A058处的数据 dec(enc_flag, key); printf(&quot;%s&quot;, enc_flag); return 0;&#125; 得到 fc5e038d38a57032085441e7fe7010b0，加上 flag{} 得到 flag&#123;fc5e038d38a57032085441e7fe7010b0&#125; 方法二去花指令 123456789101112131415161718192021222324252627282930313233from ida_bytes import get_bytes, patch_bytesimport readdr = 0x415B53end = 0x0415B79buf = get_bytes(addr, end - addr)buf_str = &quot;&quot;.join([chr(i) for i in list(buf)])pattern = r&quot;\\xE8\\x01\\x00\\x00\\x00.\\x33\\xDB\\x33\\xC0\\x33\\xC9\\x59\\x83\\xC0([\\s\\S])\\xBB([\\s\\S])\\x00\\x00\\x00\\xF7\\xE3\\x83\\xC1\\x20\\x83\\xC0([\\s\\S])\\x33\\xC3\\x51(\\x88\\x45[\\s\\S])\\xC3.&quot;def handler(s): eax = ord(s.group(1)[0]) ebx = ord(s.group(2)[0]) tmp = ord(s.group(3)[0]) c = s.group(4) eax = eax * ebx eax += tmp eax ^= ebx patch_ = &quot;\\xB8&quot; + chr(eax) + &quot;\\x00\\x00\\x00&quot; return patch_ + &#x27;\\x90&#x27;*(0x25-5-5) + c + &quot;\\x90&quot; * 2buf = re.sub(pattern, handler, buf_str, flags=re.I)buf_bytes = bytes([ord(i) for i in buf])patch_bytes(addr, buf_bytes)print(&quot;OK&quot;) Z3模块解决 12345678910111213141516171819202122232425262728293031323334from z3 import *if __name__ == &quot;__main__&quot;: enc = [0xF90F8615, 0xC8827C3D, 0x1BD73263, 0x0A90C7454, 0x7D3F4E05, 0x53E4BC19, 0xA85B397F, 0xD4B2A45E] v5 = [0] * 8 flag = [BitVec(f&quot;flag_&#123;i&#125;&quot;, 32) for i in range(8)] s = Solver() v4 = [0x271E150C, 0x3B322920, 0x5F564D44, 0x736A6158, 0x978E857C, 0xABA29990, 0xCFC6BDB4, 0xE3DAD1C8] for i in range(8): v5[i] = flag[i] ^ v4[(7 * i + 2) % 8] for j in range(8): v5[j] ^= v5[j] &lt;&lt; 7 v5[j] ^= v4[(7 * j + 3) % 8] v5[j] ^= v5[(5 * j + 3) % 8] v5[j] ^= v5[j] &lt;&lt; 13 v5[j] ^= v4[(7 * j + 5) % 8] v5[j] ^= v5[j] &lt;&lt; 17 for i in range(8): s.add(v5[i] == enc[i]) assert s.check() == sat m = s.model() flag = [int.to_bytes(m[i].as_long(), 4, byteorder=&quot;little&quot;).decode() for i in flag] print(&quot;&quot;.join(flag)) EasyRe_Revenge此题与EasyRe_Revenge一样，只是把密文换了，替换上图中的enc_flag即可 1char enc_flag[33] = &#123; 66, 176, 232, 238, 108, 238, 208, 87, 50, 75, 245, 243, 214, 183, 240, 211, 137, 195, 97, 10, 64, 186, 199, 56, 44, 158, 61, 12, 132, 146, 74, 214,0 &#125;; 后来发现，原来EasyRe那道题目，flag直接存在字符串中了，所以把密文换了，才有了这个EasyRe_Revenge findmeIDA打开分析 来到 403844 这个位置 很显然这个位置不可能是strcmp，观察发现404840那个地址处还存了个函数的地址 sub_401866，估计程序有地方把403844这个地方的地址给替换掉了 来到401866位置 分析401767函数，发现是明显的RC4加密 随便输入一个假的flag，12345678901234567890123456， 然后断下，看加密后的数据 写脚本得到密钥流 12345678fake_flag = &quot;12345678901234567890123456&quot;enc_fake_flag = [ 0xD5, 0x25, 0xE2, 0xB6, 0xF1, 0x99, 0x4B, 0xD4, 0xB5, 0x1B, 0x81, 0xD0, 0x47, 0x8F, 0xEF, 0x35, 0x05, 0x46, 0x48, 0xEB, 0x8C, 0x21, 0x6C, 0xB8, 0x05, 0x8D]key = [ord(fake_flag[i]) ^ enc_fake_flag[i] for i in range(26)]print(key)# [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187] 然后提取出dword_403040解密即可 12345enc = [0xFFFFFFB7, 0x52, 0x0FFFFFF85, 0x0FFFFFFC1, 0x0FFFFFF90, 0x0FFFFFFE9, 0x7, 0xFFFFFFB8, 0x0FFFFFFE4, 0x1A, 0x0FFFFFFC3, 0x0FFFFFFBD, 0x1D, 0x0FFFFFF8E, 0x0FFFFFF85, 0x46, 0x0, 0x21, 0x44, 0x0FFFFFFAF, 0x0FFFFFFEF, 0x70, 0x32, 0x0FFFFFFB5, 0x11, 0x0FFFFFFC6]key = [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187]flag = [chr((enc[i] &amp; 0XFF) ^ key[i]) for i in range(26)]print(&quot;&quot;.join(flag))# SETCTF&#123;Th1s_i5_E2_5tRcm9!&#125; power拿到题目，附件是ARM汇编源文件 直接用arm-none-eabi-as.exe power编译下生成a.out IDA打开 发现是AES加密，这里写的是CBC模式，但其实是ECB模式，写脚本解密即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Cipher import AESimport base64import binasciiclass Aescrypt(): def __init__(self, key, model, iv): self.key = self.add_16(key) self.model = model self.iv = iv def add_16(self, par): if type(par) == str: par = par.encode() while len(par) % 16 != 0: par += b&#x27;\\x00&#x27; return par def aesencrypt(self, text): text = self.add_16(text) if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.encrypt_text = self.aes.encrypt(text) return self.encrypt_text def aesdecrypt(self, text): if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.decrypt_text = self.aes.decrypt(text) self.decrypt_text = self.decrypt_text.strip(b&quot;\\x00&quot;) return self.decrypt_textif __name__ == &#x27;__main__&#x27;: passwd = b&quot;this_is_a_key!!!&quot; enc_flag_str = &quot;1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b&quot; enc_flag = binascii.unhexlify(enc_flag_str) aescryptor = Aescrypt(passwd, AES.MODE_ECB, None) # ECB text = aescryptor.aesdecrypt(enc_flag) print(&quot;明文:&quot;, text) # 明文: b&#x27;flag&#123;y0u_found_the_aes_12113112&#125;&#x27; Eat_something核心代码在Eat_something.wasm中 找到工具将wasm转为.o文件 https://www.52pojie.cn/thread-1438499-1-1.html 用IDA打开，找到w2c_checkright函数，这是验证flag的地方 核心算法就是这一句 v13 != (i32_load(w2c_memory, v16 + 12LL) ^ (2 * v10)) 翻译下就是enc[i] != i ^ (flag[i] * 2) 将enc提取出来，写脚本即可 123456789101112enc = [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, 0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, 0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21, 0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00] flag = []for i in range(26): flag .append(chr((i ^ enc[i]) // 2))print(&quot;&quot;.join(flag))# CETCTF&#123;Th0nk_Y0u_DocTOr51&#125; 最后将CETCTF 改为 SETCTF即为flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]}