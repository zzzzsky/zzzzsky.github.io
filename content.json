{"meta":{"title":"zsky's Blog","subtitle":"","description":"某211研一在读|CTF_RE选手|tcl","author":"zsky","url":"https://zzzzsky.github.io","root":"/"},"pages":[{"title":"记录本fw的学习","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-29T12:15:58.760Z","comments":true,"path":"about/index.html","permalink":"https://zzzzsky.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-11-18T14:36:52.000Z","updated":"2021-11-29T12:15:03.610Z","comments":true,"path":"categories/index.html","permalink":"https://zzzzsky.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-11-18T14:36:30.000Z","updated":"2021-11-29T12:15:43.104Z","comments":true,"path":"tags/index.html","permalink":"https://zzzzsky.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-18T14:37:07.000Z","updated":"2021-11-29T12:15:24.996Z","comments":true,"path":"link/index.html","permalink":"https://zzzzsky.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"Python 常用数据类型转换","slug":"python处理数据类型","date":"2021-12-03T09:46:00.000Z","updated":"2021-12-03T09:47:22.856Z","comments":true,"path":"2021/12/03/python处理数据类型/","link":"","permalink":"https://zzzzsky.github.io/2021/12/03/python%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Python 常用数据类型转换在CTF中，经常需要各种数据类型之间的转换 struct模块 官方文档: https://docs.python.org/zh-cn/3.10/library/struct.html C语言数据结构与python bytes之间的转换 ​ 12345678910111213141516171819In [1]: import struct In [2]: struct.pack(&quot;&lt;LLLL&quot;, 1,2,3,4) Out[2]: b&#x27;\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00&#x27; In [3]: struct.pack(&quot;&lt;LLLL&quot;,&#x27;a&#x27;,2,3,4) --------------------------------------------------------------------------- error Traceback (most recent call last) &lt;ipython-input-3-e0808e208379&gt; in &lt;module&gt; ----&gt; 1 struct.pack(&quot;&lt;LLLL&quot;,&#x27;a&#x27;,2,3,4) error: required argument is not an integer In [4]: c = struct.pack(&#x27;&lt;I&#x27;, ord(&#x27;a&#x27;)) In [5]: b = struct.unpack(&#x27;&lt;I&#x27;, c) In [6]: b[0] Out[6]: 97 binascii模块二进制和ASCII之间的转换 官方文档: https://docs.python.org/zh-cn/3.7/library/binascii.html 12345678910111213141516In [1]: import binasciiIn [2]: binascii.hexlify(b&#x27;12345&#x27;)Out[2]: b&#x27;3132333435&#x27;In [3]: binascii.hexlify(b&#x27;12345&#x27;, &#x27;-&#x27;)Out[3]: b&#x27;31-32-33-34-35&#x27;In [4]: binascii.unhexlify(b&#x27;3132333435&#x27;)Out[4]: b&#x27;12345&#x27;In [5]: binascii.crc32(b&#x27;123&#x27;)Out[5]: 2286445522In [6]: hex(binascii.crc32(b&#x27;123&#x27;))Out[6]: &#x27;0x884863d2&#x27; 进制之间的转换1234567891011121314151617In [7]: int(0x12)Out[7]: 18In [8]: int(&#x27;23&#x27;)Out[8]: 23In [9]: int(&#x27;1111&#x27;, 2)Out[9]: 15In [10]: int(&#x27;11&#x27;, 16)Out[10]: 17In [11]: bin(123)Out[11]: &#x27;0b1111011&#x27;In [12]: int(&#x27;1111011&#x27;, 2)Out[12]: 123 bytes和数字之间的转换1234567891011121314151617181920212223In [17]: from Crypto.Util.number import long_to_bytes, bytes_to_longIn [18]: bytes_to_long(b&#x27;flag&#x27;)Out[18]: 1718378855In [19]: hex(1718378855)Out[19]: &#x27;0x666c6167&#x27;In [20]: from binascii import *In [21]: unhexlify(1718378855)---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-21-43c0727e7de8&gt; in &lt;module&gt;----&gt; 1 unhexlify(1718378855)TypeError: argument should be bytes, buffer or ASCII string, not &#x27;int&#x27;In [22]: unhexlify(&#x27;666c6167&#x27;)Out[22]: b&#x27;flag&#x27;In [23]: long_to_bytes(1718378855)Out[23]: b&#x27;flag&#x27; 列表和bytes,str类型转换1234567891011121314151617In [28]: a = b&#x27;flag&#x27;In [29]: b = list(a)In [30]: bOut[30]: [102, 108, 97, 103]In [31]: bytes(b)Out[31]: b&#x27;flag&#x27; In [36]: a = list(&quot;flag&quot;)In [37]: aOut[37]: [&#x27;f&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;g&#x27;]In [38]: &quot;&quot;.join(a)Out[38]: &#x27;flag&#x27;","categories":[{"name":"python","slug":"python","permalink":"https://zzzzsky.github.io/categories/python/"}],"tags":[{"name":"struct","slug":"struct","permalink":"https://zzzzsky.github.io/tags/struct/"}]},{"title":"2021西湖论剑_RE_WP","slug":"2021西湖论剑_RE_WP","date":"2021-12-02T12:37:00.000Z","updated":"2021-12-02T12:37:36.844Z","comments":true,"path":"2021/12/02/2021西湖论剑_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/12/02/2021%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91_RE_WP/","excerpt":"","text":"2021西湖论剑_RE_WPTacticalArmedIDA打开发现有TLS回调函数，如果没有调试就初始化4个值 直接patch，强制jmp到4010F1的位置 第50行，v21那里是每次执行的指令 写OD脚本，在004014A3和 40146D位置下断点，OD运行脚本，打印出下图中一轮来 12345678910111213141516var fvar xmov f,&quot;C:\\\\Users\\\\ZSKY\\\\Desktop\\\\xihulunjian\\\\log.txt&quot;vv:RUNcmp eip,004014A3je stopcmp eip,40146Djnz vvstiopcode eipeval &quot;&#123;eip&#125; : &#123;$RESULT_1&#125;&quot;wrta f,$RESULTjmp vvstop:pause 1234567891011121314151617181920212223242526272829303132335AC720 : mov ecx,dword ptr ds:[0x405748]5AC720 : sub ecx,0x7E5A96D25AC720 : mov dword ptr ds:[0x405748],ecx5AC720 : mov edx,dword ptr ds:[0x40564C]5AC720 : shr edx,0x55AC720 : mov eax,dword ptr ds:[0x405004]5AC720 : add eax,edx5AC720 : mov ecx,dword ptr ds:[0x405748]5AC720 : add ecx,dword ptr ds:[0x40564C]5AC720 : xor eax,ecx5AC720 : mov edx,dword ptr ds:[0x40564C]5AC720 : shl edx,0x45AC720 : mov ecx,dword ptr ds:[0x405000]5AC720 : add ecx,edx5AC720 : xor eax,ecx5AC720 : mov edx,dword ptr ds:[0x405648]5AC720 : add edx,eax5AC720 : mov dword ptr ds:[0x405648],edx5AC720 : mov eax,dword ptr ds:[0x405648]5AC720 : shr eax,0x55AC720 : mov ecx,dword ptr ds:[0x40500C]5AC720 : add ecx,eax5AC720 : mov edx,dword ptr ds:[0x405748]5AC720 : add edx,dword ptr ds:[0x405648]5AC720 : xor ecx,edx5AC720 : mov eax,dword ptr ds:[0x405648]5AC720 : shl eax,0x45AC720 : mov edx,dword ptr ds:[0x405008]5AC720 : add edx,eax5AC720 : xor ecx,edx5AC720 : mov eax,dword ptr ds:[0x40564C]5AC720 : add eax,ecx5AC720 : mov dword ptr ds:[0x40564C],eax 在IDA中随便找个地方patch下上面汇编，然后F5 稍微整理整理 这不就是tea结构吗，只不过delta换了，然后循环变为了33轮,提取出数据写脚本即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;unsigned char enc_flag[] = &#123; 0xED, 0x1D, 0x2F, 0x42, 0x72, 0xE4, 0x85, 0x14, 0xD5, 0x78, 0x55, 0x03, 0xA2, 0x80, 0x6B, 0xBF, 0x45, 0x72, 0xD7, 0x97, 0xD1, 0x75, 0xAE, 0x2D, 0x63, 0xA9, 0x5F, 0x66, 0x74, 0x6D, 0x2E, 0x29, 0xC1, 0xFC, 0x95, 0x97, 0xE9, 0xC8, 0xB5, 0x0B, 0&#125;;uint32_t key[] = &#123; 0x7CE45630, 0x58334908, 0x66398867, 0x0C35195B1&#125;;void decrypt(uint32_t *v, uint32_t *k, uint32_t *pSum)&#123; uint32_t v0 = v[0], v1 = v[1], i; uint32_t delta = 0x7E5A96D2; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 33; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + *pSum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + *pSum) ^ ((v1 &gt;&gt; 5) + k1); *pSum += delta; &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; unsigned sum = 0; for (int i = 0; i &lt; 33 * 5; i++) &#123; sum -= 0x7E5A96D2; &#125; uint32_t *pFlag = (uint32_t *)enc_flag; for (int i = 0; i &lt; 5; i++) &#123; decrypt(pFlag + (4 - i) * 2, key, &amp;sum); &#125; printf(&quot;%s&quot;, pFlag); return 0;&#125;# kgD1ogB2yGa2roiAeXiG8_aqnLzCJ_rFHSPrn55K flag为 kgD1ogB2yGa2roiAeXiG8_aqnLzCJ_rFHSPrn55K gghdlIDA打开程序 直接F5分析一波 case 0是输入flag，case 5是验证flag是否正确，case 6是对flag中的每个字符进行加密，case 7是将加密后的每个字符后的数据与程序中生成的数据比较 调试起来 加密后v127指向的值为 2, 3, 2, 2, 2, 2, 2, 3 ， 而ord(‘A’) = 0x41, 二进制为 01000001 也就是把2换为0， 把3换为1 然后运行来到case 7的位置 v126的值为3, 3, 2, 3, 3, 3, 2, 3 转为二进制 0b11011101 1234Python&gt;0b110111010xddPython&gt;0xdd ^ ord(&#x27;A&#x27;)0x9c 然后下面的同理，发现全都是xor 0x9c, 一步步调试将对比的数据v123提取出来，然后3变为1，2变为0，转为2进制，再xor 0x9c即为flag 1234567enc = [0b11011000, 0b11011101, 0b11001111, 0b11011111, 0b11001000, 0b11011010, 0b11100111, 0b10101100, 0b10101010, 0b10101110, 0b10100101, 0b10101101, 0b10100101, 0b10101010, 0b10101110, 0b10110001, 0b11111101, 0b11111110, 0b11111101, 0b11111000, 0b10110001, 0b10101000, 0b10101100, 0b11111111, 0b10100100, 0b10110001, 0b10100100, 0b10101111, 0b10101101, 0b10100100, 0b10110001, 0b11111010, 0b10101100, 0b11111101, 0b10101010, 0b11111110, 0b10101101, 0b10100100, 0b10101010, 0b10101000, 0b10100100, 0b10101110, 0b11111111, 0b11100001]flag = [chr(i ^ 0x9c) for i in enc]print(&quot;&quot;.join(flag))# DASCTF&#123;06291962-abad-40c8-8318-f0a6b186482c&#125; 验证下 flag正确，flag为 DASCTF&#123;06291962-abad-40c8-8318-f0a6b186482c&#125; RORIDA打开分析 先找出byte_405000的索引，然后Z3解即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from z3 import *ENC_FLAG = [0x65, 0x55, 0x24, 0x36, 0x9D, 0x71, 0xB8, 0xC8, 0x65, 0xFB, 0x87, 0x7F, 0x9A, 0x9C, 0xB1, 0xDF, 0x65, 0x8F, 0x9D, 0x39, 0x8F, 0x11, 0xF6, 0x8E, 0x65, 0x42, 0xDA, 0xB4, 0x8C, 0x39, 0xFB, 0x99, 0x65, 0x48, 0x6A, 0xCA, 0x63, 0xE7, 0xA4, 0x79]byte_405000 = [0x65, 0x08, 0xF7, 0x12, 0xBC, 0xC3, 0xCF, 0xB8, 0x83, 0x7B, 0x02, 0xD5, 0x34, 0xBD, 0x9F, 0x33, 0x77, 0x76, 0xD4, 0xD7, 0xEB, 0x90, 0x89, 0x5E, 0x54, 0x01, 0x7D, 0xF4, 0x11, 0xFF, 0x99, 0x49, 0xAD, 0x57, 0x46, 0x67, 0x2A, 0x9D, 0x7F, 0xD2, 0xE1, 0x21, 0x8B, 0x1D, 0x5A, 0x91, 0x38, 0x94, 0xF9, 0x0C, 0x00, 0xCA, 0xE8, 0xCB, 0x5F, 0x19, 0xF6, 0xF0, 0x3C, 0xDE, 0xDA, 0xEA, 0x9C, 0x14, 0x75, 0xA4, 0x0D, 0x25, 0x58, 0xFC, 0x44, 0x86, 0x05, 0x6B, 0x43, 0x9A, 0x6D, 0xD1, 0x63, 0x98, 0x68, 0x2D, 0x52, 0x3D, 0xDD, 0x88, 0xD6, 0xD0, 0xA2, 0xED, 0xA5, 0x3B, 0x45, 0x3E, 0xF2, 0x22, 0x06, 0xF3, 0x1A, 0xA8, 0x09, 0xDC, 0x7C, 0x4B, 0x5C, 0x1E, 0xA1, 0xB0, 0x71, 0x04, 0xE2, 0x9B, 0xB7, 0x10, 0x4E, 0x16, 0x23, 0x82, 0x56, 0xD8, 0x61, 0xB4, 0x24, 0x7E, 0x87, 0xF8, 0x0A, 0x13, 0xE3, 0xE4, 0xE6, 0x1C, 0x35, 0x2C, 0xB1, 0xEC, 0x93, 0x66, 0x03, 0xA9, 0x95, 0xBB, 0xD3, 0x51, 0x39, 0xE7, 0xC9, 0xCE, 0x29, 0x72, 0x47, 0x6C, 0x70, 0x15, 0xDF, 0xD9, 0x17, 0x74, 0x3F, 0x62, 0xCD, 0x41, 0x07, 0x73, 0x53, 0x85, 0x31, 0x8A, 0x30, 0xAA, 0xAC, 0x2E, 0xA3, 0x50, 0x7A, 0xB5, 0x8E, 0x69, 0x1F, 0x6A, 0x97, 0x55, 0x3A, 0xB2, 0x59, 0xAB, 0xE0, 0x28, 0xC0, 0xB3, 0xBE, 0xCC, 0xC6, 0x2B, 0x5B, 0x92, 0xEE, 0x60, 0x20, 0x84, 0x4D, 0x0F, 0x26, 0x4A, 0x48, 0x0B, 0x36, 0x80, 0x5D, 0x6F, 0x4C, 0xB9, 0x81, 0x96, 0x32, 0xFD, 0x40, 0x8D, 0x27, 0xC1, 0x78, 0x4F, 0x79, 0xC8, 0x0E, 0x8C, 0xE5, 0x9E, 0xAE, 0xBF, 0xEF, 0x42, 0xC5, 0xAF, 0xA0, 0xC2, 0xFA, 0xC7, 0xB6, 0xDB, 0x18, 0xC4, 0xA6, 0xFE, 0xE9, 0xF5, 0x6E, 0x64, 0x2F, 0xF1, 0x1B, 0xFB, 0xBA, 0xA7, 0x37, 0x8F]indexs = []for i in range(len(ENC_FLAG)): indexs.append(byte_405000.index(ENC_FLAG[i]))v6 = [0] * 8v6[0] = 128v6[1] = 64v6[2] = 32v6[3] = 16v6[4] = 8v6[5] = 4v6[6] = 2v6[7] = 1flag = [BitVec(&quot;flag%d&quot; % i, 8) for i in range(40)]s = Solver()for i in range(0, 40, 8): for j in range(8): v5 = ((v6[j] &amp; flag[i + 3]) &lt;&lt; (8 - (3 - j) % 8)) | ((v6[j] &amp; flag[i + 3]) &gt;&gt; ((3 - j) % 8)) | ((v6[j] &amp; flag[i + 2]) &lt;&lt; (8 - (2 - j) % 8)) | ((v6[j] &amp; flag[i + 2]) &gt;&gt; ((2 - j) % 8)) | ((v6[j] &amp; flag[i + 1]) &lt;&lt; (8 - (1 - j) % 8)) | ((v6[j] &amp; flag[i + 1]) &gt;&gt; ((1 - j) % 8)) | ((v6[j] &amp; flag[i]) &lt;&lt; (8 - -j % 8)) | ((v6[j] &amp; flag[i]) &gt;&gt; (-j % 8)) index = ((v6[j] &amp; flag[i + 7]) &lt;&lt; (8 - (7 - j) % 8)) | ((v6[j] &amp; flag[i + 7]) &gt;&gt; ((7 - j) % 8)) | ((v6[j] &amp; flag[i + 6]) &lt;&lt; (8 - (6 - j) % 8)) | ((v6[j] &amp; flag[i + 6]) &gt;&gt; ((6 - j) % 8) ) | ((v6[j] &amp; flag[i + 5]) &lt;&lt; (8 - (5 - j) % 8)) | ((v6[j] &amp; flag[i + 5]) &gt;&gt; ((5 - j) % 8)) | ((v6[j] &amp; flag[i + 4]) &lt;&lt; (8 - (4 - j) % 8)) | ((v6[j] &amp; flag[i + 4]) &gt;&gt; ((4 - j) % 8)) | v5 s.add(index == indexs[i+j])assert s.check() == satm = s.model()flag = [chr(m[i].as_long()) for i in flag]print(&quot;DASCTF&#123;&quot; + &quot;&quot;.join(flag) + &quot;&#125;&quot;)# DASCTF&#123;Q5la5_3KChtem6_HYHk_NlHhNZz73aCZeK05II96&#125; 虚假的粉丝IDA打开程序分析 \\ 输入3个数字 文件序号 读取此文件的偏移 从偏移处读多少个字节 然后下面判断读取的数据Buffer[0] != &#39;U&#39; || Buffer[39] != &#39;S&#39; 写脚本判断哪个文件含有这2个字母 12345678for i in range(1, 5317): filename = &quot;f/ASCII-faded &quot; + str(i).zfill(4) + &quot;.txt&quot; f = open(filename, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) c = f.read() if &#x27;U&#x27; in c and &#x27;S&#x27; in c: print(filename) f.close()# f/ASCII-faded 4157.txt 于是打开找到了 UzNDcmU3X0szeSUyMCUzRCUyMEFsNE5fd0FsSzNS 将其base64解密为S3Cre7_K3y%20%3D%20Al4N_wAlK3R URL_decode后为 S3Cre7_K3y = Al4N_wAlK3R 偏移是0x45E(1118), 输入的三个数字是4157, 1118, 40，然后输入 Al4N_wAlK3R 最终/f/ASCII-faded 5315.txt 会被解密，打开即可看到flag flag为 A_TrUe_AW_f4ns 题目附件链接：https://pan.baidu.com/s/1Manwxlun-0gK4ZdkzBU0Zw提取码：sj8s","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"z3","slug":"z3","permalink":"https://zzzzsky.github.io/tags/z3/"}]},{"title":"NCTF2021_RE_WP","slug":"NCTF2021_RE_WP","date":"2021-11-29T06:41:34.000Z","updated":"2021-11-29T11:44:44.992Z","comments":true,"path":"2021/11/29/NCTF2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/29/NCTF2021_RE_WP/","excerpt":"","text":"NCTF2021_RE_WPHello せかい记事本都能做的题.IDA打开直接看到flag flag为 NCTF&#123;We1come_2_Reverse_Engineering&#125; Shadowbringerbase64换了2次表，调试起来找到表，逆回去即可 写脚本解密 1234567891011121314import base64flag = &quot;U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!&quot;std_table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;my_table = &#x27;#$%&amp;\\x27()*+,-.s0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[h]^_`ab&#x27;my_table2 = &#x27;ba`_^]h[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210s.-,+*)(\\x27&amp;%$#&#x27;flag = flag.translate(str.maketrans(my_table2, std_table))flag = flag.replace(&quot;!&quot;, &#x27;=&#x27;).encode() # &quot;6G074JP+s)WV:Z+T&lt;&amp;(Q18`Ks)WV:Y4hs9[h:YCS?&amp;0`&quot;flag = base64.b64decode(flag).decode()flag = flag.translate(str.maketrans(my_table, std_table))print(base64.b64decode(flag))# NCTF&#123;H0m3_r1d1n9_h0m3_dy1n9_h0p3&#125; flag 为 NCTF&#123;H0m3_r1d1n9_h0m3_dy1n9_h0p3&#125; 鲨鲨的秘密这个题跟西湖论剑那个第一个RE题好像 loc_404E3B为执行的指令，因为每次就33条汇编，也不长，直接调试把第一轮所有的汇编拿出来分析 12345678910111213141516171819202122232425262728293031323334mov ds:dword_404E50, 0FFFFFFFFh # dword_404E50 = -1mov ecx, ds:Imov dl, [ecx+4049F8h] # flag[0]mov byte ptr ds:dword_404E4C, dl movzx eax, byte ptr ds:dword_404E4Cxor eax, ds:dword_404E50 dword_404E4C = (flag[0] ^ 404E50 ) &amp; 0xFFmov byte ptr ds:dword_404E4C, almovzx ecx, byte ptr ds:dword_404E4Cand ecx, 0FFh dword_404E50 &gt;&gt;= 8mov byte ptr ds:dword_404E4C, clmov edx, ds:dword_404E50 dword_404E50 ^= dword_404A38[dword_404E4C * 4]shr edx, 8mov ds:dword_404E50, edxmovzx eax, byte ptr ds:dword_404E4Cmov ecx, ds:dword_404E50xor ecx, ds:dword_404A38[eax*4]mov ds:dword_404E50, ecxmov edx, ds:Imov al, [edx+4049F9h] # flag[1]mov byte ptr ds:dword_404E4C, almovzx ecx, byte ptr ds:dword_404E4Cxor ecx, ds:dword_404E50 404E4C = flag[1] ^ 404E50mov byte ptr ds:dword_404E4C, clmov edx, ds:dword_404E50 shr edx, 8 dword_404E50 &gt;&gt;= 8mov ds:dword_404E50, edxmovzx eax, byte ptr ds:dword_404E4Cmov ecx, ds:dword_404E50xor ecx, ds:dword_404A38[eax*4] dword_404E50 ^= dword_404A38[dword_404E4C * 4]mov ds:dword_404E50, ecxmov edx, ds:dword_404E50xor edx, 0FFFFFFFFhmov ds:dword_404E50, edx 分析完毕，把程序中加密后的flag提取出来直接爆破 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;windows.h&gt;unsigned char byte_404A38[] =&#123; 0x00, 0x00, 0x00, 0x00, 0x96, 0x30, 0x07, 0x77, 0x2C, 0x61, 0x0E, 0xEE, 0xBA, 0x51, 0x09, 0x99, 0x19, 0xC4, 0x6D, 0x07, 0x8F, 0xF4, 0x6A, 0x70, 0x35, 0xA5, 0x63, 0xE9, 0xA3, 0x95, 0x64, 0x9E, 0x32, 0x88, 0xDB, 0x0E, 0xA4, 0xB8, 0xDC, 0x79, 0x1E, 0xE9, 0xD5, 0xE0, 0x88, 0xD9, 0xD2, 0x97, 0x2B, 0x4C, 0xB6, 0x09, 0xBD, 0x7C, 0xB1, 0x7E, 0x07, 0x2D, 0xB8, 0xE7, 0x91, 0x1D, 0xBF, 0x90, 0x64, 0x10, 0xB7, 0x1D, 0xF2, 0x20, 0xB0, 0x6A, 0x48, 0x71, 0xB9, 0xF3, 0xDE, 0x41, 0xBE, 0x84, 0x7D, 0xD4, 0xDA, 0x1A, 0xEB, 0xE4, 0xDD, 0x6D, 0x51, 0xB5, 0xD4, 0xF4, 0xC7, 0x85, 0xD3, 0x83, 0x56, 0x98, 0x6C, 0x13, 0xC0, 0xA8, 0x6B, 0x64, 0x7A, 0xF9, 0x62, 0xFD, 0xEC, 0xC9, 0x65, 0x8A, 0x4F, 0x5C, 0x01, 0x14, 0xD9, 0x6C, 0x06, 0x63, 0x63, 0x3D, 0x0F, 0xFA, 0xF5, 0x0D, 0x08, 0x8D, 0xC8, 0x20, 0x6E, 0x3B, 0x5E, 0x10, 0x69, 0x4C, 0xE4, 0x41, 0x60, 0xD5, 0x72, 0x71, 0x67, 0xA2, 0xD1, 0xE4, 0x03, 0x3C, 0x47, 0xD4, 0x04, 0x4B, 0xFD, 0x85, 0x0D, 0xD2, 0x6B, 0xB5, 0x0A, 0xA5, 0xFA, 0xA8, 0xB5, 0x35, 0x6C, 0x98, 0xB2, 0x42, 0xD6, 0xC9, 0xBB, 0xDB, 0x40, 0xF9, 0xBC, 0xAC, 0xE3, 0x6C, 0xD8, 0x32, 0x75, 0x5C, 0xDF, 0x45, 0xCF, 0x0D, 0xD6, 0xDC, 0x59, 0x3D, 0xD1, 0xAB, 0xAC, 0x30, 0xD9, 0x26, 0x3A, 0x00, 0xDE, 0x51, 0x80, 0x51, 0xD7, 0xC8, 0x16, 0x61, 0xD0, 0xBF, 0xB5, 0xF4, 0xB4, 0x21, 0x23, 0xC4, 0xB3, 0x56, 0x99, 0x95, 0xBA, 0xCF, 0x0F, 0xA5, 0xBD, 0xB8, 0x9E, 0xB8, 0x02, 0x28, 0x08, 0x88, 0x05, 0x5F, 0xB2, 0xD9, 0x0C, 0xC6, 0x24, 0xE9, 0x0B, 0xB1, 0x87, 0x7C, 0x6F, 0x2F, 0x11, 0x4C, 0x68, 0x58, 0xAB, 0x1D, 0x61, 0xC1, 0x3D, 0x2D, 0x66, 0xB6, 0x90, 0x41, 0xDC, 0x76, 0x06, 0x71, 0xDB, 0x01, 0xBC, 0x20, 0xD2, 0x98, 0x2A, 0x10, 0xD5, 0xEF, 0x89, 0x85, 0xB1, 0x71, 0x1F, 0xB5, 0xB6, 0x06, 0xA5, 0xE4, 0xBF, 0x9F, 0x33, 0xD4, 0xB8, 0xE8, 0xA2, 0xC9, 0x07, 0x78, 0x34, 0xF9, 0x00, 0x0F, 0x8E, 0xA8, 0x09, 0x96, 0x18, 0x98, 0x0E, 0xE1, 0xBB, 0x0D, 0x6A, 0x7F, 0x2D, 0x3D, 0x6D, 0x08, 0x97, 0x6C, 0x64, 0x91, 0x01, 0x5C, 0x63, 0xE6, 0xF4, 0x51, 0x6B, 0x6B, 0x62, 0x61, 0x6C, 0x1C, 0xD8, 0x30, 0x65, 0x85, 0x4E, 0x00, 0x62, 0xF2, 0xED, 0x95, 0x06, 0x6C, 0x7B, 0xA5, 0x01, 0x1B, 0xC1, 0xF4, 0x08, 0x82, 0x57, 0xC4, 0x0F, 0xF5, 0xC6, 0xD9, 0xB0, 0x65, 0x50, 0xE9, 0xB7, 0x12, 0xEA, 0xB8, 0xBE, 0x8B, 0x7C, 0x88, 0xB9, 0xFC, 0xDF, 0x1D, 0xDD, 0x62, 0x49, 0x2D, 0xDA, 0x15, 0xF3, 0x7C, 0xD3, 0x8C, 0x65, 0x4C, 0xD4, 0xFB, 0x58, 0x61, 0xB2, 0x4D, 0xCE, 0x51, 0xB5, 0x3A, 0x74, 0x00, 0xBC, 0xA3, 0xE2, 0x30, 0xBB, 0xD4, 0x41, 0xA5, 0xDF, 0x4A, 0xD7, 0x95, 0xD8, 0x3D, 0x6D, 0xC4, 0xD1, 0xA4, 0xFB, 0xF4, 0xD6, 0xD3, 0x6A, 0xE9, 0x69, 0x43, 0xFC, 0xD9, 0x6E, 0x34, 0x46, 0x88, 0x67, 0xAD, 0xD0, 0xB8, 0x60, 0xDA, 0x73, 0x2D, 0x04, 0x44, 0xE5, 0x1D, 0x03, 0x33, 0x5F, 0x4C, 0x0A, 0xAA, 0xC9, 0x7C, 0x0D, 0xDD, 0x3C, 0x71, 0x05, 0x50, 0xAA, 0x41, 0x02, 0x27, 0x10, 0x10, 0x0B, 0xBE, 0x86, 0x20, 0x0C, 0xC9, 0x25, 0xB5, 0x68, 0x57, 0xB3, 0x85, 0x6F, 0x20, 0x09, 0xD4, 0x66, 0xB9, 0x9F, 0xE4, 0x61, 0xCE, 0x0E, 0xF9, 0xDE, 0x5E, 0x98, 0xC9, 0xD9, 0x29, 0x22, 0x98, 0xD0, 0xB0, 0xB4, 0xA8, 0xD7, 0xC7, 0x17, 0x3D, 0xB3, 0x59, 0x81, 0x0D, 0xB4, 0x2E, 0x3B, 0x5C, 0xBD, 0xB7, 0xAD, 0x6C, 0xBA, 0xC0, 0x20, 0x83, 0xB8, 0xED, 0xB6, 0xB3, 0xBF, 0x9A, 0x0C, 0xE2, 0xB6, 0x03, 0x9A, 0xD2, 0xB1, 0x74, 0x39, 0x47, 0xD5, 0xEA, 0xAF, 0x77, 0xD2, 0x9D, 0x15, 0x26, 0xDB, 0x04, 0x83, 0x16, 0xDC, 0x73, 0x12, 0x0B, 0x63, 0xE3, 0x84, 0x3B, 0x64, 0x94, 0x3E, 0x6A, 0x6D, 0x0D, 0xA8, 0x5A, 0x6A, 0x7A, 0x0B, 0xCF, 0x0E, 0xE4, 0x9D, 0xFF, 0x09, 0x93, 0x27, 0xAE, 0x00, 0x0A, 0xB1, 0x9E, 0x07, 0x7D, 0x44, 0x93, 0x0F, 0xF0, 0xD2, 0xA3, 0x08, 0x87, 0x68, 0xF2, 0x01, 0x1E, 0xFE, 0xC2, 0x06, 0x69, 0x5D, 0x57, 0x62, 0xF7, 0xCB, 0x67, 0x65, 0x80, 0x71, 0x36, 0x6C, 0x19, 0xE7, 0x06, 0x6B, 0x6E, 0x76, 0x1B, 0xD4, 0xFE, 0xE0, 0x2B, 0xD3, 0x89, 0x5A, 0x7A, 0xDA, 0x10, 0xCC, 0x4A, 0xDD, 0x67, 0x6F, 0xDF, 0xB9, 0xF9, 0xF9, 0xEF, 0xBE, 0x8E, 0x43, 0xBE, 0xB7, 0x17, 0xD5, 0x8E, 0xB0, 0x60, 0xE8, 0xA3, 0xD6, 0xD6, 0x7E, 0x93, 0xD1, 0xA1, 0xC4, 0xC2, 0xD8, 0x38, 0x52, 0xF2, 0xDF, 0x4F, 0xF1, 0x67, 0xBB, 0xD1, 0x67, 0x57, 0xBC, 0xA6, 0xDD, 0x06, 0xB5, 0x3F, 0x4B, 0x36, 0xB2, 0x48, 0xDA, 0x2B, 0x0D, 0xD8, 0x4C, 0x1B, 0x0A, 0xAF, 0xF6, 0x4A, 0x03, 0x36, 0x60, 0x7A, 0x04, 0x41, 0xC3, 0xEF, 0x60, 0xDF, 0x55, 0xDF, 0x67, 0xA8, 0xEF, 0x8E, 0x6E, 0x31, 0x79, 0xBE, 0x69, 0x46, 0x8C, 0xB3, 0x61, 0xCB, 0x1A, 0x83, 0x66, 0xBC, 0xA0, 0xD2, 0x6F, 0x25, 0x36, 0xE2, 0x68, 0x52, 0x95, 0x77, 0x0C, 0xCC, 0x03, 0x47, 0x0B, 0xBB, 0xB9, 0x16, 0x02, 0x22, 0x2F, 0x26, 0x05, 0x55, 0xBE, 0x3B, 0xBA, 0xC5, 0x28, 0x0B, 0xBD, 0xB2, 0x92, 0x5A, 0xB4, 0x2B, 0x04, 0x6A, 0xB3, 0x5C, 0xA7, 0xFF, 0xD7, 0xC2, 0x31, 0xCF, 0xD0, 0xB5, 0x8B, 0x9E, 0xD9, 0x2C, 0x1D, 0xAE, 0xDE, 0x5B, 0xB0, 0xC2, 0x64, 0x9B, 0x26, 0xF2, 0x63, 0xEC, 0x9C, 0xA3, 0x6A, 0x75, 0x0A, 0x93, 0x6D, 0x02, 0xA9, 0x06, 0x09, 0x9C, 0x3F, 0x36, 0x0E, 0xEB, 0x85, 0x67, 0x07, 0x72, 0x13, 0x57, 0x00, 0x05, 0x82, 0x4A, 0xBF, 0x95, 0x14, 0x7A, 0xB8, 0xE2, 0xAE, 0x2B, 0xB1, 0x7B, 0x38, 0x1B, 0xB6, 0x0C, 0x9B, 0x8E, 0xD2, 0x92, 0x0D, 0xBE, 0xD5, 0xE5, 0xB7, 0xEF, 0xDC, 0x7C, 0x21, 0xDF, 0xDB, 0x0B, 0xD4, 0xD2, 0xD3, 0x86, 0x42, 0xE2, 0xD4, 0xF1, 0xF8, 0xB3, 0xDD, 0x68, 0x6E, 0x83, 0xDA, 0x1F, 0xCD, 0x16, 0xBE, 0x81, 0x5B, 0x26, 0xB9, 0xF6, 0xE1, 0x77, 0xB0, 0x6F, 0x77, 0x47, 0xB7, 0x18, 0xE6, 0x5A, 0x08, 0x88, 0x70, 0x6A, 0x0F, 0xFF, 0xCA, 0x3B, 0x06, 0x66, 0x5C, 0x0B, 0x01, 0x11, 0xFF, 0x9E, 0x65, 0x8F, 0x69, 0xAE, 0x62, 0xF8, 0xD3, 0xFF, 0x6B, 0x61, 0x45, 0xCF, 0x6C, 0x16, 0x78, 0xE2, 0x0A, 0xA0, 0xEE, 0xD2, 0x0D, 0xD7, 0x54, 0x83, 0x04, 0x4E, 0xC2, 0xB3, 0x03, 0x39, 0x61, 0x26, 0x67, 0xA7, 0xF7, 0x16, 0x60, 0xD0, 0x4D, 0x47, 0x69, 0x49, 0xDB, 0x77, 0x6E, 0x3E, 0x4A, 0x6A, 0xD1, 0xAE, 0xDC, 0x5A, 0xD6, 0xD9, 0x66, 0x0B, 0xDF, 0x40, 0xF0, 0x3B, 0xD8, 0x37, 0x53, 0xAE, 0xBC, 0xA9, 0xC5, 0x9E, 0xBB, 0xDE, 0x7F, 0xCF, 0xB2, 0x47, 0xE9, 0xFF, 0xB5, 0x30, 0x1C, 0xF2, 0xBD, 0xBD, 0x8A, 0xC2, 0xBA, 0xCA, 0x30, 0x93, 0xB3, 0x53, 0xA6, 0xA3, 0xB4, 0x24, 0x05, 0x36, 0xD0, 0xBA, 0x93, 0x06, 0xD7, 0xCD, 0x29, 0x57, 0xDE, 0x54, 0xBF, 0x67, 0xD9, 0x23, 0x2E, 0x7A, 0x66, 0xB3, 0xB8, 0x4A, 0x61, 0xC4, 0x02, 0x1B, 0x68, 0x5D, 0x94, 0x2B, 0x6F, 0x2A, 0x37, 0xBE, 0x0B, 0xB4, 0xA1, 0x8E, 0x0C, 0xC3, 0x1B, 0xDF, 0x05, 0x5A, 0x8D, 0xEF, 0x02, 0x2D&#125;;unsigned char compare[] = &#123; 0x5E, 0x60, 0xF6, 0xC0, 0x0A, 0x6E, 0xB1, 0x00, 0xD2, 0xA2, 0x19, 0x33, 0xB7, 0xB7, 0xCA, 0x57, 0x9C, 0x6D, 0x64, 0x9A, 0x26, 0x27, 0xD8, 0xBD, 0x91, 0xFB, 0x38, 0xD8, 0xB3, 0x0B, 0xE1, 0x8D, 0xAD, 0x0D, 0x6B, 0x17, 0xEF, 0xDE, 0x5F, 0x68, 0xB1, 0xF7, 0x1F, 0x2C, 0x96, 0x42, 0x44, 0x6C, 0x90, 0xFE, 0x5C, 0xA1, 0x21, 0x87, 0xCD, 0x20, 0xE8, 0x7C, 0x96, 0x62, 0xFD, 0x41, 0x16, 0x2C, 0x9A, 0x0F, 0x2D, 0x57, 0x2C, 0xDC, 0x52, 0xAE, 0xCF, 0x7D, 0x49, 0x50, 0x4A, 0xBF, 0x6A, 0xFF&#125;;int main() &#123; DWORD* dword_404A38 = (DWORD*)byte_404A38; DWORD* dwcompare = (DWORD*)compare; char flag[40] = &#123;0&#125;; for (int k = 0; k &lt; 40; k+=2) &#123; for (int i = 32; i &lt; 128; i++) &#123; for (int j = 32; j &lt; 128; j++) &#123; flag[0] = i; flag[1] = j; DWORD dword_404E50 = 0xFFFFFFFF; DWORD dword_404E4C = (flag[0] ^ dword_404E50) &amp; 0xFF; dword_404E50 &gt;&gt;= 8; dword_404E50 ^= dword_404A38[dword_404E4C]; dword_404E4C = (flag[1] ^ dword_404E50) &amp; 0Xff; dword_404E50 &gt;&gt;= 8; dword_404E50 ^= dword_404A38[dword_404E4C]; dword_404E50 = 0xFFFFFFFF - dword_404E50; if (dword_404E50 == dwcompare[k/2]) &#123; printf(&quot;%c%c&quot;, i, j); &#125; &#125; &#125; &#125; return 0;&#125; flag为 NCTF&#123;rLdE57TG0iHA39qUnFZp6LeJyYEBcxMNL7&#125; 狗狗的秘密 前面是47进制，直接用C语言实现上面那个框中的算法，调试，输几个数试试就能试出来了 先写脚本从下往上把47进制后的flag弄出来，发现有很多种情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253byte_405018 = [ 0x21, 0x43, 0x65, 0x87, 0x09, 0x21, 0x43, 0x65, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC]byte_405118 = [ 0xA7, 0x1C, 0x7E, 0xAF, 0xD9, 0xC2, 0xC0, 0xBE, 0x1F, 0x45, 0x9A, 0x85, 0x26, 0xE3, 0x87, 0xC3, 0x21, 0xE0, 0x95, 0x10, 0x71, 0x70, 0x02, 0x75, 0x35, 0xA5, 0x1D, 0x0D, 0x2F, 0xEE, 0x25, 0x7B, 0xB5, 0x82, 0x66, 0x8D, 0xDB, 0x53, 0x3A, 0x29, 0xD4, 0x43, 0x99, 0x97, 0x9D, 0xE8, 0x49, 0x00]byte_v17 = [0x52, 0xC3, 0x1A, 0xE0, 0x16, 0x5D, 0x5E, 0xE2, 0x67, 0x1F, 0x1F, 0x06, 0x06, 0x1F, 0x17, 0x06, 0x0F, 0xF9, 0x06, 0x67, 0x58, 0xB2, 0xE2, 0x8C, 0x0F, 0x2A, 0x06, 0x89, 0xCF, 0x2A, 0x06, 0x1F, 0x98, 0x1A, 0x3E, 0x17, 0x67, 0x1F, 0xF7, 0x3A, 0x44, 0xC3, 0x16, 0x33, 0x69, 0x1A, 0x75, 0x16, 0x3E, 0x17, 0xD5, 0x69, 0x7A, 0x1B, 0x44, 0x44, 0x3E, 0x67, 0xF7, 0x89, 0x67]v11 = []for v17 in byte_v17: for i in range(256): c = byte_405018[i] ^ i if c == v17: # print(hex(i)) if i in byte_405118: print(byte_405118.index(i), end=&quot; &quot;) print(&quot;&quot;) 索引为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612 0 33 45 44 30 40 8 2322 11 737 3437 3419 20 4319 20 4337 342419 20 4331 42919 20 4322 11 7135234131 43519 20 439143519 20 4337 34333 45102422 11 737 343812503064233 45363010242142262825251022 11 738922 11 7 然后写脚本，从一头开始试，因为如果一头稍微一改，打印的字符串前面变化很大的话，说明改对了，因为数据高位一改，整个数字变化才大，然后long_to_bytes后对应的字符也变换很大了，如果从低位改，数据变化不大，long_to_bytes后头部的字符变化也不大了， 就这样一点点改，flag就一点点的显示出来了 可能描述的有点抽象，举个例子就很容易懂了 对应的解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from Crypto.Util.number import *compare = [2, 0, 45, 44, 30, 40, 8, 23, 11, 37, 34, 43, 43, 37, 24, 19, 4, 29, 19, # 19 20 43 22, # 22 11 7 13, 5, 23, 41, 4, # 31 4 35, 20, # 19 20 43 9, 14, 35, 43, # 19 20 43 37, # 37 34 3, 33, # 33 45 10, 24, 22, # 22 11 7 37, # 37 34 38, 1, 25, 0, 30, 6, 42, 45, # 33 45 36, 30, 10, 24, 21, 42, 26, 28, 25, 25, 10, 7, 38, 9, 11]sum = 0re_compare = compare[::-1]for i in range(len(compare)): tmp = re_compare[i] * pow(47, i) sum += tmpprint(long_to_bytes(sum))# NCTF&#123;ADF0E239-D911-3781-7E40-A575A19E5835&#125; flag为 NCTF&#123;ADF0E239-D911-3781-7E40-A575A19E5835&#125; easy_mobileJEB打开分析 发现check_flag 的算法在对应的so文件里 IDA打开找到 Java_com_example_rectf_MainActivity_checkflag 函数 哇塞，看这优美的图形，是OLLVM，从网上找来各种脚本平坦化，要么是失败，要么是去了还不如不去容易看 我一共试了这2个脚本 https://github.com/cq674350529/deflat （成功去除，基址设置为0X400000，比如check_flag是0X7900，然后 就运行 python deflat.py -f libnative-lib.so --addr 0x407900，但是去了后我感觉更难看了） https://github.com/pcy190/deobfuscator （这个我去除失败，可能是qiling版本的问题） 好吧，直接硬刚OLLVM，真机调试 如何搭建真机调试环境可以参考我写的这篇文章 https://zzzzsky.com/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/ 在下面每个框中第一条指令下断点，尤其是这种大的块肯定是有用的，先审视一下这种大的块 发现在这个位置调用了strlen，然后与0X18对比 猜测是验证flag的长度，继续审视其他块 在这个位置发现了一些类似密钥的字符串，还调用了一个函数，进入这个 sub_7D30F1E260 函数 根据&lt;&lt; 4 &gt;&gt;5 0X12345678等特征，发现这是一种个TEA算法，delta改为了0X12345678 继续审视，在这个位置发现了一些明文 F5，发现这里还有一些加减乘除的一些操作 开始调试，直接在上面对应的位置下断点，flag先输入12345试试，一点点来到strlen的位置，发现果然是验证flag的长度 继续F9，发现即没有到达加减乘除那个块，也没有到达TEA算法那里就显示NO了，我么输入flag为 123456789012345678901234 好，程序断在了加减乘除那个块那里，直接一点点单步调试 在mul之前停下，观察寄存器，发现X1指向的是最后8个字符，然后来到X16寄存器指向的内存位置，稍微整理整理 发现系统初始化了16个字符 PRST0123789: &quot;#$ ，然后下面紧跟着flag 的前16位，猜测flag是分开验证的16 + 8 跳过乘法，再看内存 最终调试到memcpy的位置 dword_7CD3B3E14C 处的数据为 而刚才0007FD020C630处的数据已经变为了 于是猜测是flag的前16位根据PRST0123789: &quot;#$ 加减乘除后 与dword_7CD3B3E14C进行对比，然后flag 的后8位是那个tea算法 这里一点点调试，发现 1234[&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1687, 1824, 1912, 2002][&#x27;9&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;] * [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] + [&#x27;P&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;] = [2816, 2434, 2533, 2634][&#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1751, 1892, 1982, 2074][&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;] * [&#x27; &#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;] + [&#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;] = [1623, 1756, 1842, 1930] 写脚本解密得到flag的前16个字符 12345678910111213141516171819202122232425262728293031323334a = [3287, 1688, 3452, 1786, 3255, 1994, 1947, 2002, 2384, 2777, 2783, 5286, 3319, 1824, 1842, 2038] mul1 = [ord(i) for i in &quot;0123&quot;]mul2 = [ord(i) for i in &#x27; &quot;#$&#x27;]add1 = [ord(i) for i in &quot;PRST&quot;]add2 = [ord(i) for i in &quot;789:&quot;]flag = []flag1 = [(a[:4][i]-add2[i])/mul2[i] for i in range(4)]flag2 = [(a[4:8][i]-add2[i])/mul2[i] for i in range(4)]flag3 = [(a[8:12][i]-add1[i])/mul1[i] for i in range(4)]flag4 = [(a[12:][i]-add2[i])/mul2[i] for i in range(4)]print(flag1)print(flag2)print(flag3)print(flag4)flag = flag1 + flag2 + flag3 + flag4flag = [chr(int(i)) for i in flag]print(&quot;&quot;.join(flag))# [101.0, 48.0, 97.0, 48.0]# [100.0, 57.0, 54.0, 54.0]# [48.0, 55.0, 54.0, 102.0]# [102.0, 52.0, 51.0, 55.0]# e0a0d966076ff437 然后flag输入e0a0d966076ff437ABCD1234重新调试，果然程序断在了TEA算法的位置 发现果然是对flag的后8个字符进行TEA加密，直接运行到加密完成 然后进入汇编界面单步调试，注意CMP指令 可以发现V0加密后应改为0XC65AEDA, 这里修改X13的值为0XC65AEDA,使其验证通过，然后再单步 运行到这个位置，发现V1加密后的数据为 0xADBF8DB1 直接写脚本解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; //加密函数 void encrypt(uint32_t* v, uint32_t* k) &#123; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; uint32_t delta = 0x12345678; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); &#125; v[0] = v0; v[1] = v1;&#125;//解密函数 void decrypt(uint32_t* v, uint32_t* k) &#123; uint32_t delta = 0x12345678; uint32_t v0 = v[0], v1 = v[1], sum = delta * 32, i; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;unsigned char byte_key[] =&#123; 0x71, 0x69, 0x68, 0x61, 0x68, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x61, 0x6E, 0x61, 0x6E, 0x61, 0x6D&#125;;//char enc[] = &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; &#125;;int main()&#123; //uint32_t* v = (uint32_t*)enc; uint32_t v[2] = &#123; 0x000000000C65AEDA , 0x00000000ADBF8DB1 &#125;; uint32_t* k = (uint32_t*)byte_key; decrypt(v, k); printf(&quot;解密后的数据：%u %u\\n&quot;, v[0], v[1]); return 0;&#125; 后8位是 58af2715 拼凑得到 flag e0a0d966076ff43758af2715 验证成功 纪念AK RE, 拿了3一血，美滋滋 继续加油~~ 题目附件链接：https://pan.baidu.com/s/1FaBD6_FDjKLziKpVqvGe-Q提取码：ptjq","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"ollvm","slug":"ollvm","permalink":"https://zzzzsky.github.io/tags/ollvm/"}]},{"title":"IDA真机调试安卓so文件","slug":"IDA真机调试安卓so文件","date":"2021-11-29T05:03:23.000Z","updated":"2021-11-29T11:44:31.569Z","comments":true,"path":"2021/11/29/IDA真机调试安卓so文件/","link":"","permalink":"https://zzzzsky.github.io/2021/11/29/IDA%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93so%E6%96%87%E4%BB%B6/","excerpt":"","text":"IDA真机调试安卓so文件简要看了网上很多的IDA真机调试安卓的文章，感觉很多步骤没有必要，这里整理一下最简单的实现安卓真机调试的步骤，以便以后参考，以 2021NCTF easy_mobile题目举例 步骤 首先需要一个root 后的手机，用数据线连接电脑，并且开启USB调试 电脑安装好 adb 运行adb devices 观察设备是否已经连接 来到IDA安装目录的文件夹，将 用adb push 电脑源目录 安卓的目的目录 将 dbgsrv对应的文件放到手机文件的某个目录下 运行adb shell 然后su 切换到root权限，来到对应的目录下 给 android_server 和 android_server64加可执行权限 观察此题check_flag函数在libnative-lib.so文件中，为arm64架构 运行对应的server, 这里运行的是./android_server64 端口转发adb forward tcp:23946 tcp:23946 打开IDA，拖入对应的so文件，选择Remote ARM Linux/Android debugger 11、Debugger -&gt; Process options,填写localhost，端口保持默认 12、对应的手机上安装对应的APK文件 13、IDA Debugger -&gt; Attach to process, 选择对应的进程 14、在Java_com_example_rectf_MainActivity_checkflag 函数那里下断点，手机输入flag，点验证，IDA断下 关于这个题的详细题解可以参考 https://zzzzsky.com/2021/11/29/NCTF2021_RE_WP/ 参考文章https://www.cnblogs.com/xuan52rock/p/11010304.html https://blog.csdn.net/Breeze_CAT/article/details/106298559 https://www.i4k.xyz/article/haodawei123/104060906","categories":[{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"真机调试","slug":"真机调试","permalink":"https://zzzzsky.github.io/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/tags/%E5%AE%89%E5%8D%93/"}]},{"title":"2021GFCTF部分RE_WP","slug":"2021GFCTF_WP","date":"2021-11-25T09:05:00.000Z","updated":"2021-11-29T11:41:47.513Z","comments":true,"path":"2021/11/25/2021GFCTF_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/25/2021GFCTF_WP/","excerpt":"","text":"2021GFCTF RE_WPwordy去除花指令 123456789addr =0X556AE377FD56end = 0x0556AE377FE40flag = &quot;&quot;for i in range(addr, end, 13): c = get_bytes(i+4, 1)[0] flag+=chr(c) print(flag)# GFCTF&#123;u_are2wordy&#125; BabyReverseIDA打开，去除所有的花指令 直接看下面对flag如何加密的，进入sub_412E10, 发现是SM4加密 而传入的第二个参数是key，即byte_4409c0是key，回到main函数再往上看，发现前面有一个对byte_4409c0类似RC4加密的操作, 对 byte_4409C0进行交叉引用 于是下断点调试来获取key，发现不行，猜测前面是反调试，从main函数头部下断点调试 最终定位到这个函数 采用的是self_mapping技术实现反调试，本质是创建secion的时候设置SEC_NO_CHANGE，映射后不能改变 Self-Remapping-Code 关于这个技术，可以参考下这位大佬的笔记 https://jev0n.com/2021/09/23/Self-Remapping.html 我们直接将call sub_411CE0 的地方nop掉，手动的把byte_4409c0的地方加1 12345678a = [ 0x07, 0xB8, 0x0D, 0x24, 0xB1, 0x0C, 0x2D, 0xC7, 0x28, 0x2D, 0xC3, 0x61, 0x66, 0x4F, 0x72, 0x13] addr = 0x04409C0for i in range(16): patch_byte(addr+i, a[i]+1)print(&quot;OK&quot;) 运行起来 得到key为 GF?-&gt;GirlFriend? 提取密文 10D 40 3B 87 A5 66 DA 74 92 7F BB E1 B8 CD EB BC 59 45 1B C0 38 99 AA 22 AA 3F 9D 21 07 4E 81 1F SM4在线解密 2e69df5961f20aee0897cf1905156344 , 最终得到flag为 GFCTF&#123;2e69df5961f20aee0897cf1905156344&#125; re_EasyRE_0x00IDA打开分析，最关键的是sub_100016A0函数 经过分析，发现sub_10001180是解密login.key文件，生成的数据放到V13里面 然后下面这个地方是将V13处的数据与生成的一些数据进行对比，猜测是机器码的验证 这是V13处的数据 111 55 66 55 0D 50 51 0C FF 01 80 12 CE A9 08 75 73 65 72 32 33 33 33 最后8个字符是user2333 将对比的数据也提取出来, 然后结合题目，用户名用admin6677登录，长度是9，整理得 111 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37 我们写脚本，每次运行到对比数据的时候就把v13的数据给他替换掉 12345data = [0x11, 0x55, 0x66, 0x55, 0x98, 0xFA, 0x9B, 0x59, 0x6F, 0xF6, 0x14, 0x8F, 0xE9, 0xDA, 0x09, 0x61, 0x64, 0x6D, 0x69, 0x6E, 0x36, 0x36, 0x37, 0x37]addr = 0x004CB348 # v13的地址for i in range(len(data)): patch_byte(addr+i, data[i])print(&quot;OK&quot;) 然后绕过机器码验证，往下走，来到sub_10001610处 可以发现，这个地方肯定是与服务器通信了，我们直接运行，直接Wireshark抓包 提取数据 1234567---&gt; 11 55 66 55 1a 27 00 00 00 00 &lt;--- 11 55 66 55 66 27 00 00 0f 00 f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd ---&gt; 11 55 66 55 1a 27 01 00 40 00 0e a2 60 19 1f df 39 0d bc 62 48 57 5a 11 87 78 69 11 03 76 4b f9 2c 1f 35 fd ff 4a b8 d8 63 8f b6 b1 f0 cd d3 90 2d 27 05 b7 1e 01 22 74 91 1a a4 53 df 1d f4 69 7d 3e 29 bd d3 30 da 94 a3 03 &lt;--- 11 55 66 55 66 27 01 00 48 00 84 cb 11 ef 71 51 30 0b b3 d8 c1 22 ac c4 ca f1 29 12 cf 79 f5 36 5f 5a 5e a8 f5 fa 62 3c e8 32 69 d6 a1 54 eb 1b 06 06 b0 68 20 5a 62 ea 48 ec 8a 3d 5c 40 d0 a8 03 94 6a 2e b7 f0 e4 33 aa a0 e3 f2 da f8 a9 cf 5d 92 重新调试，接着刚才的位置往下分析，看到了RC4的初始化及加密 猜测是刚开始，服务器端返回RC4的key，然后后面全部使用RC4加密方式进行加密 根据sub_10001350这个函数可以猜测出数据包的格式, 拿上面服务器返回的key举例子 1234511 55 66 55 //标志66 27 //版本00 00 //命令0f 00 //后面数据的长度f3 46 8a be 81 62 ed 36 d5 df 28 dc 04 8a fd //数据，当命令为0的时候，是RC4的key，命令为1和2的时候，是RC4加密的数据 写脚本验证RC4加密 1234567891011121314151617181920212223242526272829303132from Crypto.Cipher import ARC4 as rc4cipherimport binasciidef rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return reskey = binascii.unhexlify(&quot;f3468abe8162ed36d5df28dc048afd&quot;)data1 = binascii.unhexlify( &quot;0ea260191fdf390dbc6248575a118778691103764bf92c1f35fdff4ab8d8638fb6b1f0cdd3902d2705b71e012274911aa453df1df4697d3e29bdd330da94a303&quot;)m1 = rc4_algorithm(&quot;dec&quot;, data1, key)data2 = binascii.unhexlify( &quot;84cb11ef7151300bb3d8c122acc4caf12912cf79f5365f5a5ea8f5fa623ce83269d6a154eb1b0606b068205a62ea48ec8a3d5c40d0a803946a2eb7f0e433aaa0e3f2daf8a9cf5d92&quot;)m2 = rc4_algorithm(&quot;dec&quot;, data2, key)print(m1)print(m2)# b&#x27;\\x8ayqv,\\x8eYjj\\xdb\\xfa\\x10\\xd6\\xa0=\\xed!w\\xa9/\\xdd\\xa3\\x1a \\x05!+\\xbd\\xd0\\xa7\\xe7\\xd4\\xba\\t%\\xb9N\\xeeYR\\xdc\\xb0Pfq\\xae\\xe9\\xc7\\x1eB\\xa3\\x0eA\\xb3\\x08\\xcf1\\xb3\\x12\\xa5L\\xd4`\\xcc&#x27;# b&#x27;\\x00\\x10\\x00\\x80B\\x00Please update client!\\r\\nClient version=10010, Server version=10086\\x00&#x27; 结合login.key，发现当命令为1的时候，向服务器发送的是login.key的数据，然后服务器返回信息 所以现在需要构造 真正的login.key(11 55 66 55 98 FA 9B 59 6F F6 14 8F E9 DA 09 61 64 6D 69 6E 36 36 37 37) 加密后的数据 sub_10001180是解密函数，进去分析,发现是RSA的PKCS#1加密 根据这个结构找到e和n 提取出来 12345e: 65537n: 0xd928b8efe000f72db5bda67a9aa0740defb555b2603736eecd6d01f38ef2fc79分解得到p, qp = 322922590106035145437937724697895880569q = 304171468404401467258708275665013611777 利用rsatool.py生成private.pem 1python rsatool.py -e 65537 -p 322922590106035145437937724697895880569 -q 304171468404401467258708275665013611777 -o private.pem 利用在线解密网站测试 https://the-x.cn/cryptography/Rsa.aspx 发现解密成功，将构造好的数据进行加密， 对于PKCS#1的填充方式可以参考下面2篇文章 https://www.cloudcared.cn/3155.html https://www.cnblogs.com/feng9exe/p/8075447.html 然后写程序与服务器交互，发现服务器返回命令为2的验证码问题 Question(Send result in uint32_t format, 1 second!): 9540808 * 32 + 509 * 859 = ? 然后利用eval计算数值，构造，返回给服务器，即可得到flag，完整的exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import socketfrom Crypto.Cipher import ARC4 as rc4cipherimport reimport structlogin_key = [0x5D, 0x98, 0xEE, 0x8B, 0x68, 0x86, 0x2F, 0x56, 0xBA, 0xA1, 0x27, 0x2A, 0x68, 0x8B, 0x19, 0x31, 0x37, 0xC1, 0x2B, 0x1A, 0x80, 0x5F, 0xAB, 0x8C, 0xE0, 0xE6, 0x81, 0xDF, 0x05, 0xC6, 0xB1, 0x2F, 0x0E, 0x59, 0xC8, 0x45, 0x8A, 0x7D, 0x83, 0x35, 0x5F, 0x02, 0x05, 0x10, 0x8A, 0x35, 0x6D, 0x0C, 0xE8, 0x3C, 0x9C, 0x15, 0xD7, 0xDA, 0xF0, 0x96, 0x6D, 0x2E, 0x77, 0xEC, 0x78, 0x3B, 0x83, 0xB2]def rc4_algorithm(encrypt_or_decrypt, data, key1): if encrypt_or_decrypt == &quot;enc&quot;: key = key1 enc = rc4cipher.new(key) res = enc.encrypt(data) return res elif encrypt_or_decrypt == &quot;dec&quot;: key = key1 enc = rc4cipher.new(key) res = enc.decrypt(data) return resdef get_data(_cmd, _len, _data, _key): sig = [0x11, 0x55, 0x66, 0x55] # 签名 banben = [0x66, 0x27] # 版本 cmd_list = [_cmd, 0x00] # 命令 data_len_list = [_len, 0x00] # 数据长度 if _len != 0: return bytes(sig + banben + cmd_list + data_len_list) + rc4_algorithm(&#x27;enc&#x27;, bytes(_data), _key) return bytes(sig + banben + cmd_list + data_len_list)def get_captcha(_captcha_str): m = re.search( r&quot;Question\\(Send result in uint32_t format, 1 second!\\): (.*?) = &quot;, _captcha_str) c = eval(m.group(1)) return struct.pack(&quot;I&quot;, c)if __name__ == &#x27;__main__&#x27;: address = (&#x27;119.27.179.145&#x27;, 10086) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(address) s.send(get_data(0, 0, [], None)) data = s.recv(1024) rc4_key = data[10:] # 获取RC4密钥 s.send(get_data(1, 0x40, login_key, rc4_key)) data = s.recv(1024) captcha_str = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key).decode() captcha = get_captcha(captcha_str) # 计算得到验证码 print(f&quot;Captcha: &#123;captcha&#125;&quot;) # 向服务器返回验证码 send_data = get_data(2, len(captcha), list(captcha), rc4_key) s.send(send_data) data = s.recv(1024) m = rc4_algorithm(&quot;dec&quot;, data[10:], rc4_key) print(m) s.close() # Captcha: b&#x27;\\xc84\\x06\\x03&#x27; # b&#x27;\\x00\\x10\\x00\\x805\\x00flag_0x00 = \\x00GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;\\x00&#x27; 得到flag为 GFCTF&#123;e8e9071b7a70770bec1f6415c4ed4c1d&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"2021 L3HCTF 部分RE WP","slug":"2021L3HCTF_WP_RE_","date":"2021-11-17T02:00:00.000Z","updated":"2021-11-29T11:41:58.907Z","comments":true,"path":"2021/11/17/2021L3HCTF_WP_RE_/","link":"","permalink":"https://zzzzsky.github.io/2021/11/17/2021L3HCTF_WP_RE_/","excerpt":"","text":"2021 L3HCTF 部分RE WPdouble-joyIDA打开程序，找到main函数进行分析 最关键的是enc_flag 函数, 经过调试，发现传入的参数有2套，都是固定的结构体 1234567typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1; 进入 enc_flag函数，F5，发现很乱，然后patch掉一些用于对齐的代码后，F5, 发现是个VM 调试，发现一共执行了0XCA次 enc_flag, 并且传入的参数是交替的 还原程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include &lt;windows.h&gt;#include &lt;basetsd.h&gt;#include &lt;stdio.h&gt;typedef unsigned int uint32;#define _DWORD uint32typedef struct _struc_1&#123; BYTE* pKey; //指向OPCODE _DWORD* pFlag; //指向FLAG，主要这个FLAG前40个字节是用户输入的，后面一大部分要留给程序用 int i; //指向OPCODE的索引 int stack; //指向了一些 “操作数”，在OPCODE 中存着，比如OPCODE是 \\XE的话，后面4个字节就是一个“操作数”&#125;struc_1;BYTE key1[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0x15, 0xCD, 0x5B, 0x07, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xB1, 0x68, 0xDE, 0x3A, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4C, 0x49, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x76, 0x6F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x20, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x55, 0x43, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x56, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x20, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x07, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x08, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xCC, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x96, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;BYTE key2[] =&#123; 0x11, 0x15, 0x00, 0x00, 0x00, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0E, 0xF7, 0xCB, 0x54, 0x01, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0xAD, 0xDE, 0xED, 0x5E, 0x08, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x44, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xA8, 0xFF, 0xFF, 0xFF, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x54, 0x53, 0x00, 0x00, 0x08, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x4D, 0x4F, 0x00, 0x00, 0x08, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x74, 0x20, 0x00, 0x00, 0x08, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x61, 0x65, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x5B, 0x01, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0C, 0x01, 0x0B, 0x0A, 0x10, 0x25, 0x01, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x02, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x03, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x07, 0x07, 0x00, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x08, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x09, 0x08, 0x12, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0xC7, 0xFE, 0xFF, 0xFF, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x09, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x91, 0xFE, 0xFF, 0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;;void enc_flag(struc_1* st)&#123; BYTE* pKey = st-&gt;pKey; BYTE opcode = 0; _DWORD* pFlag = st-&gt;pFlag; int data1, data2, tmp, index; while (true) &#123; opcode = pKey[st-&gt;i]; //取出对应的opcode st-&gt;i++; //每取出一个opcode， 索引就+1 printf(&quot;------&gt;OPCODE :%d\\n&quot;, opcode); switch (opcode) &#123; case 0: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 + data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x + pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 1: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 - data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x - pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 2: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 * data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x * pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 3: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 / data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x / pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 4: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 % data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x %% pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 5: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 &amp; data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x &amp; pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 6: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 | data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x | pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 7: st-&gt;stack--; data1 = pFlag[st-&gt;stack]; data2 = pFlag[st-&gt;stack - 1]; pFlag[st-&gt;stack - 1] = data1 ^ data2; printf(&quot;pFlag[%d] = pFlag[%d]:%#x ^ pFlag[%d]:%#x;\\n&quot;, st-&gt;stack - 1, st-&gt;stack, data1, st-&gt;stack - 1, data2); continue; case 8: st-&gt;stack--; tmp = pFlag[st-&gt;stack]; index = pFlag[st-&gt;stack - 1]; pFlag[index] = tmp; printf(&quot;pFlag[%d] = %#x;\\n&quot;, index, tmp); st-&gt;stack--; continue; case 9: index = pFlag[st-&gt;stack - 1]; data1 = pFlag[index]; pFlag[st-&gt;stack - 1] = data1; printf(&quot;pFlag[%d] = %#x;\\n&quot;, st-&gt;stack -1, data1); continue; case 10: tmp = pFlag[st-&gt;stack - 1]; if (tmp == 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 11: tmp = pFlag[st-&gt;stack - 1]; if ((int)tmp &lt; 0) &#123; pFlag[st-&gt;stack - 1] = 1; printf(&quot;pFlag[%d] = 1;\\n&quot;, st-&gt;stack - 1); &#125; else &#123; pFlag[st-&gt;stack - 1] = 0; printf(&quot;pFlag[%d] = 0;\\n&quot;, st-&gt;stack - 1); &#125; continue; case 12: data1 = pFlag[st-&gt;stack - 1]; data2 = pFlag[st-&gt;stack - 2]; pFlag[st-&gt;stack - 1] = data2; pFlag[st-&gt;stack - 2] = data1; printf(&quot;exchange pFlag[%d]:%#x, pFlag[%d]:%#x\\n&quot;, st-&gt;stack - 1, data2, st-&gt;stack - 2, data1); continue; case 13: st-&gt;stack--; continue; case 14: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i += 4; pFlag[st-&gt;stack++] = tmp; printf(&quot;pFlag[%d] = %#x\\n&quot;, st-&gt;stack-1, tmp); continue; case 15: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; index = st-&gt;i + 4 + tmp; st-&gt;i = index; continue; case 16: tmp = st-&gt;i + 4; st-&gt;stack--; if (pFlag[st-&gt;stack]) tmp += *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;i = tmp; continue; case 17: tmp = *(_DWORD*)&amp;pKey[st-&gt;i]; st-&gt;stack += tmp; st-&gt;i += 4; continue; case 18: st-&gt;i += 4; return; default: st-&gt;i++; &#125; &#125;&#125;char flag1[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char flag2[4000] = &#123; 0 &#125;; //前40个字节使用户输入的flag，40往后是为了加密flag用到的数据char compare_date[1000] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79, 0&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111222211111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111222211111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD *)flag1; v12.pKey = key1; v12.i = 0; v12.stack = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.stack = 0; for (int i = 0; i &lt; 0XCA; i+=2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); printf(&quot;----------------------------------------------------------------------------&quot;); &#125; return 0; &#125; 调试发现，flag是分组进行加密的,每8个字符一组，共5组 第一组 L3HCTF&#123;*, 只差1个字符, 暴力破解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667char compare_date[] = &#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; struc_1 v12 = &#123; 0 &#125;; struc_1 v13 = &#123; 0 &#125;; memcpy(flag1, &quot;111111111111111111111111111111111111111\\0&quot;, 40); memcpy(flag2, &quot;111111111111111111111111111111111111111\\0&quot;, 40); v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;1&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;1&quot;, 8); for (int j = 32; j &lt; 127; j++) &#123; v12.pFlag = (_DWORD*)flag1; v12.pKey = key1; v12.i = 0; v12.kk = 0; v13.pFlag = (_DWORD*)flag2; v13.pKey = key2; v13.i = 0; v13.kk = 0; memcpy(flag1, &quot;L3HCTF&#123;&quot;, 8); memcpy(flag2, &quot;L3HCTF&#123;&quot;, 8); flag1[7] = j; flag2[7] = j; for (int i = 0; i &lt; 0XCA; i += 2) &#123; enc_flag(&amp;v12); memcpy(flag2, flag1, 40); enc_flag(&amp;v13); memcpy(flag1, flag2, 40); &#125; if (memcmp(flag1, compare_date, 8) == 0) &#123; printf(&quot;%c\\n&quot;, j); getchar(); &#125; &#125; return 0;&#125;//D 发现第一组是L3HCTF&#123;D 然后下面开始还原VM，只需还原出加密每一组的第一个循环就OK 输入flag 为 L3HCTF&#123;D1111222211111111111111111111111 1234第二组为Input: 31 31 31 31 32 32 32 32enc后Output: ec 9d 57 67 94 6a 7e a5 通过打印的日志，追踪Input，来分析如何得到的Output 加密flag的第二组的第一个循环的日志 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564输入：31 31 31 31 32 32 32 32输出：ec 9d 57 67 94 6a 7e a5======以下是打印的日志OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :8pFlag[12] = 0x31313131;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :8pFlag[13] = 0x32323232;------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x31313131;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x32323232;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x32323232; ====------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0x32323232, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0x32323232 / pFlag[24]:0x20; ====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x1919191 ^ pFlag[23]:0x23232320;------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x32323232; ====------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x32323232 + pFlag[23]:0x22b2b2b1; ====------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xce0a6e55;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xce0a6e55;------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0x1;------&gt;OPCODE :9pFlag[25] = 0x6f76;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x6f76 + pFlag[24]:0xce0a6e55;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xce0addcb ^ pFlag[23]:0x54e4e4e3;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9aee3928 + pFlag[22]:0x31313131; ===------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0xce0a6e55; === 上一轮循环剩下的------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x75bcd15;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x75bcd15 + pFlag[22]:0xce0a6e55;------&gt;OPCODE :8pFlag[11] = 0xd5663b6a;====------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x32323232;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0xcc1f6a59; ===------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[25] = 0x20------&gt;OPCODE :12exchange pFlag[25]:0xcc1f6a59, pFlag[24]:0x20------&gt;OPCODE :3pFlag[24] = pFlag[25]:0xcc1f6a59 / pFlag[24]:0x20;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xfe60fb53 ^ pFlag[23]:0xc1f6a590;------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0xcc1f6a59;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0xcc1f6a59 + pFlag[23]:0x3f965ec3;------&gt;OPCODE :14pFlag[24] = 0xb------&gt;OPCODE :9pFlag[24] = 0xd5663b6a;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0xd5663b6a;------&gt;OPCODE :14pFlag[26] = 0x800------&gt;OPCODE :12exchange pFlag[26]:0xd5663b6a, pFlag[25]:0x800------&gt;OPCODE :3pFlag[25] = pFlag[26]:0xd5663b6a / pFlag[25]:0x800;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :5pFlag[25] = pFlag[26]:0x3 &amp; pFlag[25]:0xfffaacc8; ====------&gt;OPCODE :14pFlag[26] = 0xe------&gt;OPCODE :0pFlag[25] = pFlag[26]:0xe + pFlag[25]:0;------&gt;OPCODE :9pFlag[25] = 0x494c;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x494c + pFlag[24]:0xd5663b6a;===------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xd56684b6 ^ pFlag[23]:0xbb5c91c; ===------&gt;OPCODE :0pFlag[22] = pFlag[23]:0xded34daa + pFlag[22]:0x32323232;------&gt;OPCODE :8pFlag[13] = 0x11057fdc; === ------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[2] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[3] = 0x11057fdc;------&gt;OPCODE :18 =============================================v13准备开始------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :9pFlag[22] = 0x13;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x13;------&gt;OPCODE :8pFlag[20] = 0x14;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0x14;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0x14, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x14 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 0;------&gt;OPCODE :10pFlag[21] = 1;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0;------&gt;OPCODE :14pFlag[23] = 0x2------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x2 + pFlag[22]:0;------&gt;OPCODE :8pFlag[19] = 0x2;------&gt;OPCODE :15------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0xa------&gt;OPCODE :12exchange pFlag[22]:0x2, pFlag[21]:0xa------&gt;OPCODE :1pFlag[21] = pFlag[22]:0x2 - pFlag[21]:0xa;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :8pFlag[20] = 0;------&gt;OPCODE :14pFlag[21] = 0x14------&gt;OPCODE :9pFlag[21] = 0;------&gt;OPCODE :14pFlag[22] = 0x14------&gt;OPCODE :12exchange pFlag[22]:0, pFlag[21]:0x14------&gt;OPCODE :1pFlag[21] = pFlag[22]:0 - pFlag[21]:0x14;------&gt;OPCODE :11pFlag[21] = 1;------&gt;OPCODE :10pFlag[21] = 0;------&gt;OPCODE :16------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x2;------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :8pFlag[12] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0x13------&gt;OPCODE :9pFlag[22] = 0x2;------&gt;OPCODE :14pFlag[23] = 0x1------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x1 + pFlag[22]:0x2;------&gt;OPCODE :14pFlag[23] = 0------&gt;OPCODE :0pFlag[22] = pFlag[23]:0 + pFlag[22]:0x3;------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :8pFlag[13] = 0x11057fdc;------&gt;OPCODE :14pFlag[21] = 0xb------&gt;OPCODE :14pFlag[22] = 0xb------&gt;OPCODE :9pFlag[22] = 0x798dcdf9;------&gt;OPCODE :14pFlag[23] = 0xa------&gt;OPCODE :9pFlag[23] = 0x154cbf7; = =====系统中的立即数------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x154cbf7 + pFlag[22]:0x798dcdf9; == 这2个数是固定的------&gt;OPCODE :8pFlag[11] = 0x7ae299f0; =========------&gt;OPCODE :14pFlag[21] = 0xc------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0xcc1f6a59;------&gt;OPCODE :14pFlag[23] = 0xd------&gt;OPCODE :9pFlag[23] = 0x11057fdc;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x11057fdc;========------&gt;OPCODE :14pFlag[24] = 0------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0;------&gt;OPCODE :9pFlag[24] = 0x5354;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x5354 + pFlag[23]:0x1057fdc0; =======------&gt;OPCODE :14pFlag[24] = 0xd------&gt;OPCODE :9pFlag[24] = 0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x11057fdc;------&gt;OPCODE :14pFlag[25] = 0xd------&gt;OPCODE :9pFlag[25] = 0x11057fdc;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x11057fdc, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x11057fdc / pFlag[25]:0x20; ### 0x882bfe------&gt;OPCODE :14pFlag[26] = 0x1------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x1;------&gt;OPCODE :9pFlag[26] = 0x4f4d;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x4f4d + pFlag[25]:0x882bfe;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x887b4b ^ pFlag[24]:0x8be819cc; =====------&gt;OPCODE :7pFlag[23] = pFlag[24]:0x8b606287 ^ pFlag[23]:0x10585114;==------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9b383393 + pFlag[22]:0xcc1f6a59;=====------&gt;OPCODE :8pFlag[12] = 0x67579dec; ######------&gt;OPCODE :14pFlag[21] = 0xd------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0x11057fdc;------&gt;OPCODE :14pFlag[23] = 0xc------&gt;OPCODE :9pFlag[23] = 0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x10------&gt;OPCODE :2pFlag[23] = pFlag[24]:0x10 * pFlag[23]:0x67579dec;------&gt;OPCODE :14pFlag[24] = 0x2------&gt;OPCODE :14pFlag[25] = 0xe------&gt;OPCODE :0pFlag[24] = pFlag[25]:0xe + pFlag[24]:0x2;------&gt;OPCODE :9pFlag[24] = 0x2074;------&gt;OPCODE :0pFlag[23] = pFlag[24]:0x2074 + pFlag[23]:0x7579dec0; === 49------&gt;OPCODE :14pFlag[24] = 0xc------&gt;OPCODE :9pFlag[24] = 0x67579dec;------&gt;OPCODE :14pFlag[25] = 0xb------&gt;OPCODE :9pFlag[25] = 0x7ae299f0;------&gt;OPCODE :0pFlag[24] = pFlag[25]:0x7ae299f0 + pFlag[24]:0x67579dec; =====------&gt;OPCODE :14pFlag[25] = 0xc------&gt;OPCODE :9pFlag[25] = 0x67579dec;------&gt;OPCODE :14pFlag[26] = 0x20------&gt;OPCODE :12exchange pFlag[26]:0x67579dec, pFlag[25]:0x20------&gt;OPCODE :3pFlag[25] = pFlag[26]:0x67579dec / pFlag[25]:0x20;===&#x27;0x33abcef&#x27;------&gt;OPCODE :14pFlag[26] = 0x3------&gt;OPCODE :14pFlag[27] = 0xe------&gt;OPCODE :0pFlag[26] = pFlag[27]:0xe + pFlag[26]:0x3;------&gt;OPCODE :9pFlag[26] = 0x6561;------&gt;OPCODE :0pFlag[25] = pFlag[26]:0x6561 + pFlag[25]:0x33abcef;------&gt;OPCODE :7pFlag[24] = pFlag[25]:0x33b2250 ^ pFlag[24]:0xe23a37dc;------&gt;OPCODE :7pFlag[23] = pFlag[24]:0xe101158c ^ pFlag[23]:0x7579ff34;------&gt;OPCODE :0pFlag[22] = pFlag[23]:0x9478eab8 + pFlag[22]:0x11057fdc; # &#x27;0xa57e6a94&#x27;------&gt;OPCODE :8pFlag[13] = 0xa57e6a94;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0xc------&gt;OPCODE :9pFlag[22] = 0x67579dec;------&gt;OPCODE :8pFlag[2] = 0x67579dec;------&gt;OPCODE :14pFlag[21] = 0x13------&gt;OPCODE :9pFlag[21] = 0x2;------&gt;OPCODE :14pFlag[22] = 0x1------&gt;OPCODE :0pFlag[21] = pFlag[22]:0x1 + pFlag[21]:0x2;------&gt;OPCODE :14pFlag[22] = 0------&gt;OPCODE :0pFlag[21] = pFlag[22]:0 + pFlag[21]:0x3;------&gt;OPCODE :14pFlag[22] = 0xd------&gt;OPCODE :9pFlag[22] = 0xa57e6a94;------&gt;OPCODE :8pFlag[3] = 0xa57e6a94;------&gt;OPCODE :18---------------------------------------------------------------------------- 分析算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758A = FLAG[0:4]B = FLAG[4:8]pFlag[23] = B * 0x10pFlag[24] = B / 0X20 pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = B + pFlag[23] pFlag[23] = (0xCE0A6E55 + 0X6F76) ^ pFlag[23] pFlag[22] = pFlag[23] + A TMP1 = pFlag[22] # 173行 0xcc1f6a59 ***V12导出 # v0pFlag[22] = 0xCE0A6E55 # (过会回来补坑，这个是上一轮循环剩下的) 这个与FLAG无关，是固定的pFlag[22] = 0x75bcd15(立即数) + 0xce0a6e55TMP2 = pFlag[22] # 187行 0xd5663b6a #TMP2 = sum1pFlag[23] = TMP1pFlag[23] = TMP1 * 0X10 # 201pFlag[24] = TMP1 / 0x20 # 213pFlag[23] = pFlag[23] ^ pFlag[24]pFlag[23] = TMP1 + pFlag[23] pFlag[26] = TMP2pFlag[25] = pFlag[26] / 0x800 #233行pFlag[24] = TMP2 + 0x494c ###245pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + B TMP3 = pFlag[22] ### 251行 0x11057fdc ***V12导出 #v1pFlag[22] = 0x154cbf7(立即数) + 0x798dcdf9; #这2个数是固定的 #在第一轮的时候是这个，其他的还没测试TMP4 = pFlag[22] ###407行 0x7ae299f0pFlag[23] = TMP3 * 0X10pFlag[23] = pFlag[23] + 0X5354 # 421 pFlag[24] = TMP4 + TMP3 #441 pFlag[25] = TMP3 / 0x20 #451 ### 0x882bfepFlag[25] = 0x4f4d + pFlag[25] pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23] #465 ## 0x9b383393pFlag[22] = pFlag[23] + TMP1TMP5 = pFlag[22] #### 469 0x67579decpFlag[23] = TMP5 * 0X10pFlag[23] = pFlag[23] + 0x2074 ## 0x7579ff34pFlag[24] = TMP4 + TMP5 ####503行pFlag[25] = TMP5 / 0x20pFlag[25] = pFlag[25] + 0x6561pFlag[24] = pFlag[25] ^ pFlag[24]pFlag[23] = pFlag[24] ^ pFlag[23]pFlag[22] = pFlag[23] + TMP3 # 529行 0xa57e6a94TMP6 = pFlag[22] # 0xa57e6a94 通过 * 0x10 、/0x20、 /0x800、 &amp;3等特征，猜测是xtea， tea算法 一边猜一边还原算法,用C语言写出1轮的循环加密算法 1234567891011121314151617181920int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125; sum_tea 和 sum_xtea，对于每一组来说，初始值是不同的，比如第二组这里是0x798dcdf9 和 0xce0a6e55 最后通过打印三，四，五组第一个循环的日志，来与第二组的日志做对比，找到了所有组的初始的sum_tea 和 sum_xtea 123456int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;; 最终写脚本解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int sum[4][2] = &#123; 0xCE0A6E55, 0x798dcdf9, 0x613673f9, 0x942dbd45, 0xf462799d, 0xaecdac91, 0x878e7f41, 0xc96d9bdd&#125;;int tea_key[4] = &#123; 0X5354, 0x4f4d, 0x2074, 0x6561 &#125;;int xtea_key[4] = &#123; 0x494c, 0X6F76 , 0x6520, 0x4355 &#125;;void encrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v0 += (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); sum_xtea += 0x75bcd15; v1 += (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_tea += 0x154cbf7; v0 += ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); v1 += ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v[0] = v0; v[1] = v1;&#125;void decrypt(int* v, int&amp; sum_xtea, int&amp; sum_tea)&#123; int v0 = v[0], v1 = v[1]; v1 -= ((v0 &lt;&lt; 4) + tea_key[2]) ^ (v0 + sum_tea) ^ ((v0 / 0x20) + tea_key[3]); v0 -= ((v1 &lt;&lt; 4) + tea_key[0]) ^ (v1 + sum_tea) ^ ((v1 / 0x20) + tea_key[1]); sum_tea -= 0x154cbf7;; v1 -= (((v0 &lt;&lt; 4) ^ (v0 / 0x20)) + v0) ^ (sum_xtea + xtea_key[(sum_xtea / 0x800) &amp; 3]); sum_xtea -= 0x75bcd15; v0 -= (((v1 &lt;&lt; 4) ^ (v1 / 0x20)) + v1) ^ (sum_xtea + xtea_key[sum_xtea &amp; 3]); v[0] = v0; v[1] = v1;&#125;char compare_date[100] = //这里是从程序中提取的加密后的flag的值&#123; 0xE8, 0xFA, 0xE0, 0xAE, 0x01, 0x41, 0x3E, 0xFC, 0x92, 0xAD, 0x7C, 0x16, 0xBE, 0x6C, 0xEA, 0x51, 0x00, 0x01, 0x2A, 0x24, 0x1B, 0x1A, 0x51, 0x01, 0x94, 0x66, 0x4D, 0x51, 0xEB, 0xBF, 0x5F, 0x2F, 0x98, 0x63, 0xD3, 0x46, 0xF0, 0xE3, 0xEE, 0x79&#125;;int main()&#123; int v[2] = &#123; 0 &#125;; int* encFlag = (int*)compare_date; //flag的前8个字符爆破得到的 L3HCTF&#123;D for (int j = 0; j &lt; 4; j++) //后32个字符，分4组 &#123; for (int i = 0; i &lt; 20; i++) encrypt(v, sum[j][0], sum[j][1]); //提升sum_xtea 和 sum_tea for (int i = 0; i &lt; 20; i++) decrypt(&amp;encFlag[j * 2 + 2], sum[j][0], sum[j][1]); &#125; char* flag = (char*)&amp;encFlag[2]; printf(&quot;flag is L3HCTF&#123;D%s \\n&quot;, flag); return 0;&#125;// L3HCTF&#123;D0uBle_vM_W1th_dOubIe_TEA&#125; LoadIDA打开程序分析 进入LOAD_PE函数，就是创建了个傀儡进程 在ResumeThread这里下断点，dump，然后foremost分离 注意在foremost分离的时候要把dump下来的程序的MZ头抹去，这样才能分离解密后的PE文件来 IDA打开分析 获取flag后，对flag中的字符在 0x30-0x39或 a-f 范围做了个小处理 12340x30 - 0x39 ---&gt; 0x00 - 0x09a - f ---&gt; 0xA ---0xF# 然后假设输入的是123f --&gt; 0x12, 0x3f 存在了0x434380的位置 注意这里全是对应的十六进制，猜测输入的flag的范围就是[0-9a-f] 最终434380处的数据是13个。下面又分为9 + 4 个，正好是3和2的平方，并且下面验证的时候也是分为9 + 4进行验证的 猜测是3 * 3 + 2 * 2的某个矩阵运算, 在上述图89行位置下断点，修改src处的数据为100010001, 12341 0 00 1 00 0 1正好是单位矩阵 然后运行，加密后发现Src处的数据没变，但是v29处的数据全乱了，猜测是逆矩阵 提取出加密后Src 和 v29处的数据 12345678Src: 1 0 -90 -1 -6-1 -2 -4 v29:7 330 13 写脚本求逆矩阵，并转换为flag 12345678910111213141516171819import numpyif __name__ == &quot;__main__&quot;: a = numpy.array([[1, 0, -9], [0, -1, -6], [-1, -2, -4]]) b = numpy.array([[7, 3], [30, 13]]) a_inv = numpy.linalg.inv(a) b_inv = numpy.linalg.inv(b) a_list = [list(i) for i in a_inv] b_list = [list(i) for i in b_inv] flag_list = a_list[0] + a_list[1] + a_list[2] + b_list[0] + b_list[1] flag_list = [int(i) &amp; 0xff for i in flag_list] flag = bytes(flag_list).hex() print(flag) # f812f706f306ff02ff0dfde207 拼接后进行验证，Load.exe在 ResumeThread那里下断点，输入flag，程序断下，在运行dump提取出来的exe，验证成功 最终flag为 : flag&#123;f812f706f306ff02ff0dfde207&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]},{"title":"2021强网拟态_babyre","slug":"2021强网拟态_babyre","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-29T11:42:10.176Z","comments":true,"path":"2021/11/12/2021强网拟态_babyre/","link":"","permalink":"https://zzzzsky.github.io/2021/11/12/2021%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81_babyre/","excerpt":"","text":"2021强网拟态rebabyreIDA动态调试，进入关键函数 分析函数，提取数据，还原算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;typedef unsigned char BYTE;typedef unsigned long DWORD;char _flag[] = &quot;1234567890123456&quot;;DWORD cmp_data[8] = &#123;0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623&#125;;DWORD key[60] = &#123;0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f&#125;;DWORD dword_405420[256] = &#123;0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042&#125;;DWORD dword_405820[256] = &#123;0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257&#125;;DWORD dword_405C20[256] = &#123;0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8&#125;;DWORD dword_405020[256] = &#123;0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0&#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123;0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE HIBYTE(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;DWORD _enc_flag[4] = &#123;0&#125;;int main()&#123; DWORD *flag = (DWORD *)_flag; int key_index = 0; DWORD v9 = 0, v8 = 0, v7 = 0, i = 0; DWORD v11 = 0, v13 = 0, v15 = 0, v17 = 0; DWORD v12 = 0, v14 = 0, v16 = 0, v18 = 0; v9 = flag[3] ^ key[key_index]; key_index += 1; v8 = flag[2] ^ key[key_index]; key_index += 1; v7 = flag[1] ^ key[key_index]; key_index += 1; i = flag[0] ^ key[key_index]; key_index += 1; for (int j = 0; j &lt; 13; j++) &#123; v11 = dword_405420[BYTE1(v9)] ^ dword_405820[BYTE2(v8)] ^ dword_405C20[HIBYTE(v7)] ^ dword_405020[BYTE0(i)]; v13 = dword_405420[BYTE1(i)] ^ dword_405820[BYTE2(v9)] ^ dword_405C20[HIBYTE(v8)] ^ dword_405020[BYTE0(v7)]; v15 = dword_405420[BYTE1(v7)] ^ dword_405820[BYTE2(i)] ^ dword_405C20[HIBYTE(v9)] ^ dword_405020[BYTE0(v8)]; v17 = dword_405420[BYTE1(v8)] ^ dword_405820[BYTE2(v7)] ^ dword_405C20[HIBYTE(i)] ^ dword_405020[BYTE0(v9)]; //最后一轮时 V11, V13, V15, V17的值应该如下 // v11 = 0xf048c314; // v13 = 0xb4db6016; // v15 = 0x8eee5336; // v17 = 0x948726e2; v9 = v17 ^ key[key_index]; key_index += 1; v8 = v15 ^ key[key_index]; key_index += 1; v7 = v13 ^ key[key_index]; key_index += 1; i = v11 ^ key[key_index]; key_index += 1; &#125; //运行到这里，v9, v8, v7, i的数据应该如下 // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; v12 = (RijnDael_AES_LONG_inv_406120[BYTE1(v9)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v8)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v7)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(i)]; v14 = (RijnDael_AES_LONG_inv_406120[BYTE1(i)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v9)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v8)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v7)]; v16 = (RijnDael_AES_LONG_inv_406120[BYTE1(v7)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(i)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(v9)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v8)]; v18 = (RijnDael_AES_LONG_inv_406120[BYTE1(v8)] &lt;&lt; 8) | (RijnDael_AES_LONG_inv_406120[BYTE2(v7)] &lt;&lt; 16) | (RijnDael_AES_LONG_inv_406120[HIBYTE(i)] &lt;&lt; 24) | RijnDael_AES_LONG_inv_406120[BYTE0(v9)]; //运行到这里，v12, v14, v16, v18的数据应该如下 // 0xe82b2381 v12 // 0x70ea91de v14 // 0xe7e1d2f1 v16 // 0xdb36973b v18 _enc_flag[3] = v18 ^ key[key_index]; key_index += 1; _enc_flag[2] = v16 ^ key[key_index]; key_index += 1; _enc_flag[1] = v14 ^ key[key_index]; key_index += 1; _enc_flag[0] = v12 ^ key[key_index]; for (int i = 0; i &lt; 4; i++) &#123; printf(&quot;%#X, &quot;, _enc_flag[i]); &#125; return 0;&#125; 写解密脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;windows.h&gt;size_t count = 0;DWORD key[60] = &#123; 0xc3bb95b, 0x578c9d63, 0x7faca21c, 0x29522e93, 0xb268681, 0xda705e01, 0xa7732a53, 0x72e0c013, 0x4b4fcf3b, 0xe46963a6, 0x3eeea9d2, 0xefb38fbb, 0xd156d880, 0x7d037452, 0xd593ea40, 0xd5223126, 0xaf26ac9d, 0xda87ca74, 0xd15d2669, 0x6cadaad, 0xac55acd2, 0xa8909e12, 0xb1db66, 0xcc4c1870, 0x75a166e9, 0xbdaec1d, 0xd797fcc4, 0x9cd3659b, 0x4c532c0, 0xa8214574, 0xccfdc316, 0x6019b4a2, 0x7e7b8af4, 0xdc4d10d9, 0x4b44995f, 0x2ca5c858, 0xace477b4, 0x64dc8662, 0xace477b4, 0xbbc35df5, 0xa2369a2d, 0x97098986, 0x67e15107, 0xfd0b6e21, 0xc838f1d6, 0xc838f1d6, 0x17272a41, 0x38f9ff4a, 0x353f13ab, 0xf0e8d881, 0x9aea3f26, 0x5f3df40c, 0x0, 0xdf1fdb97, 0x2fded50b, 0x49b04218, 0xf3000000, 0xc3fa1e0f, 0xf3000000, 0x841f &#125;;DWORD dword_405420[256] = &#123; 0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x3e34b93, 0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 0x5ab1de49, 0x1bba2567, 0xeea4598, 0xc0fe5de1, 0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x24b72e2, 0x8f1fe357, 0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x837d3a5, 0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 0x8a213ef9, 0x6dd963d, 0x53eddae, 0xbde64d46, 0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 0xa7ca147, 0xf427ce9, 0x1e84f8c9, 0x0, 0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0xd090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x775af4c, 0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0xbd49836, 0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x99fead4, 0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 0xca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 0x1a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042 &#125;;DWORD dword_405820[256] = &#123; 0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 0xcc889176, 0x2f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x8f9942b, 0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 0x2830f287, 0xbf23b2a5, 0x302ba6a, 0x16ed5c82, 0xcf8a2b1c, 0x79a792b4, 0x7f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x506d5be, 0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 0xc471055d, 0x6046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x0, 0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0xefdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 0xf0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 0xa0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x90e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 0x1f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x4f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0xbfb2e41, 0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0xdff4195, 0xa8397101, 0xc08deb3, 0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257 &#125;;DWORD dword_405C20[256] = &#123; 0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x3e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 0x30f28728, 0x23b2a5bf, 0x2ba6a03, 0xed5c8216, 0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x6d5be05, 0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x532e18a, 0xa475ebf6, 0xb39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 0x71055dc4, 0x46fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x7888b89, 0xe7385b19, 0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x0, 0x9838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 0xf563885, 0x3d1ed5ae, 0x3627392d, 0xa64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 0xcb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0xe0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 0xdec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 0x9d04ea5e, 0x15d358c, 0xfa737487, 0xfb2e410b, 0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x8deb30c, 0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8 &#125;;DWORD dword_405020[256] = &#123; 0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 0x2752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 0x728ebb2, 0x3c2b52f, 0x9a7bc586, 0xa50837d3, 0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x69f715e, 0x51106ebd, 0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 0x55dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x0, 0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0xfe75793, 0xd296eeb4, 0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 0xaba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0xb0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0xd927850, 0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x97826cd, 0xf418596e, 0x1b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 0x8cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 0xf7daec41, 0xe50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 0x4ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 0xc25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0 &#125;;BYTE RijnDael_AES_LONG_inv_406120[256] = &#123; 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D &#125;;BYTE BYTE1(DWORD _data)&#123; return (_data &gt;&gt; 8) &amp; 0XFF;&#125;BYTE BYTE2(DWORD _data)&#123; return (_data &gt;&gt; 16) &amp; 0XFF;&#125;BYTE BYTE3(DWORD _data)&#123; return (_data &gt;&gt; 24) &amp; 0XFF;&#125;BYTE BYTE0(DWORD _data)&#123; return _data &amp; 0XFF;&#125;// void brute(DWORD target /*, unsigned char *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4*/)// &#123;// for (unsigned char i1 = 0; i1 &lt; 256; i1++)// &#123;// for (unsigned char i2 = 0; i2 &lt; 256; i2++)// &#123;// for (unsigned char i3 = 0; i3 &lt; 256; i3++)// &#123;// for (unsigned char i4 = 0; i4 &lt; 256; i4++)// &#123;// if ((dword_405020[i1] ^ dword_405420[i2] ^ dword_405820[i3] ^ dword_405C20[i4]) == target)// &#123;// printf(&quot;brute found for %#x: %d %d %d %d\\n&quot;, target, i1, i2, i3, i4);// // *a1 = i1;// // *a2 = i2;// // *a3 = i3;// // *a4 = i4;// return;// &#125;// &#125;// &#125;// &#125;// &#125;// &#125;void brute(DWORD target, unsigned char* a1, unsigned char* a2, unsigned char* a3, unsigned char* a4)&#123; for (size_t i1 = 0; i1 &lt; 256; i1++) &#123; for (size_t i2 = 0; i2 &lt; 256; i2++) &#123; for (size_t i3 = 0; i3 &lt; 256; i3++) &#123; for (size_t i4 = 0; i4 &lt; 256; i4++) &#123; if ((dword_405420[i1] ^ dword_405820[i2] ^ dword_405C20[i3] ^ dword_405020[i4]) == target) &#123; printf(&quot;%d - brute found for %x:%d %d %d %d\\n&quot;, count++, target, i1, i2, i3, i4); *a1 = i1; *a2 = i2; *a3 = i3; *a4 = i4; &#125; &#125; &#125; &#125; &#125;&#125;unsigned char findIndex1(BYTE data)&#123; BYTE* array = RijnDael_AES_LONG_inv_406120; for (unsigned char i = 0; i &lt; 256; i++) &#123; if (array[i] == data) return i; &#125; return -1;&#125;void decrypt(DWORD* miwen, DWORD* flag)&#123; int key_index = 59; DWORD v12, v14, v16, v18; DWORD v11, v13, v15, v17; unsigned char _v9[4] = &#123; 0 &#125;; unsigned char _v8[4] = &#123; 0 &#125;; unsigned char _v7[4] = &#123; 0 &#125;; unsigned char _i[4] = &#123; 0 &#125;; DWORD v9, v8, v7, i; v12 = miwen[0] ^ key[key_index--]; v14 = miwen[1] ^ key[key_index--]; v16 = miwen[2] ^ key[key_index--]; v18 = miwen[3] ^ key[key_index--]; // 得到v9, v8, v7, i; _i[0] = findIndex1(BYTE0(v12)); _v9[1] = findIndex1(BYTE1(v12)); _v8[2] = findIndex1(BYTE2(v12)); _v7[3] = findIndex1(BYTE3(v12)); _v7[0] = findIndex1(BYTE0(v14)); _i[1] = findIndex1(BYTE1(v14)); _v9[2] = findIndex1(BYTE2(v14)); _v8[3] = findIndex1(BYTE3(v14)); _v8[0] = findIndex1(BYTE0(v16)); _v7[1] = findIndex1(BYTE1(v16)); _i[2] = findIndex1(BYTE2(v16)); _v9[3] = findIndex1(BYTE3(v16)); _v9[0] = findIndex1(BYTE0(v18)); _v8[1] = findIndex1(BYTE1(v18)); _v7[2] = findIndex1(BYTE2(v18)); _i[3] = findIndex1(BYTE3(v18)); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; // v9 = 0x948726e2; // v8 = 0x51f188a1; // v7 = 0x9b05b51d; // i = 0xb9f8810c; for (int j = 0; j &lt; 13; j++) &#123; v11 = i ^ key[key_index--]; v13 = v7 ^ key[key_index--]; v15 = v8 ^ key[key_index--]; v17 = v9 ^ key[key_index--]; brute(v11, &amp;_v9[1], &amp;_v8[2], &amp;_v7[3], &amp;_i[0]); brute(v13, &amp;_i[1], &amp;_v9[2], &amp;_v8[3], &amp;_v7[0]); brute(v15, &amp;_v7[1], &amp;_i[2], &amp;_v9[3], &amp;_v8[0]); brute(v17, &amp;_v8[1], &amp;_v7[2], &amp;_i[3], &amp;_v9[0]); v9 = *(DWORD*)_v9; v8 = *(DWORD*)_v8; v7 = *(DWORD*)_v7; i = *(DWORD*)_i; &#125; flag[0] = i ^ key[key_index--]; flag[1] = v7 ^ key[key_index--]; flag[2] = v8 ^ key[key_index--]; flag[3] = v9 ^ key[key_index--];&#125;int main()&#123; printf(&quot;Start...\\n&quot;); DWORD cmp_data[8] = &#123; 0xE82BA79E, 0x83EA91DE, 0x241BCCFE, 0x2836973B, 0x5F86C92D, 0x0C8094E88, 0x0FEC81BB0, 0x0D5277623 &#125;; //DWORD cmp_data[8] = &#123;0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6, 0X21266A63, 0XE7FC84AC, 0XEEDD698D, 0XE64535D6&#125;; //拿1234567890123456做测试 DWORD flag[8] = &#123; 0 &#125;; decrypt(cmp_data, flag); decrypt(&amp;cmp_data[4], &amp;flag[4]); printf(&quot;flag: %s\\n\\n&quot;, (char*)flag); char* tmp = (char*)flag; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X, &quot;, tmp[i]); &#125; return 0;&#125; 最终跑出来的数据为 稍作处理 123456789101112#include &lt;stdio.h&gt;int main()&#123; unsigned int a[] = &#123;0XFFFFFFF2, 0XFFFFFF88, 0X35, 0X49, 0XFFFFFFF8, 0X5C, 0X2A, 0X4, 0XFFFFFFA8, 0X4E, 0XFFFFFF86, 0XFFFFFF9E, 0XFFFFFFBE, 0XFFFFFFF9, 0X2A, 0XE, 0XFFFFFFC6, 0X4, 0XFFFFFF94, 0X56, 0X14, 0XFFFFFF89, 0X4C, 0X4C, 0X2E, 0XFFFFFF9C, 0X17, 0XFFFFFFC4, 0XFFFFFFC2, 0XFFFFFFA7, 0XFFFFFF82, 0X1F&#125;; for (int i = 0; i &lt; 32; i++) &#123; printf(&quot;%X &quot;, a[i] &amp; 0xff); &#125; return 0;&#125;//F2 88 35 49 F8 5C 2A 4 A8 4E 86 9E BE F9 2A E C6 4 94 56 14 89 4C 4C 2E 9C 17 C4 C2 A7 82 1F 找到源程序，调试起来，修改flag，进行验证 修改为 运行 发现程序输出success 所以最终的flag应该是 1flag = b&#x27;flag&#123;\\xF2\\x88\\x35\\x49\\xF8\\x5C\\x2A\\x4\\xA8\\x4E\\x86\\x9E\\xBE\\xF9\\x2A\\xE\\xC6\\x4\\x94\\x56\\x14\\x89\\x4C\\x4C\\x2E\\x9C\\x17\\xC4\\xC2\\xA7\\x82\\x1F&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]},{"title":"陇原战\"疫\"2021网络安全大赛_RE_WP","slug":"陇原战疫2021_RE_WP","date":"2021-11-11T02:00:00.000Z","updated":"2021-11-29T11:44:57.427Z","comments":true,"path":"2021/11/11/陇原战疫2021_RE_WP/","link":"","permalink":"https://zzzzsky.github.io/2021/11/11/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021_RE_WP/","excerpt":"","text":"陇原战”疫”2021网络安全大赛_RE_WPEasyRe方法一IDA打开分析 发现sub_4111406这个函数是对输入的flag进行加密，然后将加密后的数据存放到0X41A14C中 来到sub_4111406函数，并不能F5, 直接动态调试一直跟 、 发现程序在不断的生成一些数据，长度是32 多次调试，不同输入，这里获取的数据是一样的 分析，还原算法 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD * enc(char* flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)flag; DWORD* pdw_key = (DWORD*)key; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 7; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13; pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 17; &#125; return pdw_flag;&#125;int main()&#123; char flag[33] = &quot;12345678901234567890123456789012&quot;; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; enc(flag, key); return 0; //在这里下断点观察加密后的数据是否与IDA调试时生成的一样&#125; 在末尾下断点调试 IDA调试运行下断点观察加密后的数据 发现是一样的，还原加密算法成功，现在开始写解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;windows.h&gt;VOID dec_shift_xor(DWORD* mingwen, int shiftlen) &#123; //pdw_flag[i] ^= pdw_flag[i] &lt;&lt; 13 类似这种加密方式，知道加密后的，解密得到原来的数据 //mingwen指向明文 //shiftlen指向移位的的位数 DWORD data = *mingwen; DWORD mask = 1; for (int i = 0; i &lt; shiftlen - 1; i++) &#123; // 构造mask mask = (mask &lt;&lt; 1) + 1; &#125; DWORD zuidi2wei = data &amp; mask; int count = 32 / shiftlen; count = 32 % shiftlen == 0 ? count : count + 1; for (int i = 0; i &lt; count; i++) &#123; zuidi2wei &lt;&lt;= shiftlen; mask &lt;&lt;= shiftlen; data ^= zuidi2wei; zuidi2wei = data &amp; mask; &#125; *mingwen = data;&#125;DWORD* dec(char* enc_flag, char* key)&#123; DWORD* pdw_flag = (DWORD*)enc_flag; DWORD* pdw_key = (DWORD*)key; for (int i = 7; i &gt;=0; i--) &#123; dec_shift_xor(&amp;pdw_flag[i], 17); pdw_flag[i] ^= pdw_key[(7 * i + 5) % 8]; dec_shift_xor(&amp;pdw_flag[i], 13); pdw_flag[i] ^= pdw_flag[(5 * i + 3) % 8]; pdw_flag[i] ^= pdw_key[(7 * i + 3) % 8]; dec_shift_xor(&amp;pdw_flag[i], 7); &#125; for (int i = 0; i &lt; 8; i++) &#123; pdw_flag[i] ^= pdw_key[(7 * i + 2) % 8]; &#125; return pdw_flag;&#125;int main()&#123; char key[32] = &#123; 12, 21, 30, 39, 32, 41, 50, 59, 68, 77, 86, 95, 88, 97, 106, 115, 124, 133, 142, 151, 144, 153, 162, 171, 180, 189, 198, 207, 200, 209, 218, 227&#125;; char enc_flag[33] = &#123; 0x15, 0x86, 0x0F, 0xF9, 0x3D, 0x7C, 0x82, 0xC8, 0x63, 0x32, 0xD7, 0x1B, 0x54, 0x74, 0x0C, 0xA9, 0x05, 0x4E, 0x3F, 0x7D, 0x19, 0xBC, 0xE4, 0x53, 0x7F, 0x39, 0x5B, 0xA8, 0x5E, 0xA4, 0xB2, 0xD4,0&#125;; //提取的0X41A058处的数据 dec(enc_flag, key); printf(&quot;%s&quot;, enc_flag); return 0;&#125; 得到 fc5e038d38a57032085441e7fe7010b0，加上 flag{} 得到 flag&#123;fc5e038d38a57032085441e7fe7010b0&#125; 方法二去花指令 123456789101112131415161718192021222324252627282930313233from ida_bytes import get_bytes, patch_bytesimport readdr = 0x415B53end = 0x0415B79buf = get_bytes(addr, end - addr)buf_str = &quot;&quot;.join([chr(i) for i in list(buf)])pattern = r&quot;\\xE8\\x01\\x00\\x00\\x00.\\x33\\xDB\\x33\\xC0\\x33\\xC9\\x59\\x83\\xC0([\\s\\S])\\xBB([\\s\\S])\\x00\\x00\\x00\\xF7\\xE3\\x83\\xC1\\x20\\x83\\xC0([\\s\\S])\\x33\\xC3\\x51(\\x88\\x45[\\s\\S])\\xC3.&quot;def handler(s): eax = ord(s.group(1)[0]) ebx = ord(s.group(2)[0]) tmp = ord(s.group(3)[0]) c = s.group(4) eax = eax * ebx eax += tmp eax ^= ebx patch_ = &quot;\\xB8&quot; + chr(eax) + &quot;\\x00\\x00\\x00&quot; return patch_ + &#x27;\\x90&#x27;*(0x25-5-5) + c + &quot;\\x90&quot; * 2buf = re.sub(pattern, handler, buf_str, flags=re.I)buf_bytes = bytes([ord(i) for i in buf])patch_bytes(addr, buf_bytes)print(&quot;OK&quot;) Z3模块解决 12345678910111213141516171819202122232425262728293031323334from z3 import *if __name__ == &quot;__main__&quot;: enc = [0xF90F8615, 0xC8827C3D, 0x1BD73263, 0x0A90C7454, 0x7D3F4E05, 0x53E4BC19, 0xA85B397F, 0xD4B2A45E] v5 = [0] * 8 flag = [BitVec(f&quot;flag_&#123;i&#125;&quot;, 32) for i in range(8)] s = Solver() v4 = [0x271E150C, 0x3B322920, 0x5F564D44, 0x736A6158, 0x978E857C, 0xABA29990, 0xCFC6BDB4, 0xE3DAD1C8] for i in range(8): v5[i] = flag[i] ^ v4[(7 * i + 2) % 8] for j in range(8): v5[j] ^= v5[j] &lt;&lt; 7 v5[j] ^= v4[(7 * j + 3) % 8] v5[j] ^= v5[(5 * j + 3) % 8] v5[j] ^= v5[j] &lt;&lt; 13 v5[j] ^= v4[(7 * j + 5) % 8] v5[j] ^= v5[j] &lt;&lt; 17 for i in range(8): s.add(v5[i] == enc[i]) assert s.check() == sat m = s.model() flag = [int.to_bytes(m[i].as_long(), 4, byteorder=&quot;little&quot;).decode() for i in flag] print(&quot;&quot;.join(flag)) EasyRe_Revenge此题与EasyRe_Revenge一样，只是把密文换了，替换上图中的enc_flag即可 1char enc_flag[33] = &#123; 66, 176, 232, 238, 108, 238, 208, 87, 50, 75, 245, 243, 214, 183, 240, 211, 137, 195, 97, 10, 64, 186, 199, 56, 44, 158, 61, 12, 132, 146, 74, 214,0 &#125;; 后来发现，原来EasyRe那道题目，flag直接存在字符串中了，所以把密文换了，才有了这个EasyRe_Revenge findmeIDA打开分析 来到 403844 这个位置 很显然这个位置不可能是strcmp，观察发现404840那个地址处还存了个函数的地址 sub_401866，估计程序有地方把403844这个地方的地址给替换掉了 来到401866位置 分析401767函数，发现是明显的RC4加密 随便输入一个假的flag，12345678901234567890123456， 然后断下，看加密后的数据 写脚本得到密钥流 12345678fake_flag = &quot;12345678901234567890123456&quot;enc_fake_flag = [ 0xD5, 0x25, 0xE2, 0xB6, 0xF1, 0x99, 0x4B, 0xD4, 0xB5, 0x1B, 0x81, 0xD0, 0x47, 0x8F, 0xEF, 0x35, 0x05, 0x46, 0x48, 0xEB, 0x8C, 0x21, 0x6C, 0xB8, 0x05, 0x8D]key = [ord(fake_flag[i]) ^ enc_fake_flag[i] for i in range(26)]print(key)# [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187] 然后提取出dword_403040解密即可 12345enc = [0xFFFFFFB7, 0x52, 0x0FFFFFF85, 0x0FFFFFFC1, 0x0FFFFFF90, 0x0FFFFFFE9, 0x7, 0xFFFFFFB8, 0x0FFFFFFE4, 0x1A, 0x0FFFFFFC3, 0x0FFFFFFBD, 0x1D, 0x0FFFFFF8E, 0x0FFFFFF85, 0x46, 0x0, 0x21, 0x44, 0x0FFFFFFAF, 0x0FFFFFFEF, 0x70, 0x32, 0x0FFFFFFB5, 0x11, 0x0FFFFFFC6]key = [228, 23, 209, 130, 196, 175, 124, 236, 140, 43, 176, 226, 116, 187, 218, 3, 50, 126, 113, 219, 189, 19, 95, 140, 48, 187]flag = [chr((enc[i] &amp; 0XFF) ^ key[i]) for i in range(26)]print(&quot;&quot;.join(flag))# SETCTF&#123;Th1s_i5_E2_5tRcm9!&#125; power拿到题目，附件是ARM汇编源文件 直接用arm-none-eabi-as.exe power编译下生成a.out IDA打开 发现是AES加密，这里写的是CBC模式，但其实是ECB模式，写脚本解密即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Cipher import AESimport base64import binasciiclass Aescrypt(): def __init__(self, key, model, iv): self.key = self.add_16(key) self.model = model self.iv = iv def add_16(self, par): if type(par) == str: par = par.encode() while len(par) % 16 != 0: par += b&#x27;\\x00&#x27; return par def aesencrypt(self, text): text = self.add_16(text) if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.encrypt_text = self.aes.encrypt(text) return self.encrypt_text def aesdecrypt(self, text): if self.model == AES.MODE_CBC: self.aes = AES.new(self.key, self.model, self.iv) elif self.model == AES.MODE_ECB: self.aes = AES.new(self.key, self.model) self.decrypt_text = self.aes.decrypt(text) self.decrypt_text = self.decrypt_text.strip(b&quot;\\x00&quot;) return self.decrypt_textif __name__ == &#x27;__main__&#x27;: passwd = b&quot;this_is_a_key!!!&quot; enc_flag_str = &quot;1030a9254d44937bed312da03d2db9adbec5762c2eca7b5853e489d2a140427b&quot; enc_flag = binascii.unhexlify(enc_flag_str) aescryptor = Aescrypt(passwd, AES.MODE_ECB, None) # ECB text = aescryptor.aesdecrypt(enc_flag) print(&quot;明文:&quot;, text) # 明文: b&#x27;flag&#123;y0u_found_the_aes_12113112&#125;&#x27; Eat_something核心代码在Eat_something.wasm中 找到工具将wasm转为.o文件 https://www.52pojie.cn/thread-1438499-1-1.html 用IDA打开，找到w2c_checkright函数，这是验证flag的地方 核心算法就是这一句 v13 != (i32_load(w2c_memory, v16 + 12LL) ^ (2 * v10)) 翻译下就是enc[i] != i ^ (flag[i] * 2) 将enc提取出来，写脚本即可 123456789101112enc = [0x86, 0x8B, 0xAA, 0x85, 0xAC, 0x89, 0xF0, 0xAF, 0xD8, 0x69, 0xD6, 0xDD, 0xB2, 0xBF, 0x6E, 0xE5, 0xAE, 0x99, 0xCC, 0xD5, 0xBC, 0x8B, 0xF2, 0x7D, 0x7A, 0xE3, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x21, 0x00, 0x59, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x72, 0x6F, 0x6E, 0x67, 0x21, 0x00] flag = []for i in range(26): flag .append(chr((i ^ enc[i]) // 2))print(&quot;&quot;.join(flag))# CETCTF&#123;Th0nk_Y0u_DocTOr51&#125; 最后将CETCTF 改为 SETCTF即为flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"}],"tags":[{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://zzzzsky.github.io/categories/python/"},{"name":"CTF","slug":"CTF","permalink":"https://zzzzsky.github.io/categories/CTF/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"struct","slug":"struct","permalink":"https://zzzzsky.github.io/tags/struct/"},{"name":"CTFWP","slug":"CTFWP","permalink":"https://zzzzsky.github.io/tags/CTFWP/"},{"name":"z3","slug":"z3","permalink":"https://zzzzsky.github.io/tags/z3/"},{"name":"ollvm","slug":"ollvm","permalink":"https://zzzzsky.github.io/tags/ollvm/"},{"name":"真机调试","slug":"真机调试","permalink":"https://zzzzsky.github.io/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"},{"name":"安卓","slug":"安卓","permalink":"https://zzzzsky.github.io/tags/%E5%AE%89%E5%8D%93/"},{"name":"vm","slug":"vm","permalink":"https://zzzzsky.github.io/tags/vm/"}]}